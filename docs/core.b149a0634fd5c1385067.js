(window.webpackJsonp=window.webpackJsonp||[]).push([[1],[,function(module,exports,__webpack_require__){eval("// extracted by mini-css-extract-plugin\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2RiMS5jc3M/YzE0OSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiIxLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1\n")},function(module,exports,__webpack_require__){eval("__webpack_require__(3);\n\nmodule.exports = 'ui.bootstrap';\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYW5ndWxhci11aS1ib290c3RyYXAvaW5kZXguanM/ZmE5MSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxtQkFBTyxDQUFDLENBQTBCOztBQUVsQyIsImZpbGUiOiIyLmpzIiwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZSgnLi9kaXN0L3VpLWJvb3RzdHJhcC10cGxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gJ3VpLmJvb3RzdHJhcCc7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2\n")},function(module,exports){eval("/*\n * angular-ui-bootstrap\n * http://angular-ui.github.io/bootstrap/\n\n * Version: 2.5.6 - 2017-10-14\n * License: MIT\n */angular.module(\"ui.bootstrap\", [\"ui.bootstrap.tpls\", \"ui.bootstrap.collapse\",\"ui.bootstrap.tabindex\",\"ui.bootstrap.accordion\",\"ui.bootstrap.alert\",\"ui.bootstrap.buttons\",\"ui.bootstrap.carousel\",\"ui.bootstrap.dateparser\",\"ui.bootstrap.isClass\",\"ui.bootstrap.datepicker\",\"ui.bootstrap.position\",\"ui.bootstrap.datepickerPopup\",\"ui.bootstrap.debounce\",\"ui.bootstrap.multiMap\",\"ui.bootstrap.dropdown\",\"ui.bootstrap.stackedMap\",\"ui.bootstrap.modal\",\"ui.bootstrap.paging\",\"ui.bootstrap.pager\",\"ui.bootstrap.pagination\",\"ui.bootstrap.tooltip\",\"ui.bootstrap.popover\",\"ui.bootstrap.progressbar\",\"ui.bootstrap.rating\",\"ui.bootstrap.tabs\",\"ui.bootstrap.timepicker\",\"ui.bootstrap.typeahead\"]);\nangular.module(\"ui.bootstrap.tpls\", [\"uib/template/accordion/accordion-group.html\",\"uib/template/accordion/accordion.html\",\"uib/template/alert/alert.html\",\"uib/template/carousel/carousel.html\",\"uib/template/carousel/slide.html\",\"uib/template/datepicker/datepicker.html\",\"uib/template/datepicker/day.html\",\"uib/template/datepicker/month.html\",\"uib/template/datepicker/year.html\",\"uib/template/datepickerPopup/popup.html\",\"uib/template/modal/window.html\",\"uib/template/pager/pager.html\",\"uib/template/pagination/pagination.html\",\"uib/template/tooltip/tooltip-html-popup.html\",\"uib/template/tooltip/tooltip-popup.html\",\"uib/template/tooltip/tooltip-template-popup.html\",\"uib/template/popover/popover-html.html\",\"uib/template/popover/popover-template.html\",\"uib/template/popover/popover.html\",\"uib/template/progressbar/bar.html\",\"uib/template/progressbar/progress.html\",\"uib/template/progressbar/progressbar.html\",\"uib/template/rating/rating.html\",\"uib/template/tabs/tab.html\",\"uib/template/tabs/tabset.html\",\"uib/template/timepicker/timepicker.html\",\"uib/template/typeahead/typeahead-match.html\",\"uib/template/typeahead/typeahead-popup.html\"]);\nangular.module('ui.bootstrap.collapse', [])\n\n  .directive('uibCollapse', ['$animate', '$q', '$parse', '$injector', function($animate, $q, $parse, $injector) {\n    var $animateCss = $injector.has('$animateCss') ? $injector.get('$animateCss') : null;\n    return {\n      link: function(scope, element, attrs) {\n        var expandingExpr = $parse(attrs.expanding),\n          expandedExpr = $parse(attrs.expanded),\n          collapsingExpr = $parse(attrs.collapsing),\n          collapsedExpr = $parse(attrs.collapsed),\n          horizontal = false,\n          css = {},\n          cssTo = {};\n\n        init();\n\n        function init() {\n          horizontal = !!('horizontal' in attrs);\n          if (horizontal) {\n            css = {\n              width: ''\n            };\n            cssTo = {width: '0'};\n          } else {\n            css = {\n              height: ''\n            };\n            cssTo = {height: '0'};\n          }\n          if (!scope.$eval(attrs.uibCollapse)) {\n            element.addClass('in')\n              .addClass('collapse')\n              .attr('aria-expanded', true)\n              .attr('aria-hidden', false)\n              .css(css);\n          }\n        }\n\n        function getScrollFromElement(element) {\n          if (horizontal) {\n            return {width: element.scrollWidth + 'px'};\n          }\n          return {height: element.scrollHeight + 'px'};\n        }\n\n        function expand() {\n          if (element.hasClass('collapse') && element.hasClass('in')) {\n            return;\n          }\n\n          $q.resolve(expandingExpr(scope))\n            .then(function() {\n              element.removeClass('collapse')\n                .addClass('collapsing')\n                .attr('aria-expanded', true)\n                .attr('aria-hidden', false);\n\n              if ($animateCss) {\n                $animateCss(element, {\n                  addClass: 'in',\n                  easing: 'ease',\n                  css: {\n                    overflow: 'hidden'\n                  },\n                  to: getScrollFromElement(element[0])\n                }).start()['finally'](expandDone);\n              } else {\n                $animate.addClass(element, 'in', {\n                  css: {\n                    overflow: 'hidden'\n                  },\n                  to: getScrollFromElement(element[0])\n                }).then(expandDone);\n              }\n            }, angular.noop);\n        }\n\n        function expandDone() {\n          element.removeClass('collapsing')\n            .addClass('collapse')\n            .css(css);\n          expandedExpr(scope);\n        }\n\n        function collapse() {\n          if (!element.hasClass('collapse') && !element.hasClass('in')) {\n            return collapseDone();\n          }\n\n          $q.resolve(collapsingExpr(scope))\n            .then(function() {\n              element\n              // IMPORTANT: The width must be set before adding \"collapsing\" class.\n              // Otherwise, the browser attempts to animate from width 0 (in\n              // collapsing class) to the given width here.\n                .css(getScrollFromElement(element[0]))\n                // initially all panel collapse have the collapse class, this removal\n                // prevents the animation from jumping to collapsed state\n                .removeClass('collapse')\n                .addClass('collapsing')\n                .attr('aria-expanded', false)\n                .attr('aria-hidden', true);\n\n              if ($animateCss) {\n                $animateCss(element, {\n                  removeClass: 'in',\n                  to: cssTo\n                }).start()['finally'](collapseDone);\n              } else {\n                $animate.removeClass(element, 'in', {\n                  to: cssTo\n                }).then(collapseDone);\n              }\n            }, angular.noop);\n        }\n\n        function collapseDone() {\n          element.css(cssTo); // Required so that collapse works when animation is disabled\n          element.removeClass('collapsing')\n            .addClass('collapse');\n          collapsedExpr(scope);\n        }\n\n        scope.$watch(attrs.uibCollapse, function(shouldCollapse) {\n          if (shouldCollapse) {\n            collapse();\n          } else {\n            expand();\n          }\n        });\n      }\n    };\n  }]);\n\nangular.module('ui.bootstrap.tabindex', [])\n\n.directive('uibTabindexToggle', function() {\n  return {\n    restrict: 'A',\n    link: function(scope, elem, attrs) {\n      attrs.$observe('disabled', function(disabled) {\n        attrs.$set('tabindex', disabled ? -1 : null);\n      });\n    }\n  };\n});\n\nangular.module('ui.bootstrap.accordion', ['ui.bootstrap.collapse', 'ui.bootstrap.tabindex'])\n\n.constant('uibAccordionConfig', {\n  closeOthers: true\n})\n\n.controller('UibAccordionController', ['$scope', '$attrs', 'uibAccordionConfig', function($scope, $attrs, accordionConfig) {\n  // This array keeps track of the accordion groups\n  this.groups = [];\n\n  // Ensure that all the groups in this accordion are closed, unless close-others explicitly says not to\n  this.closeOthers = function(openGroup) {\n    var closeOthers = angular.isDefined($attrs.closeOthers) ?\n      $scope.$eval($attrs.closeOthers) : accordionConfig.closeOthers;\n    if (closeOthers) {\n      angular.forEach(this.groups, function(group) {\n        if (group !== openGroup) {\n          group.isOpen = false;\n        }\n      });\n    }\n  };\n\n  // This is called from the accordion-group directive to add itself to the accordion\n  this.addGroup = function(groupScope) {\n    var that = this;\n    this.groups.push(groupScope);\n\n    groupScope.$on('$destroy', function(event) {\n      that.removeGroup(groupScope);\n    });\n  };\n\n  // This is called from the accordion-group directive when to remove itself\n  this.removeGroup = function(group) {\n    var index = this.groups.indexOf(group);\n    if (index !== -1) {\n      this.groups.splice(index, 1);\n    }\n  };\n}])\n\n// The accordion directive simply sets up the directive controller\n// and adds an accordion CSS class to itself element.\n.directive('uibAccordion', function() {\n  return {\n    controller: 'UibAccordionController',\n    controllerAs: 'accordion',\n    transclude: true,\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'uib/template/accordion/accordion.html';\n    }\n  };\n})\n\n// The accordion-group directive indicates a block of html that will expand and collapse in an accordion\n.directive('uibAccordionGroup', function() {\n  return {\n    require: '^uibAccordion',         // We need this directive to be inside an accordion\n    transclude: true,              // It transcludes the contents of the directive into the template\n    restrict: 'A',\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'uib/template/accordion/accordion-group.html';\n    },\n    scope: {\n      heading: '@',               // Interpolate the heading attribute onto this scope\n      panelClass: '@?',           // Ditto with panelClass\n      isOpen: '=?',\n      isDisabled: '=?'\n    },\n    controller: function() {\n      this.setHeading = function(element) {\n        this.heading = element;\n      };\n    },\n    link: function(scope, element, attrs, accordionCtrl) {\n      element.addClass('panel');\n      accordionCtrl.addGroup(scope);\n\n      scope.openClass = attrs.openClass || 'panel-open';\n      scope.panelClass = attrs.panelClass || 'panel-default';\n      scope.$watch('isOpen', function(value) {\n        element.toggleClass(scope.openClass, !!value);\n        if (value) {\n          accordionCtrl.closeOthers(scope);\n        }\n      });\n\n      scope.toggleOpen = function($event) {\n        if (!scope.isDisabled) {\n          if (!$event || $event.which === 32) {\n            scope.isOpen = !scope.isOpen;\n          }\n        }\n      };\n\n      var id = 'accordiongroup-' + scope.$id + '-' + Math.floor(Math.random() * 10000);\n      scope.headingId = id + '-tab';\n      scope.panelId = id + '-panel';\n    }\n  };\n})\n\n// Use accordion-heading below an accordion-group to provide a heading containing HTML\n.directive('uibAccordionHeading', function() {\n  return {\n    transclude: true,   // Grab the contents to be used as the heading\n    template: '',       // In effect remove this element!\n    replace: true,\n    require: '^uibAccordionGroup',\n    link: function(scope, element, attrs, accordionGroupCtrl, transclude) {\n      // Pass the heading to the accordion-group controller\n      // so that it can be transcluded into the right place in the template\n      // [The second parameter to transclude causes the elements to be cloned so that they work in ng-repeat]\n      accordionGroupCtrl.setHeading(transclude(scope, angular.noop));\n    }\n  };\n})\n\n// Use in the accordion-group template to indicate where you want the heading to be transcluded\n// You must provide the property on the accordion-group controller that will hold the transcluded element\n.directive('uibAccordionTransclude', function() {\n  return {\n    require: '^uibAccordionGroup',\n    link: function(scope, element, attrs, controller) {\n      scope.$watch(function() { return controller[attrs.uibAccordionTransclude]; }, function(heading) {\n        if (heading) {\n          var elem = angular.element(element[0].querySelector(getHeaderSelectors()));\n          elem.html('');\n          elem.append(heading);\n        }\n      });\n    }\n  };\n\n  function getHeaderSelectors() {\n      return 'uib-accordion-header,' +\n          'data-uib-accordion-header,' +\n          'x-uib-accordion-header,' +\n          'uib\\\\:accordion-header,' +\n          '[uib-accordion-header],' +\n          '[data-uib-accordion-header],' +\n          '[x-uib-accordion-header]';\n  }\n});\n\nangular.module('ui.bootstrap.alert', [])\n\n.controller('UibAlertController', ['$scope', '$element', '$attrs', '$interpolate', '$timeout', function($scope, $element, $attrs, $interpolate, $timeout) {\n  $scope.closeable = !!$attrs.close;\n  $element.addClass('alert');\n  $attrs.$set('role', 'alert');\n  if ($scope.closeable) {\n    $element.addClass('alert-dismissible');\n  }\n\n  var dismissOnTimeout = angular.isDefined($attrs.dismissOnTimeout) ?\n    $interpolate($attrs.dismissOnTimeout)($scope.$parent) : null;\n\n  if (dismissOnTimeout) {\n    $timeout(function() {\n      $scope.close();\n    }, parseInt(dismissOnTimeout, 10));\n  }\n}])\n\n.directive('uibAlert', function() {\n  return {\n    controller: 'UibAlertController',\n    controllerAs: 'alert',\n    restrict: 'A',\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'uib/template/alert/alert.html';\n    },\n    transclude: true,\n    scope: {\n      close: '&'\n    }\n  };\n});\n\nangular.module('ui.bootstrap.buttons', [])\n\n.constant('uibButtonConfig', {\n  activeClass: 'active',\n  toggleEvent: 'click'\n})\n\n.controller('UibButtonsController', ['uibButtonConfig', function(buttonConfig) {\n  this.activeClass = buttonConfig.activeClass || 'active';\n  this.toggleEvent = buttonConfig.toggleEvent || 'click';\n}])\n\n.directive('uibBtnRadio', ['$parse', function($parse) {\n  return {\n    require: ['uibBtnRadio', 'ngModel'],\n    controller: 'UibButtonsController',\n    controllerAs: 'buttons',\n    link: function(scope, element, attrs, ctrls) {\n      var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n      var uncheckableExpr = $parse(attrs.uibUncheckable);\n\n      element.find('input').css({display: 'none'});\n\n      //model -> UI\n      ngModelCtrl.$render = function() {\n        element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, scope.$eval(attrs.uibBtnRadio)));\n      };\n\n      //ui->model\n      element.on(buttonsCtrl.toggleEvent, function() {\n        if (attrs.disabled) {\n          return;\n        }\n\n        var isActive = element.hasClass(buttonsCtrl.activeClass);\n\n        if (!isActive || angular.isDefined(attrs.uncheckable)) {\n          scope.$apply(function() {\n            ngModelCtrl.$setViewValue(isActive ? null : scope.$eval(attrs.uibBtnRadio));\n            ngModelCtrl.$render();\n          });\n        }\n      });\n\n      if (attrs.uibUncheckable) {\n        scope.$watch(uncheckableExpr, function(uncheckable) {\n          attrs.$set('uncheckable', uncheckable ? '' : undefined);\n        });\n      }\n    }\n  };\n}])\n\n.directive('uibBtnCheckbox', function() {\n  return {\n    require: ['uibBtnCheckbox', 'ngModel'],\n    controller: 'UibButtonsController',\n    controllerAs: 'button',\n    link: function(scope, element, attrs, ctrls) {\n      var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\n      element.find('input').css({display: 'none'});\n\n      function getTrueValue() {\n        return getCheckboxValue(attrs.btnCheckboxTrue, true);\n      }\n\n      function getFalseValue() {\n        return getCheckboxValue(attrs.btnCheckboxFalse, false);\n      }\n\n      function getCheckboxValue(attribute, defaultValue) {\n        return angular.isDefined(attribute) ? scope.$eval(attribute) : defaultValue;\n      }\n\n      //model -> UI\n      ngModelCtrl.$render = function() {\n        element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, getTrueValue()));\n      };\n\n      //ui->model\n      element.on(buttonsCtrl.toggleEvent, function() {\n        if (attrs.disabled) {\n          return;\n        }\n\n        scope.$apply(function() {\n          ngModelCtrl.$setViewValue(element.hasClass(buttonsCtrl.activeClass) ? getFalseValue() : getTrueValue());\n          ngModelCtrl.$render();\n        });\n      });\n    }\n  };\n});\n\nangular.module('ui.bootstrap.carousel', [])\n\n.controller('UibCarouselController', ['$scope', '$element', '$interval', '$timeout', '$animate', function($scope, $element, $interval, $timeout, $animate) {\n  var self = this,\n    slides = self.slides = $scope.slides = [],\n    SLIDE_DIRECTION = 'uib-slideDirection',\n    currentIndex = $scope.active,\n    currentInterval, isPlaying;\n\n  var destroyed = false;\n  $element.addClass('carousel');\n\n  self.addSlide = function(slide, element) {\n    slides.push({\n      slide: slide,\n      element: element\n    });\n    slides.sort(function(a, b) {\n      return +a.slide.index - +b.slide.index;\n    });\n    //if this is the first slide or the slide is set to active, select it\n    if (slide.index === $scope.active || slides.length === 1 && !angular.isNumber($scope.active)) {\n      if ($scope.$currentTransition) {\n        $scope.$currentTransition = null;\n      }\n\n      currentIndex = slide.index;\n      $scope.active = slide.index;\n      setActive(currentIndex);\n      self.select(slides[findSlideIndex(slide)]);\n      if (slides.length === 1) {\n        $scope.play();\n      }\n    }\n  };\n\n  self.getCurrentIndex = function() {\n    for (var i = 0; i < slides.length; i++) {\n      if (slides[i].slide.index === currentIndex) {\n        return i;\n      }\n    }\n  };\n\n  self.next = $scope.next = function() {\n    var newIndex = (self.getCurrentIndex() + 1) % slides.length;\n\n    if (newIndex === 0 && $scope.noWrap()) {\n      $scope.pause();\n      return;\n    }\n\n    return self.select(slides[newIndex], 'next');\n  };\n\n  self.prev = $scope.prev = function() {\n    var newIndex = self.getCurrentIndex() - 1 < 0 ? slides.length - 1 : self.getCurrentIndex() - 1;\n\n    if ($scope.noWrap() && newIndex === slides.length - 1) {\n      $scope.pause();\n      return;\n    }\n\n    return self.select(slides[newIndex], 'prev');\n  };\n\n  self.removeSlide = function(slide) {\n    var index = findSlideIndex(slide);\n\n    //get the index of the slide inside the carousel\n    slides.splice(index, 1);\n    if (slides.length > 0 && currentIndex === index) {\n      if (index >= slides.length) {\n        currentIndex = slides.length - 1;\n        $scope.active = currentIndex;\n        setActive(currentIndex);\n        self.select(slides[slides.length - 1]);\n      } else {\n        currentIndex = index;\n        $scope.active = currentIndex;\n        setActive(currentIndex);\n        self.select(slides[index]);\n      }\n    } else if (currentIndex > index) {\n      currentIndex--;\n      $scope.active = currentIndex;\n    }\n\n    //clean the active value when no more slide\n    if (slides.length === 0) {\n      currentIndex = null;\n      $scope.active = null;\n    }\n  };\n\n  /* direction: \"prev\" or \"next\" */\n  self.select = $scope.select = function(nextSlide, direction) {\n    var nextIndex = findSlideIndex(nextSlide.slide);\n    //Decide direction if it's not given\n    if (direction === undefined) {\n      direction = nextIndex > self.getCurrentIndex() ? 'next' : 'prev';\n    }\n    //Prevent this user-triggered transition from occurring if there is already one in progress\n    if (nextSlide.slide.index !== currentIndex &&\n      !$scope.$currentTransition) {\n      goNext(nextSlide.slide, nextIndex, direction);\n    }\n  };\n\n  /* Allow outside people to call indexOf on slides array */\n  $scope.indexOfSlide = function(slide) {\n    return +slide.slide.index;\n  };\n\n  $scope.isActive = function(slide) {\n    return $scope.active === slide.slide.index;\n  };\n\n  $scope.isPrevDisabled = function() {\n    return $scope.active === 0 && $scope.noWrap();\n  };\n\n  $scope.isNextDisabled = function() {\n    return $scope.active === slides.length - 1 && $scope.noWrap();\n  };\n\n  $scope.pause = function() {\n    if (!$scope.noPause) {\n      isPlaying = false;\n      resetTimer();\n    }\n  };\n\n  $scope.play = function() {\n    if (!isPlaying) {\n      isPlaying = true;\n      restartTimer();\n    }\n  };\n\n  $element.on('mouseenter', $scope.pause);\n  $element.on('mouseleave', $scope.play);\n\n  $scope.$on('$destroy', function() {\n    destroyed = true;\n    resetTimer();\n  });\n\n  $scope.$watch('noTransition', function(noTransition) {\n    $animate.enabled($element, !noTransition);\n  });\n\n  $scope.$watch('interval', restartTimer);\n\n  $scope.$watchCollection('slides', resetTransition);\n\n  $scope.$watch('active', function(index) {\n    if (angular.isNumber(index) && currentIndex !== index) {\n      for (var i = 0; i < slides.length; i++) {\n        if (slides[i].slide.index === index) {\n          index = i;\n          break;\n        }\n      }\n\n      var slide = slides[index];\n      if (slide) {\n        setActive(index);\n        self.select(slides[index]);\n        currentIndex = index;\n      }\n    }\n  });\n\n  function getSlideByIndex(index) {\n    for (var i = 0, l = slides.length; i < l; ++i) {\n      if (slides[i].index === index) {\n        return slides[i];\n      }\n    }\n  }\n\n  function setActive(index) {\n    for (var i = 0; i < slides.length; i++) {\n      slides[i].slide.active = i === index;\n    }\n  }\n\n  function goNext(slide, index, direction) {\n    if (destroyed) {\n      return;\n    }\n\n    angular.extend(slide, {direction: direction});\n    angular.extend(slides[currentIndex].slide || {}, {direction: direction});\n    if ($animate.enabled($element) && !$scope.$currentTransition &&\n      slides[index].element && self.slides.length > 1) {\n      slides[index].element.data(SLIDE_DIRECTION, slide.direction);\n      var currentIdx = self.getCurrentIndex();\n\n      if (angular.isNumber(currentIdx) && slides[currentIdx].element) {\n        slides[currentIdx].element.data(SLIDE_DIRECTION, slide.direction);\n      }\n\n      $scope.$currentTransition = true;\n      $animate.on('addClass', slides[index].element, function(element, phase) {\n        if (phase === 'close') {\n          $scope.$currentTransition = null;\n          $animate.off('addClass', element);\n        }\n      });\n    }\n\n    $scope.active = slide.index;\n    currentIndex = slide.index;\n    setActive(index);\n\n    //every time you change slides, reset the timer\n    restartTimer();\n  }\n\n  function findSlideIndex(slide) {\n    for (var i = 0; i < slides.length; i++) {\n      if (slides[i].slide === slide) {\n        return i;\n      }\n    }\n  }\n\n  function resetTimer() {\n    if (currentInterval) {\n      $interval.cancel(currentInterval);\n      currentInterval = null;\n    }\n  }\n\n  function resetTransition(slides) {\n    if (!slides.length) {\n      $scope.$currentTransition = null;\n    }\n  }\n\n  function restartTimer() {\n    resetTimer();\n    var interval = +$scope.interval;\n    if (!isNaN(interval) && interval > 0) {\n      currentInterval = $interval(timerFn, interval);\n    }\n  }\n\n  function timerFn() {\n    var interval = +$scope.interval;\n    if (isPlaying && !isNaN(interval) && interval > 0 && slides.length) {\n      $scope.next();\n    } else {\n      $scope.pause();\n    }\n  }\n}])\n\n.directive('uibCarousel', function() {\n  return {\n    transclude: true,\n    controller: 'UibCarouselController',\n    controllerAs: 'carousel',\n    restrict: 'A',\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'uib/template/carousel/carousel.html';\n    },\n    scope: {\n      active: '=',\n      interval: '=',\n      noTransition: '=',\n      noPause: '=',\n      noWrap: '&'\n    }\n  };\n})\n\n.directive('uibSlide', ['$animate', function($animate) {\n  return {\n    require: '^uibCarousel',\n    restrict: 'A',\n    transclude: true,\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'uib/template/carousel/slide.html';\n    },\n    scope: {\n      actual: '=?',\n      index: '=?'\n    },\n    link: function (scope, element, attrs, carouselCtrl) {\n      element.addClass('item');\n      carouselCtrl.addSlide(scope, element);\n      //when the scope is destroyed then remove the slide from the current slides array\n      scope.$on('$destroy', function() {\n        carouselCtrl.removeSlide(scope);\n      });\n\n      scope.$watch('active', function(active) {\n        $animate[active ? 'addClass' : 'removeClass'](element, 'active');\n      });\n    }\n  };\n}])\n\n.animation('.item', ['$animateCss',\nfunction($animateCss) {\n  var SLIDE_DIRECTION = 'uib-slideDirection';\n\n  function removeClass(element, className, callback) {\n    element.removeClass(className);\n    if (callback) {\n      callback();\n    }\n  }\n\n  return {\n    beforeAddClass: function(element, className, done) {\n      if (className === 'active') {\n        var stopped = false;\n        var direction = element.data(SLIDE_DIRECTION);\n        var directionClass = direction === 'next' ? 'left' : 'right';\n        var removeClassFn = removeClass.bind(this, element,\n          directionClass + ' ' + direction, done);\n        element.addClass(direction);\n\n        $animateCss(element, {addClass: directionClass})\n          .start()\n          .done(removeClassFn);\n\n        return function() {\n          stopped = true;\n        };\n      }\n      done();\n    },\n    beforeRemoveClass: function (element, className, done) {\n      if (className === 'active') {\n        var stopped = false;\n        var direction = element.data(SLIDE_DIRECTION);\n        var directionClass = direction === 'next' ? 'left' : 'right';\n        var removeClassFn = removeClass.bind(this, element, directionClass, done);\n\n        $animateCss(element, {addClass: directionClass})\n          .start()\n          .done(removeClassFn);\n\n        return function() {\n          stopped = true;\n        };\n      }\n      done();\n    }\n  };\n}]);\n\nangular.module('ui.bootstrap.dateparser', [])\n\n.service('uibDateParser', ['$log', '$locale', 'dateFilter', 'orderByFilter', 'filterFilter', function($log, $locale, dateFilter, orderByFilter, filterFilter) {\n  // Pulled from https://github.com/mbostock/d3/blob/master/src/format/requote.js\n  var SPECIAL_CHARACTERS_REGEXP = /[\\\\\\^\\$\\*\\+\\?\\|\\[\\]\\(\\)\\.\\{\\}]/g;\n\n  var localeId;\n  var formatCodeToRegex;\n\n  this.init = function() {\n    localeId = $locale.id;\n\n    this.parsers = {};\n    this.formatters = {};\n\n    formatCodeToRegex = [\n      {\n        key: 'yyyy',\n        regex: '\\\\d{4}',\n        apply: function(value) { this.year = +value; },\n        formatter: function(date) {\n          var _date = new Date();\n          _date.setFullYear(Math.abs(date.getFullYear()));\n          return dateFilter(_date, 'yyyy');\n        }\n      },\n      {\n        key: 'yy',\n        regex: '\\\\d{2}',\n        apply: function(value) { value = +value; this.year = value < 69 ? value + 2000 : value + 1900; },\n        formatter: function(date) {\n          var _date = new Date();\n          _date.setFullYear(Math.abs(date.getFullYear()));\n          return dateFilter(_date, 'yy');\n        }\n      },\n      {\n        key: 'y',\n        regex: '\\\\d{1,4}',\n        apply: function(value) { this.year = +value; },\n        formatter: function(date) {\n          var _date = new Date();\n          _date.setFullYear(Math.abs(date.getFullYear()));\n          return dateFilter(_date, 'y');\n        }\n      },\n      {\n        key: 'M!',\n        regex: '0?[1-9]|1[0-2]',\n        apply: function(value) { this.month = value - 1; },\n        formatter: function(date) {\n          var value = date.getMonth();\n          if (/^[0-9]$/.test(value)) {\n            return dateFilter(date, 'MM');\n          }\n\n          return dateFilter(date, 'M');\n        }\n      },\n      {\n        key: 'MMMM',\n        regex: $locale.DATETIME_FORMATS.MONTH.join('|'),\n        apply: function(value) { this.month = $locale.DATETIME_FORMATS.MONTH.indexOf(value); },\n        formatter: function(date) { return dateFilter(date, 'MMMM'); }\n      },\n      {\n        key: 'MMM',\n        regex: $locale.DATETIME_FORMATS.SHORTMONTH.join('|'),\n        apply: function(value) { this.month = $locale.DATETIME_FORMATS.SHORTMONTH.indexOf(value); },\n        formatter: function(date) { return dateFilter(date, 'MMM'); }\n      },\n      {\n        key: 'MM',\n        regex: '0[1-9]|1[0-2]',\n        apply: function(value) { this.month = value - 1; },\n        formatter: function(date) { return dateFilter(date, 'MM'); }\n      },\n      {\n        key: 'M',\n        regex: '[1-9]|1[0-2]',\n        apply: function(value) { this.month = value - 1; },\n        formatter: function(date) { return dateFilter(date, 'M'); }\n      },\n      {\n        key: 'd!',\n        regex: '[0-2]?[0-9]{1}|3[0-1]{1}',\n        apply: function(value) { this.date = +value; },\n        formatter: function(date) {\n          var value = date.getDate();\n          if (/^[1-9]$/.test(value)) {\n            return dateFilter(date, 'dd');\n          }\n\n          return dateFilter(date, 'd');\n        }\n      },\n      {\n        key: 'dd',\n        regex: '[0-2][0-9]{1}|3[0-1]{1}',\n        apply: function(value) { this.date = +value; },\n        formatter: function(date) { return dateFilter(date, 'dd'); }\n      },\n      {\n        key: 'd',\n        regex: '[1-2]?[0-9]{1}|3[0-1]{1}',\n        apply: function(value) { this.date = +value; },\n        formatter: function(date) { return dateFilter(date, 'd'); }\n      },\n      {\n        key: 'EEEE',\n        regex: $locale.DATETIME_FORMATS.DAY.join('|'),\n        formatter: function(date) { return dateFilter(date, 'EEEE'); }\n      },\n      {\n        key: 'EEE',\n        regex: $locale.DATETIME_FORMATS.SHORTDAY.join('|'),\n        formatter: function(date) { return dateFilter(date, 'EEE'); }\n      },\n      {\n        key: 'HH',\n        regex: '(?:0|1)[0-9]|2[0-3]',\n        apply: function(value) { this.hours = +value; },\n        formatter: function(date) { return dateFilter(date, 'HH'); }\n      },\n      {\n        key: 'hh',\n        regex: '0[0-9]|1[0-2]',\n        apply: function(value) { this.hours = +value; },\n        formatter: function(date) { return dateFilter(date, 'hh'); }\n      },\n      {\n        key: 'H',\n        regex: '1?[0-9]|2[0-3]',\n        apply: function(value) { this.hours = +value; },\n        formatter: function(date) { return dateFilter(date, 'H'); }\n      },\n      {\n        key: 'h',\n        regex: '[0-9]|1[0-2]',\n        apply: function(value) { this.hours = +value; },\n        formatter: function(date) { return dateFilter(date, 'h'); }\n      },\n      {\n        key: 'mm',\n        regex: '[0-5][0-9]',\n        apply: function(value) { this.minutes = +value; },\n        formatter: function(date) { return dateFilter(date, 'mm'); }\n      },\n      {\n        key: 'm',\n        regex: '[0-9]|[1-5][0-9]',\n        apply: function(value) { this.minutes = +value; },\n        formatter: function(date) { return dateFilter(date, 'm'); }\n      },\n      {\n        key: 'sss',\n        regex: '[0-9][0-9][0-9]',\n        apply: function(value) { this.milliseconds = +value; },\n        formatter: function(date) { return dateFilter(date, 'sss'); }\n      },\n      {\n        key: 'ss',\n        regex: '[0-5][0-9]',\n        apply: function(value) { this.seconds = +value; },\n        formatter: function(date) { return dateFilter(date, 'ss'); }\n      },\n      {\n        key: 's',\n        regex: '[0-9]|[1-5][0-9]',\n        apply: function(value) { this.seconds = +value; },\n        formatter: function(date) { return dateFilter(date, 's'); }\n      },\n      {\n        key: 'a',\n        regex: $locale.DATETIME_FORMATS.AMPMS.join('|'),\n        apply: function(value) {\n          if (this.hours === 12) {\n            this.hours = 0;\n          }\n\n          if (value === 'PM') {\n            this.hours += 12;\n          }\n        },\n        formatter: function(date) { return dateFilter(date, 'a'); }\n      },\n      {\n        key: 'Z',\n        regex: '[+-]\\\\d{4}',\n        apply: function(value) {\n          var matches = value.match(/([+-])(\\d{2})(\\d{2})/),\n            sign = matches[1],\n            hours = matches[2],\n            minutes = matches[3];\n          this.hours += toInt(sign + hours);\n          this.minutes += toInt(sign + minutes);\n        },\n        formatter: function(date) {\n          return dateFilter(date, 'Z');\n        }\n      },\n      {\n        key: 'ww',\n        regex: '[0-4][0-9]|5[0-3]',\n        formatter: function(date) { return dateFilter(date, 'ww'); }\n      },\n      {\n        key: 'w',\n        regex: '[0-9]|[1-4][0-9]|5[0-3]',\n        formatter: function(date) { return dateFilter(date, 'w'); }\n      },\n      {\n        key: 'GGGG',\n        regex: $locale.DATETIME_FORMATS.ERANAMES.join('|').replace(/\\s/g, '\\\\s'),\n        formatter: function(date) { return dateFilter(date, 'GGGG'); }\n      },\n      {\n        key: 'GGG',\n        regex: $locale.DATETIME_FORMATS.ERAS.join('|'),\n        formatter: function(date) { return dateFilter(date, 'GGG'); }\n      },\n      {\n        key: 'GG',\n        regex: $locale.DATETIME_FORMATS.ERAS.join('|'),\n        formatter: function(date) { return dateFilter(date, 'GG'); }\n      },\n      {\n        key: 'G',\n        regex: $locale.DATETIME_FORMATS.ERAS.join('|'),\n        formatter: function(date) { return dateFilter(date, 'G'); }\n      }\n    ];\n\n    if (angular.version.major >= 1 && angular.version.minor > 4) {\n      formatCodeToRegex.push({\n        key: 'LLLL',\n        regex: $locale.DATETIME_FORMATS.STANDALONEMONTH.join('|'),\n        apply: function(value) { this.month = $locale.DATETIME_FORMATS.STANDALONEMONTH.indexOf(value); },\n        formatter: function(date) { return dateFilter(date, 'LLLL'); }\n      });\n    }\n  };\n\n  this.init();\n\n  function getFormatCodeToRegex(key) {\n    return filterFilter(formatCodeToRegex, {key: key}, true)[0];\n  }\n\n  this.getParser = function (key) {\n    var f = getFormatCodeToRegex(key);\n    return f && f.apply || null;\n  };\n\n  this.overrideParser = function (key, parser) {\n    var f = getFormatCodeToRegex(key);\n    if (f && angular.isFunction(parser)) {\n      this.parsers = {};\n      f.apply = parser;\n    }\n  }.bind(this);\n\n  function createParser(format) {\n    var map = [], regex = format.split('');\n\n    // check for literal values\n    var quoteIndex = format.indexOf('\\'');\n    if (quoteIndex > -1) {\n      var inLiteral = false;\n      format = format.split('');\n      for (var i = quoteIndex; i < format.length; i++) {\n        if (inLiteral) {\n          if (format[i] === '\\'') {\n            if (i + 1 < format.length && format[i+1] === '\\'') { // escaped single quote\n              format[i+1] = '$';\n              regex[i+1] = '';\n            } else { // end of literal\n              regex[i] = '';\n              inLiteral = false;\n            }\n          }\n          format[i] = '$';\n        } else {\n          if (format[i] === '\\'') { // start of literal\n            format[i] = '$';\n            regex[i] = '';\n            inLiteral = true;\n          }\n        }\n      }\n\n      format = format.join('');\n    }\n\n    angular.forEach(formatCodeToRegex, function(data) {\n      var index = format.indexOf(data.key);\n\n      if (index > -1) {\n        format = format.split('');\n\n        regex[index] = '(' + data.regex + ')';\n        format[index] = '$'; // Custom symbol to define consumed part of format\n        for (var i = index + 1, n = index + data.key.length; i < n; i++) {\n          regex[i] = '';\n          format[i] = '$';\n        }\n        format = format.join('');\n\n        map.push({\n          index: index,\n          key: data.key,\n          apply: data.apply,\n          matcher: data.regex\n        });\n      }\n    });\n\n    return {\n      regex: new RegExp('^' + regex.join('') + '$'),\n      map: orderByFilter(map, 'index')\n    };\n  }\n\n  function createFormatter(format) {\n    var formatters = [];\n    var i = 0;\n    var formatter, literalIdx;\n    while (i < format.length) {\n      if (angular.isNumber(literalIdx)) {\n        if (format.charAt(i) === '\\'') {\n          if (i + 1 >= format.length || format.charAt(i + 1) !== '\\'') {\n            formatters.push(constructLiteralFormatter(format, literalIdx, i));\n            literalIdx = null;\n          }\n        } else if (i === format.length) {\n          while (literalIdx < format.length) {\n            formatter = constructFormatterFromIdx(format, literalIdx);\n            formatters.push(formatter);\n            literalIdx = formatter.endIdx;\n          }\n        }\n\n        i++;\n        continue;\n      }\n\n      if (format.charAt(i) === '\\'') {\n        literalIdx = i;\n        i++;\n        continue;\n      }\n\n      formatter = constructFormatterFromIdx(format, i);\n\n      formatters.push(formatter.parser);\n      i = formatter.endIdx;\n    }\n\n    return formatters;\n  }\n\n  function constructLiteralFormatter(format, literalIdx, endIdx) {\n    return function() {\n      return format.substr(literalIdx + 1, endIdx - literalIdx - 1);\n    };\n  }\n\n  function constructFormatterFromIdx(format, i) {\n    var currentPosStr = format.substr(i);\n    for (var j = 0; j < formatCodeToRegex.length; j++) {\n      if (new RegExp('^' + formatCodeToRegex[j].key).test(currentPosStr)) {\n        var data = formatCodeToRegex[j];\n        return {\n          endIdx: i + data.key.length,\n          parser: data.formatter\n        };\n      }\n    }\n\n    return {\n      endIdx: i + 1,\n      parser: function() {\n        return currentPosStr.charAt(0);\n      }\n    };\n  }\n\n  this.filter = function(date, format) {\n    if (!angular.isDate(date) || isNaN(date) || !format) {\n      return '';\n    }\n\n    format = $locale.DATETIME_FORMATS[format] || format;\n\n    if ($locale.id !== localeId) {\n      this.init();\n    }\n\n    if (!this.formatters[format]) {\n      this.formatters[format] = createFormatter(format);\n    }\n\n    var formatters = this.formatters[format];\n\n    return formatters.reduce(function(str, formatter) {\n      return str + formatter(date);\n    }, '');\n  };\n\n  this.parse = function(input, format, baseDate) {\n    if (!angular.isString(input) || !format) {\n      return input;\n    }\n\n    format = $locale.DATETIME_FORMATS[format] || format;\n    format = format.replace(SPECIAL_CHARACTERS_REGEXP, '\\\\$&');\n\n    if ($locale.id !== localeId) {\n      this.init();\n    }\n\n    if (!this.parsers[format]) {\n      this.parsers[format] = createParser(format, 'apply');\n    }\n\n    var parser = this.parsers[format],\n        regex = parser.regex,\n        map = parser.map,\n        results = input.match(regex),\n        tzOffset = false;\n    if (results && results.length) {\n      var fields, dt;\n      if (angular.isDate(baseDate) && !isNaN(baseDate.getTime())) {\n        fields = {\n          year: baseDate.getFullYear(),\n          month: baseDate.getMonth(),\n          date: baseDate.getDate(),\n          hours: baseDate.getHours(),\n          minutes: baseDate.getMinutes(),\n          seconds: baseDate.getSeconds(),\n          milliseconds: baseDate.getMilliseconds()\n        };\n      } else {\n        if (baseDate) {\n          $log.warn('dateparser:', 'baseDate is not a valid date');\n        }\n        fields = { year: 1900, month: 0, date: 1, hours: 0, minutes: 0, seconds: 0, milliseconds: 0 };\n      }\n\n      for (var i = 1, n = results.length; i < n; i++) {\n        var mapper = map[i - 1];\n        if (mapper.matcher === 'Z') {\n          tzOffset = true;\n        }\n\n        if (mapper.apply) {\n          mapper.apply.call(fields, results[i]);\n        }\n      }\n\n      var datesetter = tzOffset ? Date.prototype.setUTCFullYear :\n        Date.prototype.setFullYear;\n      var timesetter = tzOffset ? Date.prototype.setUTCHours :\n        Date.prototype.setHours;\n\n      if (isValid(fields.year, fields.month, fields.date)) {\n        if (angular.isDate(baseDate) && !isNaN(baseDate.getTime()) && !tzOffset) {\n          dt = new Date(baseDate);\n          datesetter.call(dt, fields.year, fields.month, fields.date);\n          timesetter.call(dt, fields.hours, fields.minutes,\n            fields.seconds, fields.milliseconds);\n        } else {\n          dt = new Date(0);\n          datesetter.call(dt, fields.year, fields.month, fields.date);\n          timesetter.call(dt, fields.hours || 0, fields.minutes || 0,\n            fields.seconds || 0, fields.milliseconds || 0);\n        }\n      }\n\n      return dt;\n    }\n  };\n\n  // Check if date is valid for specific month (and year for February).\n  // Month: 0 = Jan, 1 = Feb, etc\n  function isValid(year, month, date) {\n    if (date < 1) {\n      return false;\n    }\n\n    if (month === 1 && date > 28) {\n      return date === 29 && (year % 4 === 0 && year % 100 !== 0 || year % 400 === 0);\n    }\n\n    if (month === 3 || month === 5 || month === 8 || month === 10) {\n      return date < 31;\n    }\n\n    return true;\n  }\n\n  function toInt(str) {\n    return parseInt(str, 10);\n  }\n\n  this.toTimezone = toTimezone;\n  this.fromTimezone = fromTimezone;\n  this.timezoneToOffset = timezoneToOffset;\n  this.addDateMinutes = addDateMinutes;\n  this.convertTimezoneToLocal = convertTimezoneToLocal;\n\n  function toTimezone(date, timezone) {\n    return date && timezone ? convertTimezoneToLocal(date, timezone) : date;\n  }\n\n  function fromTimezone(date, timezone) {\n    return date && timezone ? convertTimezoneToLocal(date, timezone, true) : date;\n  }\n\n  //https://github.com/angular/angular.js/blob/622c42169699ec07fc6daaa19fe6d224e5d2f70e/src/Angular.js#L1207\n  function timezoneToOffset(timezone, fallback) {\n    timezone = timezone.replace(/:/g, '');\n    var requestedTimezoneOffset = Date.parse('Jan 01, 1970 00:00:00 ' + timezone) / 60000;\n    return isNaN(requestedTimezoneOffset) ? fallback : requestedTimezoneOffset;\n  }\n\n  function addDateMinutes(date, minutes) {\n    date = new Date(date.getTime());\n    date.setMinutes(date.getMinutes() + minutes);\n    return date;\n  }\n\n  function convertTimezoneToLocal(date, timezone, reverse) {\n    reverse = reverse ? -1 : 1;\n    var dateTimezoneOffset = date.getTimezoneOffset();\n    var timezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset);\n    return addDateMinutes(date, reverse * (timezoneOffset - dateTimezoneOffset));\n  }\n}]);\n\n// Avoiding use of ng-class as it creates a lot of watchers when a class is to be applied to\n// at most one element.\nangular.module('ui.bootstrap.isClass', [])\n.directive('uibIsClass', [\n         '$animate',\nfunction ($animate) {\n  //                    11111111          22222222\n  var ON_REGEXP = /^\\s*([\\s\\S]+?)\\s+on\\s+([\\s\\S]+?)\\s*$/;\n  //                    11111111           22222222\n  var IS_REGEXP = /^\\s*([\\s\\S]+?)\\s+for\\s+([\\s\\S]+?)\\s*$/;\n\n  var dataPerTracked = {};\n\n  return {\n    restrict: 'A',\n    compile: function(tElement, tAttrs) {\n      var linkedScopes = [];\n      var instances = [];\n      var expToData = {};\n      var lastActivated = null;\n      var onExpMatches = tAttrs.uibIsClass.match(ON_REGEXP);\n      var onExp = onExpMatches[2];\n      var expsStr = onExpMatches[1];\n      var exps = expsStr.split(',');\n\n      return linkFn;\n\n      function linkFn(scope, element, attrs) {\n        linkedScopes.push(scope);\n        instances.push({\n          scope: scope,\n          element: element\n        });\n\n        exps.forEach(function(exp, k) {\n          addForExp(exp, scope);\n        });\n\n        scope.$on('$destroy', removeScope);\n      }\n\n      function addForExp(exp, scope) {\n        var matches = exp.match(IS_REGEXP);\n        var clazz = scope.$eval(matches[1]);\n        var compareWithExp = matches[2];\n        var data = expToData[exp];\n        if (!data) {\n          var watchFn = function(compareWithVal) {\n            var newActivated = null;\n            instances.some(function(instance) {\n              var thisVal = instance.scope.$eval(onExp);\n              if (thisVal === compareWithVal) {\n                newActivated = instance;\n                return true;\n              }\n            });\n            if (data.lastActivated !== newActivated) {\n              if (data.lastActivated) {\n                $animate.removeClass(data.lastActivated.element, clazz);\n              }\n              if (newActivated) {\n                $animate.addClass(newActivated.element, clazz);\n              }\n              data.lastActivated = newActivated;\n            }\n          };\n          expToData[exp] = data = {\n            lastActivated: null,\n            scope: scope,\n            watchFn: watchFn,\n            compareWithExp: compareWithExp,\n            watcher: scope.$watch(compareWithExp, watchFn)\n          };\n        }\n        data.watchFn(scope.$eval(compareWithExp));\n      }\n\n      function removeScope(e) {\n        var removedScope = e.targetScope;\n        var index = linkedScopes.indexOf(removedScope);\n        linkedScopes.splice(index, 1);\n        instances.splice(index, 1);\n        if (linkedScopes.length) {\n          var newWatchScope = linkedScopes[0];\n          angular.forEach(expToData, function(data) {\n            if (data.scope === removedScope) {\n              data.watcher = newWatchScope.$watch(data.compareWithExp, data.watchFn);\n              data.scope = newWatchScope;\n            }\n          });\n        } else {\n          expToData = {};\n        }\n      }\n    }\n  };\n}]);\nangular.module('ui.bootstrap.datepicker', ['ui.bootstrap.dateparser', 'ui.bootstrap.isClass'])\n\n.value('$datepickerSuppressError', false)\n\n.value('$datepickerLiteralWarning', true)\n\n.constant('uibDatepickerConfig', {\n  datepickerMode: 'day',\n  formatDay: 'dd',\n  formatMonth: 'MMMM',\n  formatYear: 'yyyy',\n  formatDayHeader: 'EEE',\n  formatDayTitle: 'MMMM yyyy',\n  formatMonthTitle: 'yyyy',\n  maxDate: null,\n  maxMode: 'year',\n  minDate: null,\n  minMode: 'day',\n  monthColumns: 3,\n  ngModelOptions: {},\n  shortcutPropagation: false,\n  showWeeks: true,\n  yearColumns: 5,\n  yearRows: 4\n})\n\n.controller('UibDatepickerController', ['$scope', '$element', '$attrs', '$parse', '$interpolate', '$locale', '$log', 'dateFilter', 'uibDatepickerConfig', '$datepickerLiteralWarning', '$datepickerSuppressError', 'uibDateParser',\n  function($scope, $element, $attrs, $parse, $interpolate, $locale, $log, dateFilter, datepickerConfig, $datepickerLiteralWarning, $datepickerSuppressError, dateParser) {\n  var self = this,\n      ngModelCtrl = { $setViewValue: angular.noop }, // nullModelCtrl;\n      ngModelOptions = {},\n      watchListeners = [];\n\n  $element.addClass('uib-datepicker');\n  $attrs.$set('role', 'application');\n\n  if (!$scope.datepickerOptions) {\n    $scope.datepickerOptions = {};\n  }\n\n  // Modes chain\n  this.modes = ['day', 'month', 'year'];\n\n  [\n    'customClass',\n    'dateDisabled',\n    'datepickerMode',\n    'formatDay',\n    'formatDayHeader',\n    'formatDayTitle',\n    'formatMonth',\n    'formatMonthTitle',\n    'formatYear',\n    'maxDate',\n    'maxMode',\n    'minDate',\n    'minMode',\n    'monthColumns',\n    'showWeeks',\n    'shortcutPropagation',\n    'startingDay',\n    'yearColumns',\n    'yearRows'\n  ].forEach(function(key) {\n    switch (key) {\n      case 'customClass':\n      case 'dateDisabled':\n        $scope[key] = $scope.datepickerOptions[key] || angular.noop;\n        break;\n      case 'datepickerMode':\n        $scope.datepickerMode = angular.isDefined($scope.datepickerOptions.datepickerMode) ?\n          $scope.datepickerOptions.datepickerMode : datepickerConfig.datepickerMode;\n        break;\n      case 'formatDay':\n      case 'formatDayHeader':\n      case 'formatDayTitle':\n      case 'formatMonth':\n      case 'formatMonthTitle':\n      case 'formatYear':\n        self[key] = angular.isDefined($scope.datepickerOptions[key]) ?\n          $interpolate($scope.datepickerOptions[key])($scope.$parent) :\n          datepickerConfig[key];\n        break;\n      case 'monthColumns':\n      case 'showWeeks':\n      case 'shortcutPropagation':\n      case 'yearColumns':\n      case 'yearRows':\n        self[key] = angular.isDefined($scope.datepickerOptions[key]) ?\n          $scope.datepickerOptions[key] : datepickerConfig[key];\n        break;\n      case 'startingDay':\n        if (angular.isDefined($scope.datepickerOptions.startingDay)) {\n          self.startingDay = $scope.datepickerOptions.startingDay;\n        } else if (angular.isNumber(datepickerConfig.startingDay)) {\n          self.startingDay = datepickerConfig.startingDay;\n        } else {\n          self.startingDay = ($locale.DATETIME_FORMATS.FIRSTDAYOFWEEK + 8) % 7;\n        }\n\n        break;\n      case 'maxDate':\n      case 'minDate':\n        $scope.$watch('datepickerOptions.' + key, function(value) {\n          if (value) {\n            if (angular.isDate(value)) {\n              self[key] = dateParser.fromTimezone(new Date(value), ngModelOptions.getOption('timezone'));\n            } else {\n              if ($datepickerLiteralWarning) {\n                $log.warn('Literal date support has been deprecated, please switch to date object usage');\n              }\n\n              self[key] = new Date(dateFilter(value, 'medium'));\n            }\n          } else {\n            self[key] = datepickerConfig[key] ?\n              dateParser.fromTimezone(new Date(datepickerConfig[key]), ngModelOptions.getOption('timezone')) :\n              null;\n          }\n\n          self.refreshView();\n        });\n\n        break;\n      case 'maxMode':\n      case 'minMode':\n        if ($scope.datepickerOptions[key]) {\n          $scope.$watch(function() { return $scope.datepickerOptions[key]; }, function(value) {\n            self[key] = $scope[key] = angular.isDefined(value) ? value : $scope.datepickerOptions[key];\n            if (key === 'minMode' && self.modes.indexOf($scope.datepickerOptions.datepickerMode) < self.modes.indexOf(self[key]) ||\n              key === 'maxMode' && self.modes.indexOf($scope.datepickerOptions.datepickerMode) > self.modes.indexOf(self[key])) {\n              $scope.datepickerMode = self[key];\n              $scope.datepickerOptions.datepickerMode = self[key];\n            }\n          });\n        } else {\n          self[key] = $scope[key] = datepickerConfig[key] || null;\n        }\n\n        break;\n    }\n  });\n\n  $scope.uniqueId = 'datepicker-' + $scope.$id + '-' + Math.floor(Math.random() * 10000);\n\n  $scope.disabled = angular.isDefined($attrs.disabled) || false;\n  if (angular.isDefined($attrs.ngDisabled)) {\n    watchListeners.push($scope.$parent.$watch($attrs.ngDisabled, function(disabled) {\n      $scope.disabled = disabled;\n      self.refreshView();\n    }));\n  }\n\n  $scope.isActive = function(dateObject) {\n    if (self.compare(dateObject.date, self.activeDate) === 0) {\n      $scope.activeDateId = dateObject.uid;\n      return true;\n    }\n    return false;\n  };\n\n  this.init = function(ngModelCtrl_) {\n    ngModelCtrl = ngModelCtrl_;\n    ngModelOptions = extractOptions(ngModelCtrl);\n\n    if ($scope.datepickerOptions.initDate) {\n      self.activeDate = dateParser.fromTimezone($scope.datepickerOptions.initDate, ngModelOptions.getOption('timezone')) || new Date();\n      $scope.$watch('datepickerOptions.initDate', function(initDate) {\n        if (initDate && (ngModelCtrl.$isEmpty(ngModelCtrl.$modelValue) || ngModelCtrl.$invalid)) {\n          self.activeDate = dateParser.fromTimezone(initDate, ngModelOptions.getOption('timezone'));\n          self.refreshView();\n        }\n      });\n    } else {\n      self.activeDate = new Date();\n    }\n\n    var date = ngModelCtrl.$modelValue ? new Date(ngModelCtrl.$modelValue) : new Date();\n    this.activeDate = !isNaN(date) ?\n      dateParser.fromTimezone(date, ngModelOptions.getOption('timezone')) :\n      dateParser.fromTimezone(new Date(), ngModelOptions.getOption('timezone'));\n\n    ngModelCtrl.$render = function() {\n      self.render();\n    };\n  };\n\n  this.render = function() {\n    if (ngModelCtrl.$viewValue) {\n      var date = new Date(ngModelCtrl.$viewValue),\n          isValid = !isNaN(date);\n\n      if (isValid) {\n        this.activeDate = dateParser.fromTimezone(date, ngModelOptions.getOption('timezone'));\n      } else if (!$datepickerSuppressError) {\n        $log.error('Datepicker directive: \"ng-model\" value must be a Date object');\n      }\n    }\n    this.refreshView();\n  };\n\n  this.refreshView = function() {\n    if (this.element) {\n      $scope.selectedDt = null;\n      this._refreshView();\n      if ($scope.activeDt) {\n        $scope.activeDateId = $scope.activeDt.uid;\n      }\n\n      var date = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;\n      date = dateParser.fromTimezone(date, ngModelOptions.getOption('timezone'));\n      ngModelCtrl.$setValidity('dateDisabled', !date ||\n        this.element && !this.isDisabled(date));\n    }\n  };\n\n  this.createDateObject = function(date, format) {\n    var model = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;\n    model = dateParser.fromTimezone(model, ngModelOptions.getOption('timezone'));\n    var today = new Date();\n    today = dateParser.fromTimezone(today, ngModelOptions.getOption('timezone'));\n    var time = this.compare(date, today);\n    var dt = {\n      date: date,\n      label: dateParser.filter(date, format),\n      selected: model && this.compare(date, model) === 0,\n      disabled: this.isDisabled(date),\n      past: time < 0,\n      current: time === 0,\n      future: time > 0,\n      customClass: this.customClass(date) || null\n    };\n\n    if (model && this.compare(date, model) === 0) {\n      $scope.selectedDt = dt;\n    }\n\n    if (self.activeDate && this.compare(dt.date, self.activeDate) === 0) {\n      $scope.activeDt = dt;\n    }\n\n    return dt;\n  };\n\n  this.isDisabled = function(date) {\n    return $scope.disabled ||\n      this.minDate && this.compare(date, this.minDate) < 0 ||\n      this.maxDate && this.compare(date, this.maxDate) > 0 ||\n      $scope.dateDisabled && $scope.dateDisabled({date: date, mode: $scope.datepickerMode});\n  };\n\n  this.customClass = function(date) {\n    return $scope.customClass({date: date, mode: $scope.datepickerMode});\n  };\n\n  // Split array into smaller arrays\n  this.split = function(arr, size) {\n    var arrays = [];\n    while (arr.length > 0) {\n      arrays.push(arr.splice(0, size));\n    }\n    return arrays;\n  };\n\n  $scope.select = function(date) {\n    if ($scope.datepickerMode === self.minMode) {\n      var dt = ngModelCtrl.$viewValue ? dateParser.fromTimezone(new Date(ngModelCtrl.$viewValue), ngModelOptions.getOption('timezone')) : new Date(0, 0, 0, 0, 0, 0, 0);\n      dt.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());\n      dt = dateParser.toTimezone(dt, ngModelOptions.getOption('timezone'));\n      ngModelCtrl.$setViewValue(dt);\n      ngModelCtrl.$render();\n    } else {\n      self.activeDate = date;\n      setMode(self.modes[self.modes.indexOf($scope.datepickerMode) - 1]);\n\n      $scope.$emit('uib:datepicker.mode');\n    }\n\n    $scope.$broadcast('uib:datepicker.focus');\n  };\n\n  $scope.move = function(direction) {\n    var year = self.activeDate.getFullYear() + direction * (self.step.years || 0),\n        month = self.activeDate.getMonth() + direction * (self.step.months || 0);\n    self.activeDate.setFullYear(year, month, 1);\n    self.refreshView();\n  };\n\n  $scope.toggleMode = function(direction) {\n    direction = direction || 1;\n\n    if ($scope.datepickerMode === self.maxMode && direction === 1 ||\n      $scope.datepickerMode === self.minMode && direction === -1) {\n      return;\n    }\n\n    setMode(self.modes[self.modes.indexOf($scope.datepickerMode) + direction]);\n\n    $scope.$emit('uib:datepicker.mode');\n  };\n\n  // Key event mapper\n  $scope.keys = { 13: 'enter', 32: 'space', 33: 'pageup', 34: 'pagedown', 35: 'end', 36: 'home', 37: 'left', 38: 'up', 39: 'right', 40: 'down' };\n\n  var focusElement = function() {\n    self.element[0].focus();\n  };\n\n  // Listen for focus requests from popup directive\n  $scope.$on('uib:datepicker.focus', focusElement);\n\n  $scope.keydown = function(evt) {\n    var key = $scope.keys[evt.which];\n\n    if (!key || evt.shiftKey || evt.altKey || $scope.disabled) {\n      return;\n    }\n\n    evt.preventDefault();\n    if (!self.shortcutPropagation) {\n      evt.stopPropagation();\n    }\n\n    if (key === 'enter' || key === 'space') {\n      if (self.isDisabled(self.activeDate)) {\n        return; // do nothing\n      }\n      $scope.select(self.activeDate);\n    } else if (evt.ctrlKey && (key === 'up' || key === 'down')) {\n      $scope.toggleMode(key === 'up' ? 1 : -1);\n    } else {\n      self.handleKeyDown(key, evt);\n      self.refreshView();\n    }\n  };\n\n  $element.on('keydown', function(evt) {\n    $scope.$apply(function() {\n      $scope.keydown(evt);\n    });\n  });\n\n  $scope.$on('$destroy', function() {\n    //Clear all watch listeners on destroy\n    while (watchListeners.length) {\n      watchListeners.shift()();\n    }\n  });\n\n  function setMode(mode) {\n    $scope.datepickerMode = mode;\n    $scope.datepickerOptions.datepickerMode = mode;\n  }\n\n  function extractOptions(ngModelCtrl) {\n    var ngModelOptions;\n\n    if (angular.version.minor < 6) { // in angular < 1.6 $options could be missing\n      // guarantee a value\n      ngModelOptions = ngModelCtrl.$options ||\n        $scope.datepickerOptions.ngModelOptions ||\n        datepickerConfig.ngModelOptions ||\n        {};\n\n      // mimic 1.6+ api\n      ngModelOptions.getOption = function (key) {\n        return ngModelOptions[key];\n      };\n    } else { // in angular >=1.6 $options is always present\n      // ng-model-options defaults timezone to null; don't let its precedence squash a non-null value\n      var timezone = ngModelCtrl.$options.getOption('timezone') ||\n        ($scope.datepickerOptions.ngModelOptions ? $scope.datepickerOptions.ngModelOptions.timezone : null) ||\n        (datepickerConfig.ngModelOptions ? datepickerConfig.ngModelOptions.timezone : null);\n\n      // values passed to createChild override existing values\n      ngModelOptions = ngModelCtrl.$options // start with a ModelOptions instance\n        .createChild(datepickerConfig.ngModelOptions) // lowest precedence\n        .createChild($scope.datepickerOptions.ngModelOptions)\n        .createChild(ngModelCtrl.$options) // highest precedence\n        .createChild({timezone: timezone}); // to keep from squashing a non-null value\n    }\n\n    return ngModelOptions;\n  }\n}])\n\n.controller('UibDaypickerController', ['$scope', '$element', 'dateFilter', function(scope, $element, dateFilter) {\n  var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n\n  this.step = { months: 1 };\n  this.element = $element;\n  function getDaysInMonth(year, month) {\n    return month === 1 && year % 4 === 0 &&\n      (year % 100 !== 0 || year % 400 === 0) ? 29 : DAYS_IN_MONTH[month];\n  }\n\n  this.init = function(ctrl) {\n    angular.extend(ctrl, this);\n    scope.showWeeks = ctrl.showWeeks;\n    ctrl.refreshView();\n  };\n\n  this.getDates = function(startDate, n) {\n    var dates = new Array(n), current = new Date(startDate), i = 0, date;\n    while (i < n) {\n      date = new Date(current);\n      dates[i++] = date;\n      current.setDate(current.getDate() + 1);\n    }\n    return dates;\n  };\n\n  this._refreshView = function() {\n    var year = this.activeDate.getFullYear(),\n      month = this.activeDate.getMonth(),\n      firstDayOfMonth = new Date(this.activeDate);\n\n    firstDayOfMonth.setFullYear(year, month, 1);\n\n    var difference = this.startingDay - firstDayOfMonth.getDay(),\n      numDisplayedFromPreviousMonth = difference > 0 ?\n        7 - difference : - difference,\n      firstDate = new Date(firstDayOfMonth);\n\n    if (numDisplayedFromPreviousMonth > 0) {\n      firstDate.setDate(-numDisplayedFromPreviousMonth + 1);\n    }\n\n    // 42 is the number of days on a six-week calendar\n    var days = this.getDates(firstDate, 42);\n    for (var i = 0; i < 42; i ++) {\n      days[i] = angular.extend(this.createDateObject(days[i], this.formatDay), {\n        secondary: days[i].getMonth() !== month,\n        uid: scope.uniqueId + '-' + i\n      });\n    }\n\n    scope.labels = new Array(7);\n    for (var j = 0; j < 7; j++) {\n      scope.labels[j] = {\n        abbr: dateFilter(days[j].date, this.formatDayHeader),\n        full: dateFilter(days[j].date, 'EEEE')\n      };\n    }\n\n    scope.title = dateFilter(this.activeDate, this.formatDayTitle);\n    scope.rows = this.split(days, 7);\n\n    if (scope.showWeeks) {\n      scope.weekNumbers = [];\n      var thursdayIndex = (4 + 7 - this.startingDay) % 7,\n          numWeeks = scope.rows.length;\n      for (var curWeek = 0; curWeek < numWeeks; curWeek++) {\n        scope.weekNumbers.push(\n          getISO8601WeekNumber(scope.rows[curWeek][thursdayIndex].date));\n      }\n    }\n  };\n\n  this.compare = function(date1, date2) {\n    var _date1 = new Date(date1.getFullYear(), date1.getMonth(), date1.getDate());\n    var _date2 = new Date(date2.getFullYear(), date2.getMonth(), date2.getDate());\n    _date1.setFullYear(date1.getFullYear());\n    _date2.setFullYear(date2.getFullYear());\n    return _date1 - _date2;\n  };\n\n  function getISO8601WeekNumber(date) {\n    var checkDate = new Date(date);\n    checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7)); // Thursday\n    var time = checkDate.getTime();\n    checkDate.setMonth(0); // Compare with Jan 1\n    checkDate.setDate(1);\n    return Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;\n  }\n\n  this.handleKeyDown = function(key, evt) {\n    var date = this.activeDate.getDate();\n\n    if (key === 'left') {\n      date = date - 1;\n    } else if (key === 'up') {\n      date = date - 7;\n    } else if (key === 'right') {\n      date = date + 1;\n    } else if (key === 'down') {\n      date = date + 7;\n    } else if (key === 'pageup' || key === 'pagedown') {\n      var month = this.activeDate.getMonth() + (key === 'pageup' ? - 1 : 1);\n      this.activeDate.setMonth(month, 1);\n      date = Math.min(getDaysInMonth(this.activeDate.getFullYear(), this.activeDate.getMonth()), date);\n    } else if (key === 'home') {\n      date = 1;\n    } else if (key === 'end') {\n      date = getDaysInMonth(this.activeDate.getFullYear(), this.activeDate.getMonth());\n    }\n    this.activeDate.setDate(date);\n  };\n}])\n\n.controller('UibMonthpickerController', ['$scope', '$element', 'dateFilter', function(scope, $element, dateFilter) {\n  this.step = { years: 1 };\n  this.element = $element;\n\n  this.init = function(ctrl) {\n    angular.extend(ctrl, this);\n    ctrl.refreshView();\n  };\n\n  this._refreshView = function() {\n    var months = new Array(12),\n        year = this.activeDate.getFullYear(),\n        date;\n\n    for (var i = 0; i < 12; i++) {\n      date = new Date(this.activeDate);\n      date.setFullYear(year, i, 1);\n      months[i] = angular.extend(this.createDateObject(date, this.formatMonth), {\n        uid: scope.uniqueId + '-' + i\n      });\n    }\n\n    scope.title = dateFilter(this.activeDate, this.formatMonthTitle);\n    scope.rows = this.split(months, this.monthColumns);\n    scope.yearHeaderColspan = this.monthColumns > 3 ? this.monthColumns - 2 : 1;\n  };\n\n  this.compare = function(date1, date2) {\n    var _date1 = new Date(date1.getFullYear(), date1.getMonth());\n    var _date2 = new Date(date2.getFullYear(), date2.getMonth());\n    _date1.setFullYear(date1.getFullYear());\n    _date2.setFullYear(date2.getFullYear());\n    return _date1 - _date2;\n  };\n\n  this.handleKeyDown = function(key, evt) {\n    var date = this.activeDate.getMonth();\n\n    if (key === 'left') {\n      date = date - 1;\n    } else if (key === 'up') {\n      date = date - this.monthColumns;\n    } else if (key === 'right') {\n      date = date + 1;\n    } else if (key === 'down') {\n      date = date + this.monthColumns;\n    } else if (key === 'pageup' || key === 'pagedown') {\n      var year = this.activeDate.getFullYear() + (key === 'pageup' ? - 1 : 1);\n      this.activeDate.setFullYear(year);\n    } else if (key === 'home') {\n      date = 0;\n    } else if (key === 'end') {\n      date = 11;\n    }\n    this.activeDate.setMonth(date);\n  };\n}])\n\n.controller('UibYearpickerController', ['$scope', '$element', 'dateFilter', function(scope, $element, dateFilter) {\n  var columns, range;\n  this.element = $element;\n\n  function getStartingYear(year) {\n    return parseInt((year - 1) / range, 10) * range + 1;\n  }\n\n  this.yearpickerInit = function() {\n    columns = this.yearColumns;\n    range = this.yearRows * columns;\n    this.step = { years: range };\n  };\n\n  this._refreshView = function() {\n    var years = new Array(range), date;\n\n    for (var i = 0, start = getStartingYear(this.activeDate.getFullYear()); i < range; i++) {\n      date = new Date(this.activeDate);\n      date.setFullYear(start + i, 0, 1);\n      years[i] = angular.extend(this.createDateObject(date, this.formatYear), {\n        uid: scope.uniqueId + '-' + i\n      });\n    }\n\n    scope.title = [years[0].label, years[range - 1].label].join(' - ');\n    scope.rows = this.split(years, columns);\n    scope.columns = columns;\n  };\n\n  this.compare = function(date1, date2) {\n    return date1.getFullYear() - date2.getFullYear();\n  };\n\n  this.handleKeyDown = function(key, evt) {\n    var date = this.activeDate.getFullYear();\n\n    if (key === 'left') {\n      date = date - 1;\n    } else if (key === 'up') {\n      date = date - columns;\n    } else if (key === 'right') {\n      date = date + 1;\n    } else if (key === 'down') {\n      date = date + columns;\n    } else if (key === 'pageup' || key === 'pagedown') {\n      date += (key === 'pageup' ? - 1 : 1) * range;\n    } else if (key === 'home') {\n      date = getStartingYear(this.activeDate.getFullYear());\n    } else if (key === 'end') {\n      date = getStartingYear(this.activeDate.getFullYear()) + range - 1;\n    }\n    this.activeDate.setFullYear(date);\n  };\n}])\n\n.directive('uibDatepicker', function() {\n  return {\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'uib/template/datepicker/datepicker.html';\n    },\n    scope: {\n      datepickerOptions: '=?'\n    },\n    require: ['uibDatepicker', '^ngModel'],\n    restrict: 'A',\n    controller: 'UibDatepickerController',\n    controllerAs: 'datepicker',\n    link: function(scope, element, attrs, ctrls) {\n      var datepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\n      datepickerCtrl.init(ngModelCtrl);\n    }\n  };\n})\n\n.directive('uibDaypicker', function() {\n  return {\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'uib/template/datepicker/day.html';\n    },\n    require: ['^uibDatepicker', 'uibDaypicker'],\n    restrict: 'A',\n    controller: 'UibDaypickerController',\n    link: function(scope, element, attrs, ctrls) {\n      var datepickerCtrl = ctrls[0],\n        daypickerCtrl = ctrls[1];\n\n      daypickerCtrl.init(datepickerCtrl);\n    }\n  };\n})\n\n.directive('uibMonthpicker', function() {\n  return {\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'uib/template/datepicker/month.html';\n    },\n    require: ['^uibDatepicker', 'uibMonthpicker'],\n    restrict: 'A',\n    controller: 'UibMonthpickerController',\n    link: function(scope, element, attrs, ctrls) {\n      var datepickerCtrl = ctrls[0],\n        monthpickerCtrl = ctrls[1];\n\n      monthpickerCtrl.init(datepickerCtrl);\n    }\n  };\n})\n\n.directive('uibYearpicker', function() {\n  return {\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'uib/template/datepicker/year.html';\n    },\n    require: ['^uibDatepicker', 'uibYearpicker'],\n    restrict: 'A',\n    controller: 'UibYearpickerController',\n    link: function(scope, element, attrs, ctrls) {\n      var ctrl = ctrls[0];\n      angular.extend(ctrl, ctrls[1]);\n      ctrl.yearpickerInit();\n\n      ctrl.refreshView();\n    }\n  };\n});\n\nangular.module('ui.bootstrap.position', [])\n\n/**\n * A set of utility methods for working with the DOM.\n * It is meant to be used where we need to absolute-position elements in\n * relation to another element (this is the case for tooltips, popovers,\n * typeahead suggestions etc.).\n */\n  .factory('$uibPosition', ['$document', '$window', function($document, $window) {\n    /**\n     * Used by scrollbarWidth() function to cache scrollbar's width.\n     * Do not access this variable directly, use scrollbarWidth() instead.\n     */\n    var SCROLLBAR_WIDTH;\n    /**\n     * scrollbar on body and html element in IE and Edge overlay\n     * content and should be considered 0 width.\n     */\n    var BODY_SCROLLBAR_WIDTH;\n    var OVERFLOW_REGEX = {\n      normal: /(auto|scroll)/,\n      hidden: /(auto|scroll|hidden)/\n    };\n    var PLACEMENT_REGEX = {\n      auto: /\\s?auto?\\s?/i,\n      primary: /^(top|bottom|left|right)$/,\n      secondary: /^(top|bottom|left|right|center)$/,\n      vertical: /^(top|bottom)$/\n    };\n    var BODY_REGEX = /(HTML|BODY)/;\n\n    return {\n\n      /**\n       * Provides a raw DOM element from a jQuery/jQLite element.\n       *\n       * @param {element} elem - The element to convert.\n       *\n       * @returns {element} A HTML element.\n       */\n      getRawNode: function(elem) {\n        return elem.nodeName ? elem : elem[0] || elem;\n      },\n\n      /**\n       * Provides a parsed number for a style property.  Strips\n       * units and casts invalid numbers to 0.\n       *\n       * @param {string} value - The style value to parse.\n       *\n       * @returns {number} A valid number.\n       */\n      parseStyle: function(value) {\n        value = parseFloat(value);\n        return isFinite(value) ? value : 0;\n      },\n\n      /**\n       * Provides the closest positioned ancestor.\n       *\n       * @param {element} element - The element to get the offest parent for.\n       *\n       * @returns {element} The closest positioned ancestor.\n       */\n      offsetParent: function(elem) {\n        elem = this.getRawNode(elem);\n\n        var offsetParent = elem.offsetParent || $document[0].documentElement;\n\n        function isStaticPositioned(el) {\n          return ($window.getComputedStyle(el).position || 'static') === 'static';\n        }\n\n        while (offsetParent && offsetParent !== $document[0].documentElement && isStaticPositioned(offsetParent)) {\n          offsetParent = offsetParent.offsetParent;\n        }\n\n        return offsetParent || $document[0].documentElement;\n      },\n\n      /**\n       * Provides the scrollbar width, concept from TWBS measureScrollbar()\n       * function in https://github.com/twbs/bootstrap/blob/master/js/modal.js\n       * In IE and Edge, scollbar on body and html element overlay and should\n       * return a width of 0.\n       *\n       * @returns {number} The width of the browser scollbar.\n       */\n      scrollbarWidth: function(isBody) {\n        if (isBody) {\n          if (angular.isUndefined(BODY_SCROLLBAR_WIDTH)) {\n            var bodyElem = $document.find('body');\n            bodyElem.addClass('uib-position-body-scrollbar-measure');\n            BODY_SCROLLBAR_WIDTH = $window.innerWidth - bodyElem[0].clientWidth;\n            BODY_SCROLLBAR_WIDTH = isFinite(BODY_SCROLLBAR_WIDTH) ? BODY_SCROLLBAR_WIDTH : 0;\n            bodyElem.removeClass('uib-position-body-scrollbar-measure');\n          }\n          return BODY_SCROLLBAR_WIDTH;\n        }\n\n        if (angular.isUndefined(SCROLLBAR_WIDTH)) {\n          var scrollElem = angular.element('<div class=\"uib-position-scrollbar-measure\"></div>');\n          $document.find('body').append(scrollElem);\n          SCROLLBAR_WIDTH = scrollElem[0].offsetWidth - scrollElem[0].clientWidth;\n          SCROLLBAR_WIDTH = isFinite(SCROLLBAR_WIDTH) ? SCROLLBAR_WIDTH : 0;\n          scrollElem.remove();\n        }\n\n        return SCROLLBAR_WIDTH;\n      },\n\n      /**\n       * Provides the padding required on an element to replace the scrollbar.\n       *\n       * @returns {object} An object with the following properties:\n       *   <ul>\n       *     <li>**scrollbarWidth**: the width of the scrollbar</li>\n       *     <li>**widthOverflow**: whether the the width is overflowing</li>\n       *     <li>**right**: the amount of right padding on the element needed to replace the scrollbar</li>\n       *     <li>**rightOriginal**: the amount of right padding currently on the element</li>\n       *     <li>**heightOverflow**: whether the the height is overflowing</li>\n       *     <li>**bottom**: the amount of bottom padding on the element needed to replace the scrollbar</li>\n       *     <li>**bottomOriginal**: the amount of bottom padding currently on the element</li>\n       *   </ul>\n       */\n      scrollbarPadding: function(elem) {\n        elem = this.getRawNode(elem);\n\n        var elemStyle = $window.getComputedStyle(elem);\n        var paddingRight = this.parseStyle(elemStyle.paddingRight);\n        var paddingBottom = this.parseStyle(elemStyle.paddingBottom);\n        var scrollParent = this.scrollParent(elem, false, true);\n        var scrollbarWidth = this.scrollbarWidth(BODY_REGEX.test(scrollParent.tagName));\n\n        return {\n          scrollbarWidth: scrollbarWidth,\n          widthOverflow: scrollParent.scrollWidth > scrollParent.clientWidth,\n          right: paddingRight + scrollbarWidth,\n          originalRight: paddingRight,\n          heightOverflow: scrollParent.scrollHeight > scrollParent.clientHeight,\n          bottom: paddingBottom + scrollbarWidth,\n          originalBottom: paddingBottom\n         };\n      },\n\n      /**\n       * Checks to see if the element is scrollable.\n       *\n       * @param {element} elem - The element to check.\n       * @param {boolean=} [includeHidden=false] - Should scroll style of 'hidden' be considered,\n       *   default is false.\n       *\n       * @returns {boolean} Whether the element is scrollable.\n       */\n      isScrollable: function(elem, includeHidden) {\n        elem = this.getRawNode(elem);\n\n        var overflowRegex = includeHidden ? OVERFLOW_REGEX.hidden : OVERFLOW_REGEX.normal;\n        var elemStyle = $window.getComputedStyle(elem);\n        return overflowRegex.test(elemStyle.overflow + elemStyle.overflowY + elemStyle.overflowX);\n      },\n\n      /**\n       * Provides the closest scrollable ancestor.\n       * A port of the jQuery UI scrollParent method:\n       * https://github.com/jquery/jquery-ui/blob/master/ui/scroll-parent.js\n       *\n       * @param {element} elem - The element to find the scroll parent of.\n       * @param {boolean=} [includeHidden=false] - Should scroll style of 'hidden' be considered,\n       *   default is false.\n       * @param {boolean=} [includeSelf=false] - Should the element being passed be\n       * included in the scrollable llokup.\n       *\n       * @returns {element} A HTML element.\n       */\n      scrollParent: function(elem, includeHidden, includeSelf) {\n        elem = this.getRawNode(elem);\n\n        var overflowRegex = includeHidden ? OVERFLOW_REGEX.hidden : OVERFLOW_REGEX.normal;\n        var documentEl = $document[0].documentElement;\n        var elemStyle = $window.getComputedStyle(elem);\n        if (includeSelf && overflowRegex.test(elemStyle.overflow + elemStyle.overflowY + elemStyle.overflowX)) {\n          return elem;\n        }\n        var excludeStatic = elemStyle.position === 'absolute';\n        var scrollParent = elem.parentElement || documentEl;\n\n        if (scrollParent === documentEl || elemStyle.position === 'fixed') {\n          return documentEl;\n        }\n\n        while (scrollParent.parentElement && scrollParent !== documentEl) {\n          var spStyle = $window.getComputedStyle(scrollParent);\n          if (excludeStatic && spStyle.position !== 'static') {\n            excludeStatic = false;\n          }\n\n          if (!excludeStatic && overflowRegex.test(spStyle.overflow + spStyle.overflowY + spStyle.overflowX)) {\n            break;\n          }\n          scrollParent = scrollParent.parentElement;\n        }\n\n        return scrollParent;\n      },\n\n      /**\n       * Provides read-only equivalent of jQuery's position function:\n       * http://api.jquery.com/position/ - distance to closest positioned\n       * ancestor.  Does not account for margins by default like jQuery position.\n       *\n       * @param {element} elem - The element to caclulate the position on.\n       * @param {boolean=} [includeMargins=false] - Should margins be accounted\n       * for, default is false.\n       *\n       * @returns {object} An object with the following properties:\n       *   <ul>\n       *     <li>**width**: the width of the element</li>\n       *     <li>**height**: the height of the element</li>\n       *     <li>**top**: distance to top edge of offset parent</li>\n       *     <li>**left**: distance to left edge of offset parent</li>\n       *   </ul>\n       */\n      position: function(elem, includeMagins) {\n        elem = this.getRawNode(elem);\n\n        var elemOffset = this.offset(elem);\n        if (includeMagins) {\n          var elemStyle = $window.getComputedStyle(elem);\n          elemOffset.top -= this.parseStyle(elemStyle.marginTop);\n          elemOffset.left -= this.parseStyle(elemStyle.marginLeft);\n        }\n        var parent = this.offsetParent(elem);\n        var parentOffset = {top: 0, left: 0};\n\n        if (parent !== $document[0].documentElement) {\n          parentOffset = this.offset(parent);\n          parentOffset.top += parent.clientTop - parent.scrollTop;\n          parentOffset.left += parent.clientLeft - parent.scrollLeft;\n        }\n\n        return {\n          width: Math.round(angular.isNumber(elemOffset.width) ? elemOffset.width : elem.offsetWidth),\n          height: Math.round(angular.isNumber(elemOffset.height) ? elemOffset.height : elem.offsetHeight),\n          top: Math.round(elemOffset.top - parentOffset.top),\n          left: Math.round(elemOffset.left - parentOffset.left)\n        };\n      },\n\n      /**\n       * Provides read-only equivalent of jQuery's offset function:\n       * http://api.jquery.com/offset/ - distance to viewport.  Does\n       * not account for borders, margins, or padding on the body\n       * element.\n       *\n       * @param {element} elem - The element to calculate the offset on.\n       *\n       * @returns {object} An object with the following properties:\n       *   <ul>\n       *     <li>**width**: the width of the element</li>\n       *     <li>**height**: the height of the element</li>\n       *     <li>**top**: distance to top edge of viewport</li>\n       *     <li>**right**: distance to bottom edge of viewport</li>\n       *   </ul>\n       */\n      offset: function(elem) {\n        elem = this.getRawNode(elem);\n\n        var elemBCR = elem.getBoundingClientRect();\n        return {\n          width: Math.round(angular.isNumber(elemBCR.width) ? elemBCR.width : elem.offsetWidth),\n          height: Math.round(angular.isNumber(elemBCR.height) ? elemBCR.height : elem.offsetHeight),\n          top: Math.round(elemBCR.top + ($window.pageYOffset || $document[0].documentElement.scrollTop)),\n          left: Math.round(elemBCR.left + ($window.pageXOffset || $document[0].documentElement.scrollLeft))\n        };\n      },\n\n      /**\n       * Provides offset distance to the closest scrollable ancestor\n       * or viewport.  Accounts for border and scrollbar width.\n       *\n       * Right and bottom dimensions represent the distance to the\n       * respective edge of the viewport element.  If the element\n       * edge extends beyond the viewport, a negative value will be\n       * reported.\n       *\n       * @param {element} elem - The element to get the viewport offset for.\n       * @param {boolean=} [useDocument=false] - Should the viewport be the document element instead\n       * of the first scrollable element, default is false.\n       * @param {boolean=} [includePadding=true] - Should the padding on the offset parent element\n       * be accounted for, default is true.\n       *\n       * @returns {object} An object with the following properties:\n       *   <ul>\n       *     <li>**top**: distance to the top content edge of viewport element</li>\n       *     <li>**bottom**: distance to the bottom content edge of viewport element</li>\n       *     <li>**left**: distance to the left content edge of viewport element</li>\n       *     <li>**right**: distance to the right content edge of viewport element</li>\n       *   </ul>\n       */\n      viewportOffset: function(elem, useDocument, includePadding) {\n        elem = this.getRawNode(elem);\n        includePadding = includePadding !== false ? true : false;\n\n        var elemBCR = elem.getBoundingClientRect();\n        var offsetBCR = {top: 0, left: 0, bottom: 0, right: 0};\n\n        var offsetParent = useDocument ? $document[0].documentElement : this.scrollParent(elem);\n        var offsetParentBCR = offsetParent.getBoundingClientRect();\n\n        offsetBCR.top = offsetParentBCR.top + offsetParent.clientTop;\n        offsetBCR.left = offsetParentBCR.left + offsetParent.clientLeft;\n        if (offsetParent === $document[0].documentElement) {\n          offsetBCR.top += $window.pageYOffset;\n          offsetBCR.left += $window.pageXOffset;\n        }\n        offsetBCR.bottom = offsetBCR.top + offsetParent.clientHeight;\n        offsetBCR.right = offsetBCR.left + offsetParent.clientWidth;\n\n        if (includePadding) {\n          var offsetParentStyle = $window.getComputedStyle(offsetParent);\n          offsetBCR.top += this.parseStyle(offsetParentStyle.paddingTop);\n          offsetBCR.bottom -= this.parseStyle(offsetParentStyle.paddingBottom);\n          offsetBCR.left += this.parseStyle(offsetParentStyle.paddingLeft);\n          offsetBCR.right -= this.parseStyle(offsetParentStyle.paddingRight);\n        }\n\n        return {\n          top: Math.round(elemBCR.top - offsetBCR.top),\n          bottom: Math.round(offsetBCR.bottom - elemBCR.bottom),\n          left: Math.round(elemBCR.left - offsetBCR.left),\n          right: Math.round(offsetBCR.right - elemBCR.right)\n        };\n      },\n\n      /**\n       * Provides an array of placement values parsed from a placement string.\n       * Along with the 'auto' indicator, supported placement strings are:\n       *   <ul>\n       *     <li>top: element on top, horizontally centered on host element.</li>\n       *     <li>top-left: element on top, left edge aligned with host element left edge.</li>\n       *     <li>top-right: element on top, lerightft edge aligned with host element right edge.</li>\n       *     <li>bottom: element on bottom, horizontally centered on host element.</li>\n       *     <li>bottom-left: element on bottom, left edge aligned with host element left edge.</li>\n       *     <li>bottom-right: element on bottom, right edge aligned with host element right edge.</li>\n       *     <li>left: element on left, vertically centered on host element.</li>\n       *     <li>left-top: element on left, top edge aligned with host element top edge.</li>\n       *     <li>left-bottom: element on left, bottom edge aligned with host element bottom edge.</li>\n       *     <li>right: element on right, vertically centered on host element.</li>\n       *     <li>right-top: element on right, top edge aligned with host element top edge.</li>\n       *     <li>right-bottom: element on right, bottom edge aligned with host element bottom edge.</li>\n       *   </ul>\n       * A placement string with an 'auto' indicator is expected to be\n       * space separated from the placement, i.e: 'auto bottom-left'  If\n       * the primary and secondary placement values do not match 'top,\n       * bottom, left, right' then 'top' will be the primary placement and\n       * 'center' will be the secondary placement.  If 'auto' is passed, true\n       * will be returned as the 3rd value of the array.\n       *\n       * @param {string} placement - The placement string to parse.\n       *\n       * @returns {array} An array with the following values\n       * <ul>\n       *   <li>**[0]**: The primary placement.</li>\n       *   <li>**[1]**: The secondary placement.</li>\n       *   <li>**[2]**: If auto is passed: true, else undefined.</li>\n       * </ul>\n       */\n      parsePlacement: function(placement) {\n        var autoPlace = PLACEMENT_REGEX.auto.test(placement);\n        if (autoPlace) {\n          placement = placement.replace(PLACEMENT_REGEX.auto, '');\n        }\n\n        placement = placement.split('-');\n\n        placement[0] = placement[0] || 'top';\n        if (!PLACEMENT_REGEX.primary.test(placement[0])) {\n          placement[0] = 'top';\n        }\n\n        placement[1] = placement[1] || 'center';\n        if (!PLACEMENT_REGEX.secondary.test(placement[1])) {\n          placement[1] = 'center';\n        }\n\n        if (autoPlace) {\n          placement[2] = true;\n        } else {\n          placement[2] = false;\n        }\n\n        return placement;\n      },\n\n      /**\n       * Provides coordinates for an element to be positioned relative to\n       * another element.  Passing 'auto' as part of the placement parameter\n       * will enable smart placement - where the element fits. i.e:\n       * 'auto left-top' will check to see if there is enough space to the left\n       * of the hostElem to fit the targetElem, if not place right (same for secondary\n       * top placement).  Available space is calculated using the viewportOffset\n       * function.\n       *\n       * @param {element} hostElem - The element to position against.\n       * @param {element} targetElem - The element to position.\n       * @param {string=} [placement=top] - The placement for the targetElem,\n       *   default is 'top'. 'center' is assumed as secondary placement for\n       *   'top', 'left', 'right', and 'bottom' placements.  Available placements are:\n       *   <ul>\n       *     <li>top</li>\n       *     <li>top-right</li>\n       *     <li>top-left</li>\n       *     <li>bottom</li>\n       *     <li>bottom-left</li>\n       *     <li>bottom-right</li>\n       *     <li>left</li>\n       *     <li>left-top</li>\n       *     <li>left-bottom</li>\n       *     <li>right</li>\n       *     <li>right-top</li>\n       *     <li>right-bottom</li>\n       *   </ul>\n       * @param {boolean=} [appendToBody=false] - Should the top and left values returned\n       *   be calculated from the body element, default is false.\n       *\n       * @returns {object} An object with the following properties:\n       *   <ul>\n       *     <li>**top**: Value for targetElem top.</li>\n       *     <li>**left**: Value for targetElem left.</li>\n       *     <li>**placement**: The resolved placement.</li>\n       *   </ul>\n       */\n      positionElements: function(hostElem, targetElem, placement, appendToBody) {\n        hostElem = this.getRawNode(hostElem);\n        targetElem = this.getRawNode(targetElem);\n\n        // need to read from prop to support tests.\n        var targetWidth = angular.isDefined(targetElem.offsetWidth) ? targetElem.offsetWidth : targetElem.prop('offsetWidth');\n        var targetHeight = angular.isDefined(targetElem.offsetHeight) ? targetElem.offsetHeight : targetElem.prop('offsetHeight');\n\n        placement = this.parsePlacement(placement);\n\n        var hostElemPos = appendToBody ? this.offset(hostElem) : this.position(hostElem);\n        var targetElemPos = {top: 0, left: 0, placement: ''};\n\n        if (placement[2]) {\n          var viewportOffset = this.viewportOffset(hostElem, appendToBody);\n\n          var targetElemStyle = $window.getComputedStyle(targetElem);\n          var adjustedSize = {\n            width: targetWidth + Math.round(Math.abs(this.parseStyle(targetElemStyle.marginLeft) + this.parseStyle(targetElemStyle.marginRight))),\n            height: targetHeight + Math.round(Math.abs(this.parseStyle(targetElemStyle.marginTop) + this.parseStyle(targetElemStyle.marginBottom)))\n          };\n\n          placement[0] = placement[0] === 'top' && adjustedSize.height > viewportOffset.top && adjustedSize.height <= viewportOffset.bottom ? 'bottom' :\n                         placement[0] === 'bottom' && adjustedSize.height > viewportOffset.bottom && adjustedSize.height <= viewportOffset.top ? 'top' :\n                         placement[0] === 'left' && adjustedSize.width > viewportOffset.left && adjustedSize.width <= viewportOffset.right ? 'right' :\n                         placement[0] === 'right' && adjustedSize.width > viewportOffset.right && adjustedSize.width <= viewportOffset.left ? 'left' :\n                         placement[0];\n\n          placement[1] = placement[1] === 'top' && adjustedSize.height - hostElemPos.height > viewportOffset.bottom && adjustedSize.height - hostElemPos.height <= viewportOffset.top ? 'bottom' :\n                         placement[1] === 'bottom' && adjustedSize.height - hostElemPos.height > viewportOffset.top && adjustedSize.height - hostElemPos.height <= viewportOffset.bottom ? 'top' :\n                         placement[1] === 'left' && adjustedSize.width - hostElemPos.width > viewportOffset.right && adjustedSize.width - hostElemPos.width <= viewportOffset.left ? 'right' :\n                         placement[1] === 'right' && adjustedSize.width - hostElemPos.width > viewportOffset.left && adjustedSize.width - hostElemPos.width <= viewportOffset.right ? 'left' :\n                         placement[1];\n\n          if (placement[1] === 'center') {\n            if (PLACEMENT_REGEX.vertical.test(placement[0])) {\n              var xOverflow = hostElemPos.width / 2 - targetWidth / 2;\n              if (viewportOffset.left + xOverflow < 0 && adjustedSize.width - hostElemPos.width <= viewportOffset.right) {\n                placement[1] = 'left';\n              } else if (viewportOffset.right + xOverflow < 0 && adjustedSize.width - hostElemPos.width <= viewportOffset.left) {\n                placement[1] = 'right';\n              }\n            } else {\n              var yOverflow = hostElemPos.height / 2 - adjustedSize.height / 2;\n              if (viewportOffset.top + yOverflow < 0 && adjustedSize.height - hostElemPos.height <= viewportOffset.bottom) {\n                placement[1] = 'top';\n              } else if (viewportOffset.bottom + yOverflow < 0 && adjustedSize.height - hostElemPos.height <= viewportOffset.top) {\n                placement[1] = 'bottom';\n              }\n            }\n          }\n        }\n\n        switch (placement[0]) {\n          case 'top':\n            targetElemPos.top = hostElemPos.top - targetHeight;\n            break;\n          case 'bottom':\n            targetElemPos.top = hostElemPos.top + hostElemPos.height;\n            break;\n          case 'left':\n            targetElemPos.left = hostElemPos.left - targetWidth;\n            break;\n          case 'right':\n            targetElemPos.left = hostElemPos.left + hostElemPos.width;\n            break;\n        }\n\n        switch (placement[1]) {\n          case 'top':\n            targetElemPos.top = hostElemPos.top;\n            break;\n          case 'bottom':\n            targetElemPos.top = hostElemPos.top + hostElemPos.height - targetHeight;\n            break;\n          case 'left':\n            targetElemPos.left = hostElemPos.left;\n            break;\n          case 'right':\n            targetElemPos.left = hostElemPos.left + hostElemPos.width - targetWidth;\n            break;\n          case 'center':\n            if (PLACEMENT_REGEX.vertical.test(placement[0])) {\n              targetElemPos.left = hostElemPos.left + hostElemPos.width / 2 - targetWidth / 2;\n            } else {\n              targetElemPos.top = hostElemPos.top + hostElemPos.height / 2 - targetHeight / 2;\n            }\n            break;\n        }\n\n        targetElemPos.top = Math.round(targetElemPos.top);\n        targetElemPos.left = Math.round(targetElemPos.left);\n        targetElemPos.placement = placement[1] === 'center' ? placement[0] : placement[0] + '-' + placement[1];\n\n        return targetElemPos;\n      },\n\n      /**\n       * Provides a way to adjust the top positioning after first\n       * render to correctly align element to top after content\n       * rendering causes resized element height\n       *\n       * @param {array} placementClasses - The array of strings of classes\n       * element should have.\n       * @param {object} containerPosition - The object with container\n       * position information\n       * @param {number} initialHeight - The initial height for the elem.\n       * @param {number} currentHeight - The current height for the elem.\n       */\n      adjustTop: function(placementClasses, containerPosition, initialHeight, currentHeight) {\n        if (placementClasses.indexOf('top') !== -1 && initialHeight !== currentHeight) {\n          return {\n            top: containerPosition.top - currentHeight + 'px'\n          };\n        }\n      },\n\n      /**\n       * Provides a way for positioning tooltip & dropdown\n       * arrows when using placement options beyond the standard\n       * left, right, top, or bottom.\n       *\n       * @param {element} elem - The tooltip/dropdown element.\n       * @param {string} placement - The placement for the elem.\n       */\n      positionArrow: function(elem, placement) {\n        elem = this.getRawNode(elem);\n\n        var innerElem = elem.querySelector('.tooltip-inner, .popover-inner');\n        if (!innerElem) {\n          return;\n        }\n\n        var isTooltip = angular.element(innerElem).hasClass('tooltip-inner');\n\n        var arrowElem = isTooltip ? elem.querySelector('.tooltip-arrow') : elem.querySelector('.arrow');\n        if (!arrowElem) {\n          return;\n        }\n\n        var arrowCss = {\n          top: '',\n          bottom: '',\n          left: '',\n          right: ''\n        };\n\n        placement = this.parsePlacement(placement);\n        if (placement[1] === 'center') {\n          // no adjustment necessary - just reset styles\n          angular.element(arrowElem).css(arrowCss);\n          return;\n        }\n\n        var borderProp = 'border-' + placement[0] + '-width';\n        var borderWidth = $window.getComputedStyle(arrowElem)[borderProp];\n\n        var borderRadiusProp = 'border-';\n        if (PLACEMENT_REGEX.vertical.test(placement[0])) {\n          borderRadiusProp += placement[0] + '-' + placement[1];\n        } else {\n          borderRadiusProp += placement[1] + '-' + placement[0];\n        }\n        borderRadiusProp += '-radius';\n        var borderRadius = $window.getComputedStyle(isTooltip ? innerElem : elem)[borderRadiusProp];\n\n        switch (placement[0]) {\n          case 'top':\n            arrowCss.bottom = isTooltip ? '0' : '-' + borderWidth;\n            break;\n          case 'bottom':\n            arrowCss.top = isTooltip ? '0' : '-' + borderWidth;\n            break;\n          case 'left':\n            arrowCss.right = isTooltip ? '0' : '-' + borderWidth;\n            break;\n          case 'right':\n            arrowCss.left = isTooltip ? '0' : '-' + borderWidth;\n            break;\n        }\n\n        arrowCss[placement[1]] = borderRadius;\n\n        angular.element(arrowElem).css(arrowCss);\n      }\n    };\n  }]);\n\nangular.module('ui.bootstrap.datepickerPopup', ['ui.bootstrap.datepicker', 'ui.bootstrap.position'])\n\n.value('$datepickerPopupLiteralWarning', true)\n\n.constant('uibDatepickerPopupConfig', {\n  altInputFormats: [],\n  appendToBody: false,\n  clearText: 'Clear',\n  closeOnDateSelection: true,\n  closeText: 'Done',\n  currentText: 'Today',\n  datepickerPopup: 'yyyy-MM-dd',\n  datepickerPopupTemplateUrl: 'uib/template/datepickerPopup/popup.html',\n  datepickerTemplateUrl: 'uib/template/datepicker/datepicker.html',\n  html5Types: {\n    date: 'yyyy-MM-dd',\n    'datetime-local': 'yyyy-MM-ddTHH:mm:ss.sss',\n    'month': 'yyyy-MM'\n  },\n  onOpenFocus: true,\n  showButtonBar: true,\n  placement: 'auto bottom-left'\n})\n\n.controller('UibDatepickerPopupController', ['$scope', '$element', '$attrs', '$compile', '$log', '$parse', '$window', '$document', '$rootScope', '$uibPosition', 'dateFilter', 'uibDateParser', 'uibDatepickerPopupConfig', '$timeout', 'uibDatepickerConfig', '$datepickerPopupLiteralWarning',\nfunction($scope, $element, $attrs, $compile, $log, $parse, $window, $document, $rootScope, $position, dateFilter, dateParser, datepickerPopupConfig, $timeout, datepickerConfig, $datepickerPopupLiteralWarning) {\n  var cache = {},\n    isHtml5DateInput = false;\n  var dateFormat, closeOnDateSelection, appendToBody, onOpenFocus,\n    datepickerPopupTemplateUrl, datepickerTemplateUrl, popupEl, datepickerEl, scrollParentEl,\n    ngModel, ngModelOptions, $popup, altInputFormats, watchListeners = [];\n\n  this.init = function(_ngModel_) {\n    ngModel = _ngModel_;\n    ngModelOptions = extractOptions(ngModel);\n    closeOnDateSelection = angular.isDefined($attrs.closeOnDateSelection) ?\n      $scope.$parent.$eval($attrs.closeOnDateSelection) :\n      datepickerPopupConfig.closeOnDateSelection;\n    appendToBody = angular.isDefined($attrs.datepickerAppendToBody) ?\n      $scope.$parent.$eval($attrs.datepickerAppendToBody) :\n      datepickerPopupConfig.appendToBody;\n    onOpenFocus = angular.isDefined($attrs.onOpenFocus) ?\n      $scope.$parent.$eval($attrs.onOpenFocus) : datepickerPopupConfig.onOpenFocus;\n    datepickerPopupTemplateUrl = angular.isDefined($attrs.datepickerPopupTemplateUrl) ?\n      $attrs.datepickerPopupTemplateUrl :\n      datepickerPopupConfig.datepickerPopupTemplateUrl;\n    datepickerTemplateUrl = angular.isDefined($attrs.datepickerTemplateUrl) ?\n      $attrs.datepickerTemplateUrl : datepickerPopupConfig.datepickerTemplateUrl;\n    altInputFormats = angular.isDefined($attrs.altInputFormats) ?\n      $scope.$parent.$eval($attrs.altInputFormats) :\n      datepickerPopupConfig.altInputFormats;\n\n    $scope.showButtonBar = angular.isDefined($attrs.showButtonBar) ?\n      $scope.$parent.$eval($attrs.showButtonBar) :\n      datepickerPopupConfig.showButtonBar;\n\n    if (datepickerPopupConfig.html5Types[$attrs.type]) {\n      dateFormat = datepickerPopupConfig.html5Types[$attrs.type];\n      isHtml5DateInput = true;\n    } else {\n      dateFormat = $attrs.uibDatepickerPopup || datepickerPopupConfig.datepickerPopup;\n      $attrs.$observe('uibDatepickerPopup', function(value, oldValue) {\n        var newDateFormat = value || datepickerPopupConfig.datepickerPopup;\n        // Invalidate the $modelValue to ensure that formatters re-run\n        // FIXME: Refactor when PR is merged: https://github.com/angular/angular.js/pull/10764\n        if (newDateFormat !== dateFormat) {\n          dateFormat = newDateFormat;\n          ngModel.$modelValue = null;\n\n          if (!dateFormat) {\n            throw new Error('uibDatepickerPopup must have a date format specified.');\n          }\n        }\n      });\n    }\n\n    if (!dateFormat) {\n      throw new Error('uibDatepickerPopup must have a date format specified.');\n    }\n\n    if (isHtml5DateInput && $attrs.uibDatepickerPopup) {\n      throw new Error('HTML5 date input types do not support custom formats.');\n    }\n\n    // popup element used to display calendar\n    popupEl = angular.element('<div uib-datepicker-popup-wrap><div uib-datepicker></div></div>');\n\n    popupEl.attr({\n      'ng-model': 'date',\n      'ng-change': 'dateSelection(date)',\n      'template-url': datepickerPopupTemplateUrl\n    });\n\n    // datepicker element\n    datepickerEl = angular.element(popupEl.children()[0]);\n    datepickerEl.attr('template-url', datepickerTemplateUrl);\n\n    if (!$scope.datepickerOptions) {\n      $scope.datepickerOptions = {};\n    }\n\n    if (isHtml5DateInput) {\n      if ($attrs.type === 'month') {\n        $scope.datepickerOptions.datepickerMode = 'month';\n        $scope.datepickerOptions.minMode = 'month';\n      }\n    }\n\n    datepickerEl.attr('datepicker-options', 'datepickerOptions');\n\n    if (!isHtml5DateInput) {\n      // Internal API to maintain the correct ng-invalid-[key] class\n      ngModel.$$parserName = 'date';\n      ngModel.$validators.date = validator;\n      ngModel.$parsers.unshift(parseDate);\n      ngModel.$formatters.push(function(value) {\n        if (ngModel.$isEmpty(value)) {\n          $scope.date = value;\n          return value;\n        }\n\n        if (angular.isNumber(value)) {\n          value = new Date(value);\n        }\n\n        $scope.date = dateParser.fromTimezone(value, ngModelOptions.getOption('timezone'));\n\n        return dateParser.filter($scope.date, dateFormat);\n      });\n    } else {\n      ngModel.$formatters.push(function(value) {\n        $scope.date = dateParser.fromTimezone(value, ngModelOptions.getOption('timezone'));\n        return value;\n      });\n    }\n\n    // Detect changes in the view from the text box\n    ngModel.$viewChangeListeners.push(function() {\n      $scope.date = parseDateString(ngModel.$viewValue);\n    });\n\n    $element.on('keydown', inputKeydownBind);\n\n    $popup = $compile(popupEl)($scope);\n    // Prevent jQuery cache memory leak (template is now redundant after linking)\n    popupEl.remove();\n\n    if (appendToBody) {\n      $document.find('body').append($popup);\n    } else {\n      $element.after($popup);\n    }\n\n    $scope.$on('$destroy', function() {\n      if ($scope.isOpen === true) {\n        if (!$rootScope.$$phase) {\n          $scope.$apply(function() {\n            $scope.isOpen = false;\n          });\n        }\n      }\n\n      $popup.remove();\n      $element.off('keydown', inputKeydownBind);\n      $document.off('click', documentClickBind);\n      if (scrollParentEl) {\n        scrollParentEl.off('scroll', positionPopup);\n      }\n      angular.element($window).off('resize', positionPopup);\n\n      //Clear all watch listeners on destroy\n      while (watchListeners.length) {\n        watchListeners.shift()();\n      }\n    });\n  };\n\n  $scope.getText = function(key) {\n    return $scope[key + 'Text'] || datepickerPopupConfig[key + 'Text'];\n  };\n\n  $scope.isDisabled = function(date) {\n    if (date === 'today') {\n      date = dateParser.fromTimezone(new Date(), ngModelOptions.getOption('timezone'));\n    }\n\n    var dates = {};\n    angular.forEach(['minDate', 'maxDate'], function(key) {\n      if (!$scope.datepickerOptions[key]) {\n        dates[key] = null;\n      } else if (angular.isDate($scope.datepickerOptions[key])) {\n        dates[key] = new Date($scope.datepickerOptions[key]);\n      } else {\n        if ($datepickerPopupLiteralWarning) {\n          $log.warn('Literal date support has been deprecated, please switch to date object usage');\n        }\n\n        dates[key] = new Date(dateFilter($scope.datepickerOptions[key], 'medium'));\n      }\n    });\n\n    return $scope.datepickerOptions &&\n      dates.minDate && $scope.compare(date, dates.minDate) < 0 ||\n      dates.maxDate && $scope.compare(date, dates.maxDate) > 0;\n  };\n\n  $scope.compare = function(date1, date2) {\n    return new Date(date1.getFullYear(), date1.getMonth(), date1.getDate()) - new Date(date2.getFullYear(), date2.getMonth(), date2.getDate());\n  };\n\n  // Inner change\n  $scope.dateSelection = function(dt) {\n    $scope.date = dt;\n    var date = $scope.date ? dateParser.filter($scope.date, dateFormat) : null; // Setting to NULL is necessary for form validators to function\n    $element.val(date);\n    ngModel.$setViewValue(date);\n\n    if (closeOnDateSelection) {\n      $scope.isOpen = false;\n      $element[0].focus();\n    }\n  };\n\n  $scope.keydown = function(evt) {\n    if (evt.which === 27) {\n      evt.stopPropagation();\n      $scope.isOpen = false;\n      $element[0].focus();\n    }\n  };\n\n  $scope.select = function(date, evt) {\n    evt.stopPropagation();\n\n    if (date === 'today') {\n      var today = new Date();\n      if (angular.isDate($scope.date)) {\n        date = new Date($scope.date);\n        date.setFullYear(today.getFullYear(), today.getMonth(), today.getDate());\n      } else {\n        date = dateParser.fromTimezone(today, ngModelOptions.getOption('timezone'));\n        date.setHours(0, 0, 0, 0);\n      }\n    }\n    $scope.dateSelection(date);\n  };\n\n  $scope.close = function(evt) {\n    evt.stopPropagation();\n\n    $scope.isOpen = false;\n    $element[0].focus();\n  };\n\n  $scope.disabled = angular.isDefined($attrs.disabled) || false;\n  if ($attrs.ngDisabled) {\n    watchListeners.push($scope.$parent.$watch($parse($attrs.ngDisabled), function(disabled) {\n      $scope.disabled = disabled;\n    }));\n  }\n\n  $scope.$watch('isOpen', function(value) {\n    if (value) {\n      if (!$scope.disabled) {\n        $timeout(function() {\n          positionPopup();\n\n          if (onOpenFocus) {\n            $scope.$broadcast('uib:datepicker.focus');\n          }\n\n          $document.on('click', documentClickBind);\n\n          var placement = $attrs.popupPlacement ? $attrs.popupPlacement : datepickerPopupConfig.placement;\n          if (appendToBody || $position.parsePlacement(placement)[2]) {\n            scrollParentEl = scrollParentEl || angular.element($position.scrollParent($element));\n            if (scrollParentEl) {\n              scrollParentEl.on('scroll', positionPopup);\n            }\n          } else {\n            scrollParentEl = null;\n          }\n\n          angular.element($window).on('resize', positionPopup);\n        }, 0, false);\n      } else {\n        $scope.isOpen = false;\n      }\n    } else {\n      $document.off('click', documentClickBind);\n      if (scrollParentEl) {\n        scrollParentEl.off('scroll', positionPopup);\n      }\n      angular.element($window).off('resize', positionPopup);\n    }\n  });\n\n  function cameltoDash(string) {\n    return string.replace(/([A-Z])/g, function($1) { return '-' + $1.toLowerCase(); });\n  }\n\n  function parseDateString(viewValue) {\n    var date = dateParser.parse(viewValue, dateFormat, $scope.date);\n    if (isNaN(date)) {\n      for (var i = 0; i < altInputFormats.length; i++) {\n        date = dateParser.parse(viewValue, altInputFormats[i], $scope.date);\n        if (!isNaN(date)) {\n          return date;\n        }\n      }\n    }\n    return date;\n  }\n\n  function parseDate(viewValue) {\n    if (angular.isNumber(viewValue)) {\n      // presumably timestamp to date object\n      viewValue = new Date(viewValue);\n    }\n\n    if (!viewValue) {\n      return null;\n    }\n\n    if (angular.isDate(viewValue) && !isNaN(viewValue)) {\n      return viewValue;\n    }\n\n    if (angular.isString(viewValue)) {\n      var date = parseDateString(viewValue);\n      if (!isNaN(date)) {\n        return dateParser.toTimezone(date, ngModelOptions.getOption('timezone'));\n      }\n    }\n\n    return ngModelOptions.getOption('allowInvalid') ? viewValue : undefined;\n  }\n\n  function validator(modelValue, viewValue) {\n    var value = modelValue || viewValue;\n\n    if (!$attrs.ngRequired && !value) {\n      return true;\n    }\n\n    if (angular.isNumber(value)) {\n      value = new Date(value);\n    }\n\n    if (!value) {\n      return true;\n    }\n\n    if (angular.isDate(value) && !isNaN(value)) {\n      return true;\n    }\n\n    if (angular.isString(value)) {\n      return !isNaN(parseDateString(value));\n    }\n\n    return false;\n  }\n\n  function documentClickBind(event) {\n    if (!$scope.isOpen && $scope.disabled) {\n      return;\n    }\n\n    var popup = $popup[0];\n    var dpContainsTarget = $element[0].contains(event.target);\n    // The popup node may not be an element node\n    // In some browsers (IE) only element nodes have the 'contains' function\n    var popupContainsTarget = popup.contains !== undefined && popup.contains(event.target);\n    if ($scope.isOpen && !(dpContainsTarget || popupContainsTarget)) {\n      $scope.$apply(function() {\n        $scope.isOpen = false;\n      });\n    }\n  }\n\n  function inputKeydownBind(evt) {\n    if (evt.which === 27 && $scope.isOpen) {\n      evt.preventDefault();\n      evt.stopPropagation();\n      $scope.$apply(function() {\n        $scope.isOpen = false;\n      });\n      $element[0].focus();\n    } else if (evt.which === 40 && !$scope.isOpen) {\n      evt.preventDefault();\n      evt.stopPropagation();\n      $scope.$apply(function() {\n        $scope.isOpen = true;\n      });\n    }\n  }\n\n  function positionPopup() {\n    if ($scope.isOpen) {\n      var dpElement = angular.element($popup[0].querySelector('.uib-datepicker-popup'));\n      var placement = $attrs.popupPlacement ? $attrs.popupPlacement : datepickerPopupConfig.placement;\n      var position = $position.positionElements($element, dpElement, placement, appendToBody);\n      dpElement.css({top: position.top + 'px', left: position.left + 'px'});\n      if (dpElement.hasClass('uib-position-measure')) {\n        dpElement.removeClass('uib-position-measure');\n      }\n    }\n  }\n\n  function extractOptions(ngModelCtrl) {\n    var ngModelOptions;\n\n    if (angular.version.minor < 6) { // in angular < 1.6 $options could be missing\n      // guarantee a value\n      ngModelOptions = angular.isObject(ngModelCtrl.$options) ?\n        ngModelCtrl.$options :\n        {\n          timezone: null\n        };\n\n      // mimic 1.6+ api\n      ngModelOptions.getOption = function (key) {\n        return ngModelOptions[key];\n      };\n    } else { // in angular >=1.6 $options is always present\n      ngModelOptions = ngModelCtrl.$options;\n    }\n\n    return ngModelOptions;\n  }\n\n  $scope.$on('uib:datepicker.mode', function() {\n    $timeout(positionPopup, 0, false);\n  });\n}])\n\n.directive('uibDatepickerPopup', function() {\n  return {\n    require: ['ngModel', 'uibDatepickerPopup'],\n    controller: 'UibDatepickerPopupController',\n    scope: {\n      datepickerOptions: '=?',\n      isOpen: '=?',\n      currentText: '@',\n      clearText: '@',\n      closeText: '@'\n    },\n    link: function(scope, element, attrs, ctrls) {\n      var ngModel = ctrls[0],\n        ctrl = ctrls[1];\n\n      ctrl.init(ngModel);\n    }\n  };\n})\n\n.directive('uibDatepickerPopupWrap', function() {\n  return {\n    restrict: 'A',\n    transclude: true,\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'uib/template/datepickerPopup/popup.html';\n    }\n  };\n});\n\nangular.module('ui.bootstrap.debounce', [])\n/**\n * A helper, internal service that debounces a function\n */\n  .factory('$$debounce', ['$timeout', function($timeout) {\n    return function(callback, debounceTime) {\n      var timeoutPromise;\n\n      return function() {\n        var self = this;\n        var args = Array.prototype.slice.call(arguments);\n        if (timeoutPromise) {\n          $timeout.cancel(timeoutPromise);\n        }\n\n        timeoutPromise = $timeout(function() {\n          callback.apply(self, args);\n        }, debounceTime);\n      };\n    };\n  }]);\n\nangular.module('ui.bootstrap.multiMap', [])\n/**\n * A helper, internal data structure that stores all references attached to key\n */\n  .factory('$$multiMap', function() {\n    return {\n      createNew: function() {\n        var map = {};\n\n        return {\n          entries: function() {\n            return Object.keys(map).map(function(key) {\n              return {\n                key: key,\n                value: map[key]\n              };\n            });\n          },\n          get: function(key) {\n            return map[key];\n          },\n          hasKey: function(key) {\n            return !!map[key];\n          },\n          keys: function() {\n            return Object.keys(map);\n          },\n          put: function(key, value) {\n            if (!map[key]) {\n              map[key] = [];\n            }\n\n            map[key].push(value);\n          },\n          remove: function(key, value) {\n            var values = map[key];\n\n            if (!values) {\n              return;\n            }\n\n            var idx = values.indexOf(value);\n\n            if (idx !== -1) {\n              values.splice(idx, 1);\n            }\n\n            if (!values.length) {\n              delete map[key];\n            }\n          }\n        };\n      }\n    };\n  });\n\nangular.module('ui.bootstrap.dropdown', ['ui.bootstrap.multiMap', 'ui.bootstrap.position'])\n\n.constant('uibDropdownConfig', {\n  appendToOpenClass: 'uib-dropdown-open',\n  openClass: 'open'\n})\n\n.service('uibDropdownService', ['$document', '$rootScope', '$$multiMap', function($document, $rootScope, $$multiMap) {\n  var openScope = null;\n  var openedContainers = $$multiMap.createNew();\n\n  this.isOnlyOpen = function(dropdownScope, appendTo) {\n    var openedDropdowns = openedContainers.get(appendTo);\n    if (openedDropdowns) {\n      var openDropdown = openedDropdowns.reduce(function(toClose, dropdown) {\n        if (dropdown.scope === dropdownScope) {\n          return dropdown;\n        }\n\n        return toClose;\n      }, {});\n      if (openDropdown) {\n        return openedDropdowns.length === 1;\n      }\n    }\n\n    return false;\n  };\n\n  this.open = function(dropdownScope, element, appendTo) {\n    if (!openScope) {\n      $document.on('click', closeDropdown);\n    }\n\n    if (openScope && openScope !== dropdownScope) {\n      openScope.isOpen = false;\n    }\n\n    openScope = dropdownScope;\n\n    if (!appendTo) {\n      return;\n    }\n\n    var openedDropdowns = openedContainers.get(appendTo);\n    if (openedDropdowns) {\n      var openedScopes = openedDropdowns.map(function(dropdown) {\n        return dropdown.scope;\n      });\n      if (openedScopes.indexOf(dropdownScope) === -1) {\n        openedContainers.put(appendTo, {\n          scope: dropdownScope\n        });\n      }\n    } else {\n      openedContainers.put(appendTo, {\n        scope: dropdownScope\n      });\n    }\n  };\n\n  this.close = function(dropdownScope, element, appendTo) {\n    if (openScope === dropdownScope) {\n      $document.off('click', closeDropdown);\n      $document.off('keydown', this.keybindFilter);\n      openScope = null;\n    }\n\n    if (!appendTo) {\n      return;\n    }\n\n    var openedDropdowns = openedContainers.get(appendTo);\n    if (openedDropdowns) {\n      var dropdownToClose = openedDropdowns.reduce(function(toClose, dropdown) {\n        if (dropdown.scope === dropdownScope) {\n          return dropdown;\n        }\n\n        return toClose;\n      }, {});\n      if (dropdownToClose) {\n        openedContainers.remove(appendTo, dropdownToClose);\n      }\n    }\n  };\n\n  var closeDropdown = function(evt) {\n    // This method may still be called during the same mouse event that\n    // unbound this event handler. So check openScope before proceeding.\n    if (!openScope || !openScope.isOpen) { return; }\n\n    if (evt && openScope.getAutoClose() === 'disabled') { return; }\n\n    if (evt && evt.which === 3) { return; }\n\n    var toggleElement = openScope.getToggleElement();\n    if (evt && toggleElement && toggleElement[0].contains(evt.target)) {\n      return;\n    }\n\n    var dropdownElement = openScope.getDropdownElement();\n    if (evt && openScope.getAutoClose() === 'outsideClick' &&\n      dropdownElement && dropdownElement[0].contains(evt.target)) {\n      return;\n    }\n\n    openScope.focusToggleElement();\n    openScope.isOpen = false;\n\n    if (!$rootScope.$$phase) {\n      openScope.$apply();\n    }\n  };\n\n  this.keybindFilter = function(evt) {\n    if (!openScope) {\n      // see this.close as ESC could have been pressed which kills the scope so we can not proceed\n      return;\n    }\n\n    var dropdownElement = openScope.getDropdownElement();\n    var toggleElement = openScope.getToggleElement();\n    var dropdownElementTargeted = dropdownElement && dropdownElement[0].contains(evt.target);\n    var toggleElementTargeted = toggleElement && toggleElement[0].contains(evt.target);\n    if (evt.which === 27) {\n      evt.stopPropagation();\n      openScope.focusToggleElement();\n      closeDropdown();\n    } else if (openScope.isKeynavEnabled() && [38, 40].indexOf(evt.which) !== -1 && openScope.isOpen && (dropdownElementTargeted || toggleElementTargeted)) {\n      evt.preventDefault();\n      evt.stopPropagation();\n      openScope.focusDropdownEntry(evt.which);\n    }\n  };\n}])\n\n.controller('UibDropdownController', ['$scope', '$element', '$attrs', '$parse', 'uibDropdownConfig', 'uibDropdownService', '$animate', '$uibPosition', '$document', '$compile', '$templateRequest', function($scope, $element, $attrs, $parse, dropdownConfig, uibDropdownService, $animate, $position, $document, $compile, $templateRequest) {\n  var self = this,\n    scope = $scope.$new(), // create a child scope so we are not polluting original one\n    templateScope,\n    appendToOpenClass = dropdownConfig.appendToOpenClass,\n    openClass = dropdownConfig.openClass,\n    getIsOpen,\n    setIsOpen = angular.noop,\n    toggleInvoker = $attrs.onToggle ? $parse($attrs.onToggle) : angular.noop,\n    keynavEnabled = false,\n    selectedOption = null,\n    body = $document.find('body');\n\n  $element.addClass('dropdown');\n\n  this.init = function() {\n    if ($attrs.isOpen) {\n      getIsOpen = $parse($attrs.isOpen);\n      setIsOpen = getIsOpen.assign;\n\n      $scope.$watch(getIsOpen, function(value) {\n        scope.isOpen = !!value;\n      });\n    }\n\n    keynavEnabled = angular.isDefined($attrs.keyboardNav);\n  };\n\n  this.toggle = function(open) {\n    scope.isOpen = arguments.length ? !!open : !scope.isOpen;\n    if (angular.isFunction(setIsOpen)) {\n      setIsOpen(scope, scope.isOpen);\n    }\n\n    return scope.isOpen;\n  };\n\n  // Allow other directives to watch status\n  this.isOpen = function() {\n    return scope.isOpen;\n  };\n\n  scope.getToggleElement = function() {\n    return self.toggleElement;\n  };\n\n  scope.getAutoClose = function() {\n    return $attrs.autoClose || 'always'; //or 'outsideClick' or 'disabled'\n  };\n\n  scope.getElement = function() {\n    return $element;\n  };\n\n  scope.isKeynavEnabled = function() {\n    return keynavEnabled;\n  };\n\n  scope.focusDropdownEntry = function(keyCode) {\n    var elems = self.dropdownMenu ? //If append to body is used.\n      angular.element(self.dropdownMenu).find('a') :\n      $element.find('ul').eq(0).find('a');\n\n    switch (keyCode) {\n      case 40: {\n        if (!angular.isNumber(self.selectedOption)) {\n          self.selectedOption = 0;\n        } else {\n          self.selectedOption = self.selectedOption === elems.length - 1 ?\n            self.selectedOption :\n            self.selectedOption + 1;\n        }\n        break;\n      }\n      case 38: {\n        if (!angular.isNumber(self.selectedOption)) {\n          self.selectedOption = elems.length - 1;\n        } else {\n          self.selectedOption = self.selectedOption === 0 ?\n            0 : self.selectedOption - 1;\n        }\n        break;\n      }\n    }\n    elems[self.selectedOption].focus();\n  };\n\n  scope.getDropdownElement = function() {\n    return self.dropdownMenu;\n  };\n\n  scope.focusToggleElement = function() {\n    if (self.toggleElement) {\n      self.toggleElement[0].focus();\n    }\n  };\n\n  function removeDropdownMenu() {\n    $element.append(self.dropdownMenu);\n  }\n\n  scope.$watch('isOpen', function(isOpen, wasOpen) {\n    var appendTo = null,\n      appendToBody = false;\n\n    if (angular.isDefined($attrs.dropdownAppendTo)) {\n      var appendToEl = $parse($attrs.dropdownAppendTo)(scope);\n      if (appendToEl) {\n        appendTo = angular.element(appendToEl);\n      }\n    }\n\n    if (angular.isDefined($attrs.dropdownAppendToBody)) {\n      var appendToBodyValue = $parse($attrs.dropdownAppendToBody)(scope);\n      if (appendToBodyValue !== false) {\n        appendToBody = true;\n      }\n    }\n\n    if (appendToBody && !appendTo) {\n      appendTo = body;\n    }\n\n    if (appendTo && self.dropdownMenu) {\n      if (isOpen) {\n        appendTo.append(self.dropdownMenu);\n        $element.on('$destroy', removeDropdownMenu);\n      } else {\n        $element.off('$destroy', removeDropdownMenu);\n        removeDropdownMenu();\n      }\n    }\n\n    if (appendTo && self.dropdownMenu) {\n      var pos = $position.positionElements($element, self.dropdownMenu, 'bottom-left', true),\n        css,\n        rightalign,\n        scrollbarPadding,\n        scrollbarWidth = 0;\n\n      css = {\n        top: pos.top + 'px',\n        display: isOpen ? 'block' : 'none'\n      };\n\n      rightalign = self.dropdownMenu.hasClass('dropdown-menu-right');\n      if (!rightalign) {\n        css.left = pos.left + 'px';\n        css.right = 'auto';\n      } else {\n        css.left = 'auto';\n        scrollbarPadding = $position.scrollbarPadding(appendTo);\n\n        if (scrollbarPadding.heightOverflow && scrollbarPadding.scrollbarWidth) {\n          scrollbarWidth = scrollbarPadding.scrollbarWidth;\n        }\n\n        css.right = window.innerWidth - scrollbarWidth -\n          (pos.left + $element.prop('offsetWidth')) + 'px';\n      }\n\n      // Need to adjust our positioning to be relative to the appendTo container\n      // if it's not the body element\n      if (!appendToBody) {\n        var appendOffset = $position.offset(appendTo);\n\n        css.top = pos.top - appendOffset.top + 'px';\n\n        if (!rightalign) {\n          css.left = pos.left - appendOffset.left + 'px';\n        } else {\n          css.right = window.innerWidth -\n            (pos.left - appendOffset.left + $element.prop('offsetWidth')) + 'px';\n        }\n      }\n\n      self.dropdownMenu.css(css);\n    }\n\n    var openContainer = appendTo ? appendTo : $element;\n    var dropdownOpenClass = appendTo ? appendToOpenClass : openClass;\n    var hasOpenClass = openContainer.hasClass(dropdownOpenClass);\n    var isOnlyOpen = uibDropdownService.isOnlyOpen($scope, appendTo);\n\n    if (hasOpenClass === !isOpen) {\n      var toggleClass;\n      if (appendTo) {\n        toggleClass = !isOnlyOpen ? 'addClass' : 'removeClass';\n      } else {\n        toggleClass = isOpen ? 'addClass' : 'removeClass';\n      }\n      $animate[toggleClass](openContainer, dropdownOpenClass).then(function() {\n        if (angular.isDefined(isOpen) && isOpen !== wasOpen) {\n          toggleInvoker($scope, { open: !!isOpen });\n        }\n      });\n    }\n\n    if (isOpen) {\n      if (self.dropdownMenuTemplateUrl) {\n        $templateRequest(self.dropdownMenuTemplateUrl).then(function(tplContent) {\n          templateScope = scope.$new();\n          $compile(tplContent.trim())(templateScope, function(dropdownElement) {\n            var newEl = dropdownElement;\n            self.dropdownMenu.replaceWith(newEl);\n            self.dropdownMenu = newEl;\n            $document.on('keydown', uibDropdownService.keybindFilter);\n          });\n        });\n      } else {\n        $document.on('keydown', uibDropdownService.keybindFilter);\n      }\n\n      scope.focusToggleElement();\n      uibDropdownService.open(scope, $element, appendTo);\n    } else {\n      uibDropdownService.close(scope, $element, appendTo);\n      if (self.dropdownMenuTemplateUrl) {\n        if (templateScope) {\n          templateScope.$destroy();\n        }\n        var newEl = angular.element('<ul class=\"dropdown-menu\"></ul>');\n        self.dropdownMenu.replaceWith(newEl);\n        self.dropdownMenu = newEl;\n      }\n\n      self.selectedOption = null;\n    }\n\n    if (angular.isFunction(setIsOpen)) {\n      setIsOpen($scope, isOpen);\n    }\n  });\n}])\n\n.directive('uibDropdown', function() {\n  return {\n    controller: 'UibDropdownController',\n    link: function(scope, element, attrs, dropdownCtrl) {\n      dropdownCtrl.init();\n    }\n  };\n})\n\n.directive('uibDropdownMenu', function() {\n  return {\n    restrict: 'A',\n    require: '?^uibDropdown',\n    link: function(scope, element, attrs, dropdownCtrl) {\n      if (!dropdownCtrl || angular.isDefined(attrs.dropdownNested)) {\n        return;\n      }\n\n      element.addClass('dropdown-menu');\n\n      var tplUrl = attrs.templateUrl;\n      if (tplUrl) {\n        dropdownCtrl.dropdownMenuTemplateUrl = tplUrl;\n      }\n\n      if (!dropdownCtrl.dropdownMenu) {\n        dropdownCtrl.dropdownMenu = element;\n      }\n    }\n  };\n})\n\n.directive('uibDropdownToggle', function() {\n  return {\n    require: '?^uibDropdown',\n    link: function(scope, element, attrs, dropdownCtrl) {\n      if (!dropdownCtrl) {\n        return;\n      }\n\n      element.addClass('dropdown-toggle');\n\n      dropdownCtrl.toggleElement = element;\n\n      var toggleDropdown = function(event) {\n        event.preventDefault();\n\n        if (!element.hasClass('disabled') && !attrs.disabled) {\n          scope.$apply(function() {\n            dropdownCtrl.toggle();\n          });\n        }\n      };\n\n      element.on('click', toggleDropdown);\n\n      // WAI-ARIA\n      element.attr({ 'aria-haspopup': true, 'aria-expanded': false });\n      scope.$watch(dropdownCtrl.isOpen, function(isOpen) {\n        element.attr('aria-expanded', !!isOpen);\n      });\n\n      scope.$on('$destroy', function() {\n        element.off('click', toggleDropdown);\n      });\n    }\n  };\n});\n\nangular.module('ui.bootstrap.stackedMap', [])\n/**\n * A helper, internal data structure that acts as a map but also allows getting / removing\n * elements in the LIFO order\n */\n  .factory('$$stackedMap', function() {\n    return {\n      createNew: function() {\n        var stack = [];\n\n        return {\n          add: function(key, value) {\n            stack.push({\n              key: key,\n              value: value\n            });\n          },\n          get: function(key) {\n            for (var i = 0; i < stack.length; i++) {\n              if (key === stack[i].key) {\n                return stack[i];\n              }\n            }\n          },\n          keys: function() {\n            var keys = [];\n            for (var i = 0; i < stack.length; i++) {\n              keys.push(stack[i].key);\n            }\n            return keys;\n          },\n          top: function() {\n            return stack[stack.length - 1];\n          },\n          remove: function(key) {\n            var idx = -1;\n            for (var i = 0; i < stack.length; i++) {\n              if (key === stack[i].key) {\n                idx = i;\n                break;\n              }\n            }\n            return stack.splice(idx, 1)[0];\n          },\n          removeTop: function() {\n            return stack.pop();\n          },\n          length: function() {\n            return stack.length;\n          }\n        };\n      }\n    };\n  });\nangular.module('ui.bootstrap.modal', ['ui.bootstrap.multiMap', 'ui.bootstrap.stackedMap', 'ui.bootstrap.position'])\n/**\n * Pluggable resolve mechanism for the modal resolve resolution\n * Supports UI Router's $resolve service\n */\n  .provider('$uibResolve', function() {\n    var resolve = this;\n    this.resolver = null;\n\n    this.setResolver = function(resolver) {\n      this.resolver = resolver;\n    };\n\n    this.$get = ['$injector', '$q', function($injector, $q) {\n      var resolver = resolve.resolver ? $injector.get(resolve.resolver) : null;\n      return {\n        resolve: function(invocables, locals, parent, self) {\n          if (resolver) {\n            return resolver.resolve(invocables, locals, parent, self);\n          }\n\n          var promises = [];\n\n          angular.forEach(invocables, function(value) {\n            if (angular.isFunction(value) || angular.isArray(value)) {\n              promises.push($q.resolve($injector.invoke(value)));\n            } else if (angular.isString(value)) {\n              promises.push($q.resolve($injector.get(value)));\n            } else {\n              promises.push($q.resolve(value));\n            }\n          });\n\n          return $q.all(promises).then(function(resolves) {\n            var resolveObj = {};\n            var resolveIter = 0;\n            angular.forEach(invocables, function(value, key) {\n              resolveObj[key] = resolves[resolveIter++];\n            });\n\n            return resolveObj;\n          });\n        }\n      };\n    }];\n  })\n\n/**\n * A helper directive for the $modal service. It creates a backdrop element.\n */\n  .directive('uibModalBackdrop', ['$animate', '$injector', '$uibModalStack',\n  function($animate, $injector, $modalStack) {\n    return {\n      restrict: 'A',\n      compile: function(tElement, tAttrs) {\n        tElement.addClass(tAttrs.backdropClass);\n        return linkFn;\n      }\n    };\n\n    function linkFn(scope, element, attrs) {\n      if (attrs.modalInClass) {\n        $animate.addClass(element, attrs.modalInClass);\n\n        scope.$on($modalStack.NOW_CLOSING_EVENT, function(e, setIsAsync) {\n          var done = setIsAsync();\n          if (scope.modalOptions.animation) {\n            $animate.removeClass(element, attrs.modalInClass).then(done);\n          } else {\n            done();\n          }\n        });\n      }\n    }\n  }])\n\n  .directive('uibModalWindow', ['$uibModalStack', '$q', '$animateCss', '$document',\n  function($modalStack, $q, $animateCss, $document) {\n    return {\n      scope: {\n        index: '@'\n      },\n      restrict: 'A',\n      transclude: true,\n      templateUrl: function(tElement, tAttrs) {\n        return tAttrs.templateUrl || 'uib/template/modal/window.html';\n      },\n      link: function(scope, element, attrs) {\n        element.addClass(attrs.windowTopClass || '');\n        scope.size = attrs.size;\n\n        scope.close = function(evt) {\n          var modal = $modalStack.getTop();\n          if (modal && modal.value.backdrop &&\n            modal.value.backdrop !== 'static' &&\n            evt.target === evt.currentTarget) {\n            evt.preventDefault();\n            evt.stopPropagation();\n            $modalStack.dismiss(modal.key, 'backdrop click');\n          }\n        };\n\n        // moved from template to fix issue #2280\n        element.on('click', scope.close);\n\n        // This property is only added to the scope for the purpose of detecting when this directive is rendered.\n        // We can detect that by using this property in the template associated with this directive and then use\n        // {@link Attribute#$observe} on it. For more details please see {@link TableColumnResize}.\n        scope.$isRendered = true;\n\n        // Deferred object that will be resolved when this modal is rendered.\n        var modalRenderDeferObj = $q.defer();\n        // Resolve render promise post-digest\n        scope.$$postDigest(function() {\n          modalRenderDeferObj.resolve();\n        });\n\n        modalRenderDeferObj.promise.then(function() {\n          var animationPromise = null;\n\n          if (attrs.modalInClass) {\n            animationPromise = $animateCss(element, {\n              addClass: attrs.modalInClass\n            }).start();\n\n            scope.$on($modalStack.NOW_CLOSING_EVENT, function(e, setIsAsync) {\n              var done = setIsAsync();\n              $animateCss(element, {\n                removeClass: attrs.modalInClass\n              }).start().then(done);\n            });\n          }\n\n\n          $q.when(animationPromise).then(function() {\n            // Notify {@link $modalStack} that modal is rendered.\n            var modal = $modalStack.getTop();\n            if (modal) {\n              $modalStack.modalRendered(modal.key);\n            }\n\n            /**\n             * If something within the freshly-opened modal already has focus (perhaps via a\n             * directive that causes focus) then there's no need to try to focus anything.\n             */\n            if (!($document[0].activeElement && element[0].contains($document[0].activeElement))) {\n              var inputWithAutofocus = element[0].querySelector('[autofocus]');\n              /**\n               * Auto-focusing of a freshly-opened modal element causes any child elements\n               * with the autofocus attribute to lose focus. This is an issue on touch\n               * based devices which will show and then hide the onscreen keyboard.\n               * Attempts to refocus the autofocus element via JavaScript will not reopen\n               * the onscreen keyboard. Fixed by updated the focusing logic to only autofocus\n               * the modal element if the modal does not contain an autofocus element.\n               */\n              if (inputWithAutofocus) {\n                inputWithAutofocus.focus();\n              } else {\n                element[0].focus();\n              }\n            }\n          });\n        });\n      }\n    };\n  }])\n\n  .directive('uibModalAnimationClass', function() {\n    return {\n      compile: function(tElement, tAttrs) {\n        if (tAttrs.modalAnimation) {\n          tElement.addClass(tAttrs.uibModalAnimationClass);\n        }\n      }\n    };\n  })\n\n  .directive('uibModalTransclude', ['$animate', function($animate) {\n    return {\n      link: function(scope, element, attrs, controller, transclude) {\n        transclude(scope.$parent, function(clone) {\n          element.empty();\n          $animate.enter(clone, element);\n        });\n      }\n    };\n  }])\n\n  .factory('$uibModalStack', ['$animate', '$animateCss', '$document',\n    '$compile', '$rootScope', '$q', '$$multiMap', '$$stackedMap', '$uibPosition',\n    function($animate, $animateCss, $document, $compile, $rootScope, $q, $$multiMap, $$stackedMap, $uibPosition) {\n      var OPENED_MODAL_CLASS = 'modal-open';\n\n      var backdropDomEl, backdropScope;\n      var openedWindows = $$stackedMap.createNew();\n      var openedClasses = $$multiMap.createNew();\n      var $modalStack = {\n        NOW_CLOSING_EVENT: 'modal.stack.now-closing'\n      };\n      var topModalIndex = 0;\n      var previousTopOpenedModal = null;\n      var ARIA_HIDDEN_ATTRIBUTE_NAME = 'data-bootstrap-modal-aria-hidden-count';\n\n      //Modal focus behavior\n      var tabbableSelector = 'a[href], area[href], input:not([disabled]):not([tabindex=\\'-1\\']), ' +\n        'button:not([disabled]):not([tabindex=\\'-1\\']),select:not([disabled]):not([tabindex=\\'-1\\']), textarea:not([disabled]):not([tabindex=\\'-1\\']), ' +\n        'iframe, object, embed, *[tabindex]:not([tabindex=\\'-1\\']), *[contenteditable=true]';\n      var scrollbarPadding;\n      var SNAKE_CASE_REGEXP = /[A-Z]/g;\n\n      // TODO: extract into common dependency with tooltip\n      function snake_case(name) {\n        var separator = '-';\n        return name.replace(SNAKE_CASE_REGEXP, function(letter, pos) {\n          return (pos ? separator : '') + letter.toLowerCase();\n        });\n      }\n\n      function isVisible(element) {\n        return !!(element.offsetWidth ||\n          element.offsetHeight ||\n          element.getClientRects().length);\n      }\n\n      function backdropIndex() {\n        var topBackdropIndex = -1;\n        var opened = openedWindows.keys();\n        for (var i = 0; i < opened.length; i++) {\n          if (openedWindows.get(opened[i]).value.backdrop) {\n            topBackdropIndex = i;\n          }\n        }\n\n        // If any backdrop exist, ensure that it's index is always\n        // right below the top modal\n        if (topBackdropIndex > -1 && topBackdropIndex < topModalIndex) {\n          topBackdropIndex = topModalIndex;\n        }\n        return topBackdropIndex;\n      }\n\n      $rootScope.$watch(backdropIndex, function(newBackdropIndex) {\n        if (backdropScope) {\n          backdropScope.index = newBackdropIndex;\n        }\n      });\n\n      function removeModalWindow(modalInstance, elementToReceiveFocus) {\n        var modalWindow = openedWindows.get(modalInstance).value;\n        var appendToElement = modalWindow.appendTo;\n\n        //clean up the stack\n        openedWindows.remove(modalInstance);\n        previousTopOpenedModal = openedWindows.top();\n        if (previousTopOpenedModal) {\n          topModalIndex = parseInt(previousTopOpenedModal.value.modalDomEl.attr('index'), 10);\n        }\n\n        removeAfterAnimate(modalWindow.modalDomEl, modalWindow.modalScope, function() {\n          var modalBodyClass = modalWindow.openedClass || OPENED_MODAL_CLASS;\n          openedClasses.remove(modalBodyClass, modalInstance);\n          var areAnyOpen = openedClasses.hasKey(modalBodyClass);\n          appendToElement.toggleClass(modalBodyClass, areAnyOpen);\n          if (!areAnyOpen && scrollbarPadding && scrollbarPadding.heightOverflow && scrollbarPadding.scrollbarWidth) {\n            if (scrollbarPadding.originalRight) {\n              appendToElement.css({paddingRight: scrollbarPadding.originalRight + 'px'});\n            } else {\n              appendToElement.css({paddingRight: ''});\n            }\n            scrollbarPadding = null;\n          }\n          toggleTopWindowClass(true);\n        }, modalWindow.closedDeferred);\n        checkRemoveBackdrop();\n\n        //move focus to specified element if available, or else to body\n        if (elementToReceiveFocus && elementToReceiveFocus.focus) {\n          elementToReceiveFocus.focus();\n        } else if (appendToElement.focus) {\n          appendToElement.focus();\n        }\n      }\n\n      // Add or remove \"windowTopClass\" from the top window in the stack\n      function toggleTopWindowClass(toggleSwitch) {\n        var modalWindow;\n\n        if (openedWindows.length() > 0) {\n          modalWindow = openedWindows.top().value;\n          modalWindow.modalDomEl.toggleClass(modalWindow.windowTopClass || '', toggleSwitch);\n        }\n      }\n\n      function checkRemoveBackdrop() {\n        //remove backdrop if no longer needed\n        if (backdropDomEl && backdropIndex() === -1) {\n          var backdropScopeRef = backdropScope;\n          removeAfterAnimate(backdropDomEl, backdropScope, function() {\n            backdropScopeRef = null;\n          });\n          backdropDomEl = undefined;\n          backdropScope = undefined;\n        }\n      }\n\n      function removeAfterAnimate(domEl, scope, done, closedDeferred) {\n        var asyncDeferred;\n        var asyncPromise = null;\n        var setIsAsync = function() {\n          if (!asyncDeferred) {\n            asyncDeferred = $q.defer();\n            asyncPromise = asyncDeferred.promise;\n          }\n\n          return function asyncDone() {\n            asyncDeferred.resolve();\n          };\n        };\n        scope.$broadcast($modalStack.NOW_CLOSING_EVENT, setIsAsync);\n\n        // Note that it's intentional that asyncPromise might be null.\n        // That's when setIsAsync has not been called during the\n        // NOW_CLOSING_EVENT broadcast.\n        return $q.when(asyncPromise).then(afterAnimating);\n\n        function afterAnimating() {\n          if (afterAnimating.done) {\n            return;\n          }\n          afterAnimating.done = true;\n\n          $animate.leave(domEl).then(function() {\n            if (done) {\n              done();\n            }\n\n            domEl.remove();\n            if (closedDeferred) {\n              closedDeferred.resolve();\n            }\n          });\n\n          scope.$destroy();\n        }\n      }\n\n      $document.on('keydown', keydownListener);\n\n      $rootScope.$on('$destroy', function() {\n        $document.off('keydown', keydownListener);\n      });\n\n      function keydownListener(evt) {\n        if (evt.isDefaultPrevented()) {\n          return evt;\n        }\n\n        var modal = openedWindows.top();\n        if (modal) {\n          switch (evt.which) {\n            case 27: {\n              if (modal.value.keyboard) {\n                evt.preventDefault();\n                $rootScope.$apply(function() {\n                  $modalStack.dismiss(modal.key, 'escape key press');\n                });\n              }\n              break;\n            }\n            case 9: {\n              var list = $modalStack.loadFocusElementList(modal);\n              var focusChanged = false;\n              if (evt.shiftKey) {\n                if ($modalStack.isFocusInFirstItem(evt, list) || $modalStack.isModalFocused(evt, modal)) {\n                  focusChanged = $modalStack.focusLastFocusableElement(list);\n                }\n              } else {\n                if ($modalStack.isFocusInLastItem(evt, list)) {\n                  focusChanged = $modalStack.focusFirstFocusableElement(list);\n                }\n              }\n\n              if (focusChanged) {\n                evt.preventDefault();\n                evt.stopPropagation();\n              }\n\n              break;\n            }\n          }\n        }\n      }\n\n      $modalStack.open = function(modalInstance, modal) {\n        var modalOpener = $document[0].activeElement,\n          modalBodyClass = modal.openedClass || OPENED_MODAL_CLASS;\n\n        toggleTopWindowClass(false);\n\n        // Store the current top first, to determine what index we ought to use\n        // for the current top modal\n        previousTopOpenedModal = openedWindows.top();\n\n        openedWindows.add(modalInstance, {\n          deferred: modal.deferred,\n          renderDeferred: modal.renderDeferred,\n          closedDeferred: modal.closedDeferred,\n          modalScope: modal.scope,\n          backdrop: modal.backdrop,\n          keyboard: modal.keyboard,\n          openedClass: modal.openedClass,\n          windowTopClass: modal.windowTopClass,\n          animation: modal.animation,\n          appendTo: modal.appendTo\n        });\n\n        openedClasses.put(modalBodyClass, modalInstance);\n\n        var appendToElement = modal.appendTo,\n            currBackdropIndex = backdropIndex();\n\n        if (currBackdropIndex >= 0 && !backdropDomEl) {\n          backdropScope = $rootScope.$new(true);\n          backdropScope.modalOptions = modal;\n          backdropScope.index = currBackdropIndex;\n          backdropDomEl = angular.element('<div uib-modal-backdrop=\"modal-backdrop\"></div>');\n          backdropDomEl.attr({\n            'class': 'modal-backdrop',\n            'ng-style': '{\\'z-index\\': 1040 + (index && 1 || 0) + index*10}',\n            'uib-modal-animation-class': 'fade',\n            'modal-in-class': 'in'\n          });\n          if (modal.backdropClass) {\n            backdropDomEl.addClass(modal.backdropClass);\n          }\n\n          if (modal.animation) {\n            backdropDomEl.attr('modal-animation', 'true');\n          }\n          $compile(backdropDomEl)(backdropScope);\n          $animate.enter(backdropDomEl, appendToElement);\n          if ($uibPosition.isScrollable(appendToElement)) {\n            scrollbarPadding = $uibPosition.scrollbarPadding(appendToElement);\n            if (scrollbarPadding.heightOverflow && scrollbarPadding.scrollbarWidth) {\n              appendToElement.css({paddingRight: scrollbarPadding.right + 'px'});\n            }\n          }\n        }\n\n        var content;\n        if (modal.component) {\n          content = document.createElement(snake_case(modal.component.name));\n          content = angular.element(content);\n          content.attr({\n            resolve: '$resolve',\n            'modal-instance': '$uibModalInstance',\n            close: '$close($value)',\n            dismiss: '$dismiss($value)'\n          });\n        } else {\n          content = modal.content;\n        }\n\n        // Set the top modal index based on the index of the previous top modal\n        topModalIndex = previousTopOpenedModal ? parseInt(previousTopOpenedModal.value.modalDomEl.attr('index'), 10) + 1 : 0;\n        var angularDomEl = angular.element('<div uib-modal-window=\"modal-window\"></div>');\n        angularDomEl.attr({\n          'class': 'modal',\n          'template-url': modal.windowTemplateUrl,\n          'window-top-class': modal.windowTopClass,\n          'role': 'dialog',\n          'aria-labelledby': modal.ariaLabelledBy,\n          'aria-describedby': modal.ariaDescribedBy,\n          'size': modal.size,\n          'index': topModalIndex,\n          'animate': 'animate',\n          'ng-style': '{\\'z-index\\': 1050 + $$topModalIndex*10, display: \\'block\\'}',\n          'tabindex': -1,\n          'uib-modal-animation-class': 'fade',\n          'modal-in-class': 'in'\n        }).append(content);\n        if (modal.windowClass) {\n          angularDomEl.addClass(modal.windowClass);\n        }\n\n        if (modal.animation) {\n          angularDomEl.attr('modal-animation', 'true');\n        }\n\n        appendToElement.addClass(modalBodyClass);\n        if (modal.scope) {\n          // we need to explicitly add the modal index to the modal scope\n          // because it is needed by ngStyle to compute the zIndex property.\n          modal.scope.$$topModalIndex = topModalIndex;\n        }\n        $animate.enter($compile(angularDomEl)(modal.scope), appendToElement);\n\n        openedWindows.top().value.modalDomEl = angularDomEl;\n        openedWindows.top().value.modalOpener = modalOpener;\n\n        applyAriaHidden(angularDomEl);\n\n        function applyAriaHidden(el) {\n          if (!el || el[0].tagName === 'BODY') {\n            return;\n          }\n\n          getSiblings(el).forEach(function(sibling) {\n            var elemIsAlreadyHidden = sibling.getAttribute('aria-hidden') === 'true',\n              ariaHiddenCount = parseInt(sibling.getAttribute(ARIA_HIDDEN_ATTRIBUTE_NAME), 10);\n\n            if (!ariaHiddenCount) {\n              ariaHiddenCount = elemIsAlreadyHidden ? 1 : 0;\n            }\n\n            sibling.setAttribute(ARIA_HIDDEN_ATTRIBUTE_NAME, ariaHiddenCount + 1);\n            sibling.setAttribute('aria-hidden', 'true');\n          });\n\n          return applyAriaHidden(el.parent());\n\n          function getSiblings(el) {\n            var children = el.parent() ? el.parent().children() : [];\n\n            return Array.prototype.filter.call(children, function(child) {\n              return child !== el[0];\n            });\n          }\n        }\n      };\n\n      function broadcastClosing(modalWindow, resultOrReason, closing) {\n        return !modalWindow.value.modalScope.$broadcast('modal.closing', resultOrReason, closing).defaultPrevented;\n      }\n\n      function unhideBackgroundElements() {\n        Array.prototype.forEach.call(\n          document.querySelectorAll('[' + ARIA_HIDDEN_ATTRIBUTE_NAME + ']'),\n          function(hiddenEl) {\n            var ariaHiddenCount = parseInt(hiddenEl.getAttribute(ARIA_HIDDEN_ATTRIBUTE_NAME), 10),\n              newHiddenCount = ariaHiddenCount - 1;\n            hiddenEl.setAttribute(ARIA_HIDDEN_ATTRIBUTE_NAME, newHiddenCount);\n\n            if (!newHiddenCount) {\n              hiddenEl.removeAttribute(ARIA_HIDDEN_ATTRIBUTE_NAME);\n              hiddenEl.removeAttribute('aria-hidden');\n            }\n          }\n        );\n      }\n\n      $modalStack.close = function(modalInstance, result) {\n        var modalWindow = openedWindows.get(modalInstance);\n        unhideBackgroundElements();\n        if (modalWindow && broadcastClosing(modalWindow, result, true)) {\n          modalWindow.value.modalScope.$$uibDestructionScheduled = true;\n          modalWindow.value.deferred.resolve(result);\n          removeModalWindow(modalInstance, modalWindow.value.modalOpener);\n          return true;\n        }\n\n        return !modalWindow;\n      };\n\n      $modalStack.dismiss = function(modalInstance, reason) {\n        var modalWindow = openedWindows.get(modalInstance);\n        unhideBackgroundElements();\n        if (modalWindow && broadcastClosing(modalWindow, reason, false)) {\n          modalWindow.value.modalScope.$$uibDestructionScheduled = true;\n          modalWindow.value.deferred.reject(reason);\n          removeModalWindow(modalInstance, modalWindow.value.modalOpener);\n          return true;\n        }\n        return !modalWindow;\n      };\n\n      $modalStack.dismissAll = function(reason) {\n        var topModal = this.getTop();\n        while (topModal && this.dismiss(topModal.key, reason)) {\n          topModal = this.getTop();\n        }\n      };\n\n      $modalStack.getTop = function() {\n        return openedWindows.top();\n      };\n\n      $modalStack.modalRendered = function(modalInstance) {\n        var modalWindow = openedWindows.get(modalInstance);\n        if (modalWindow) {\n          modalWindow.value.renderDeferred.resolve();\n        }\n      };\n\n      $modalStack.focusFirstFocusableElement = function(list) {\n        if (list.length > 0) {\n          list[0].focus();\n          return true;\n        }\n        return false;\n      };\n\n      $modalStack.focusLastFocusableElement = function(list) {\n        if (list.length > 0) {\n          list[list.length - 1].focus();\n          return true;\n        }\n        return false;\n      };\n\n      $modalStack.isModalFocused = function(evt, modalWindow) {\n        if (evt && modalWindow) {\n          var modalDomEl = modalWindow.value.modalDomEl;\n          if (modalDomEl && modalDomEl.length) {\n            return (evt.target || evt.srcElement) === modalDomEl[0];\n          }\n        }\n        return false;\n      };\n\n      $modalStack.isFocusInFirstItem = function(evt, list) {\n        if (list.length > 0) {\n          return (evt.target || evt.srcElement) === list[0];\n        }\n        return false;\n      };\n\n      $modalStack.isFocusInLastItem = function(evt, list) {\n        if (list.length > 0) {\n          return (evt.target || evt.srcElement) === list[list.length - 1];\n        }\n        return false;\n      };\n\n      $modalStack.loadFocusElementList = function(modalWindow) {\n        if (modalWindow) {\n          var modalDomE1 = modalWindow.value.modalDomEl;\n          if (modalDomE1 && modalDomE1.length) {\n            var elements = modalDomE1[0].querySelectorAll(tabbableSelector);\n            return elements ?\n              Array.prototype.filter.call(elements, function(element) {\n                return isVisible(element);\n              }) : elements;\n          }\n        }\n      };\n\n      return $modalStack;\n    }])\n\n  .provider('$uibModal', function() {\n    var $modalProvider = {\n      options: {\n        animation: true,\n        backdrop: true, //can also be false or 'static'\n        keyboard: true\n      },\n      $get: ['$rootScope', '$q', '$document', '$templateRequest', '$controller', '$uibResolve', '$uibModalStack',\n        function ($rootScope, $q, $document, $templateRequest, $controller, $uibResolve, $modalStack) {\n          var $modal = {};\n\n          function getTemplatePromise(options) {\n            return options.template ? $q.when(options.template) :\n              $templateRequest(angular.isFunction(options.templateUrl) ?\n                options.templateUrl() : options.templateUrl);\n          }\n\n          var promiseChain = null;\n          $modal.getPromiseChain = function() {\n            return promiseChain;\n          };\n\n          $modal.open = function(modalOptions) {\n            var modalResultDeferred = $q.defer();\n            var modalOpenedDeferred = $q.defer();\n            var modalClosedDeferred = $q.defer();\n            var modalRenderDeferred = $q.defer();\n\n            //prepare an instance of a modal to be injected into controllers and returned to a caller\n            var modalInstance = {\n              result: modalResultDeferred.promise,\n              opened: modalOpenedDeferred.promise,\n              closed: modalClosedDeferred.promise,\n              rendered: modalRenderDeferred.promise,\n              close: function (result) {\n                return $modalStack.close(modalInstance, result);\n              },\n              dismiss: function (reason) {\n                return $modalStack.dismiss(modalInstance, reason);\n              }\n            };\n\n            //merge and clean up options\n            modalOptions = angular.extend({}, $modalProvider.options, modalOptions);\n            modalOptions.resolve = modalOptions.resolve || {};\n            modalOptions.appendTo = modalOptions.appendTo || $document.find('body').eq(0);\n\n            if (!modalOptions.appendTo.length) {\n              throw new Error('appendTo element not found. Make sure that the element passed is in DOM.');\n            }\n\n            //verify options\n            if (!modalOptions.component && !modalOptions.template && !modalOptions.templateUrl) {\n              throw new Error('One of component or template or templateUrl options is required.');\n            }\n\n            var templateAndResolvePromise;\n            if (modalOptions.component) {\n              templateAndResolvePromise = $q.when($uibResolve.resolve(modalOptions.resolve, {}, null, null));\n            } else {\n              templateAndResolvePromise =\n                $q.all([getTemplatePromise(modalOptions), $uibResolve.resolve(modalOptions.resolve, {}, null, null)]);\n            }\n\n            function resolveWithTemplate() {\n              return templateAndResolvePromise;\n            }\n\n            // Wait for the resolution of the existing promise chain.\n            // Then switch to our own combined promise dependency (regardless of how the previous modal fared).\n            // Then add to $modalStack and resolve opened.\n            // Finally clean up the chain variable if no subsequent modal has overwritten it.\n            var samePromise;\n            samePromise = promiseChain = $q.all([promiseChain])\n              .then(resolveWithTemplate, resolveWithTemplate)\n              .then(function resolveSuccess(tplAndVars) {\n                var providedScope = modalOptions.scope || $rootScope;\n\n                var modalScope = providedScope.$new();\n                modalScope.$close = modalInstance.close;\n                modalScope.$dismiss = modalInstance.dismiss;\n\n                modalScope.$on('$destroy', function() {\n                  if (!modalScope.$$uibDestructionScheduled) {\n                    modalScope.$dismiss('$uibUnscheduledDestruction');\n                  }\n                });\n\n                var modal = {\n                  scope: modalScope,\n                  deferred: modalResultDeferred,\n                  renderDeferred: modalRenderDeferred,\n                  closedDeferred: modalClosedDeferred,\n                  animation: modalOptions.animation,\n                  backdrop: modalOptions.backdrop,\n                  keyboard: modalOptions.keyboard,\n                  backdropClass: modalOptions.backdropClass,\n                  windowTopClass: modalOptions.windowTopClass,\n                  windowClass: modalOptions.windowClass,\n                  windowTemplateUrl: modalOptions.windowTemplateUrl,\n                  ariaLabelledBy: modalOptions.ariaLabelledBy,\n                  ariaDescribedBy: modalOptions.ariaDescribedBy,\n                  size: modalOptions.size,\n                  openedClass: modalOptions.openedClass,\n                  appendTo: modalOptions.appendTo\n                };\n\n                var component = {};\n                var ctrlInstance, ctrlInstantiate, ctrlLocals = {};\n\n                if (modalOptions.component) {\n                  constructLocals(component, false, true, false);\n                  component.name = modalOptions.component;\n                  modal.component = component;\n                } else if (modalOptions.controller) {\n                  constructLocals(ctrlLocals, true, false, true);\n\n                  // the third param will make the controller instantiate later,private api\n                  // @see https://github.com/angular/angular.js/blob/master/src/ng/controller.js#L126\n                  ctrlInstantiate = $controller(modalOptions.controller, ctrlLocals, true, modalOptions.controllerAs);\n                  if (modalOptions.controllerAs && modalOptions.bindToController) {\n                    ctrlInstance = ctrlInstantiate.instance;\n                    ctrlInstance.$close = modalScope.$close;\n                    ctrlInstance.$dismiss = modalScope.$dismiss;\n                    angular.extend(ctrlInstance, {\n                      $resolve: ctrlLocals.$scope.$resolve\n                    }, providedScope);\n                  }\n\n                  ctrlInstance = ctrlInstantiate();\n\n                  if (angular.isFunction(ctrlInstance.$onInit)) {\n                    ctrlInstance.$onInit();\n                  }\n                }\n\n                if (!modalOptions.component) {\n                  modal.content = tplAndVars[0];\n                }\n\n                $modalStack.open(modalInstance, modal);\n                modalOpenedDeferred.resolve(true);\n\n                function constructLocals(obj, template, instanceOnScope, injectable) {\n                  obj.$scope = modalScope;\n                  obj.$scope.$resolve = {};\n                  if (instanceOnScope) {\n                    obj.$scope.$uibModalInstance = modalInstance;\n                  } else {\n                    obj.$uibModalInstance = modalInstance;\n                  }\n\n                  var resolves = template ? tplAndVars[1] : tplAndVars;\n                  angular.forEach(resolves, function(value, key) {\n                    if (injectable) {\n                      obj[key] = value;\n                    }\n\n                    obj.$scope.$resolve[key] = value;\n                  });\n                }\n            }, function resolveError(reason) {\n              modalOpenedDeferred.reject(reason);\n              modalResultDeferred.reject(reason);\n            })['finally'](function() {\n              if (promiseChain === samePromise) {\n                promiseChain = null;\n              }\n            });\n\n            return modalInstance;\n          };\n\n          return $modal;\n        }\n      ]\n    };\n\n    return $modalProvider;\n  });\n\nangular.module('ui.bootstrap.paging', [])\n/**\n * Helper internal service for generating common controller code between the\n * pager and pagination components\n */\n.factory('uibPaging', ['$parse', function($parse) {\n  return {\n    create: function(ctrl, $scope, $attrs) {\n      ctrl.setNumPages = $attrs.numPages ? $parse($attrs.numPages).assign : angular.noop;\n      ctrl.ngModelCtrl = { $setViewValue: angular.noop }; // nullModelCtrl\n      ctrl._watchers = [];\n\n      ctrl.init = function(ngModelCtrl, config) {\n        ctrl.ngModelCtrl = ngModelCtrl;\n        ctrl.config = config;\n\n        ngModelCtrl.$render = function() {\n          ctrl.render();\n        };\n\n        if ($attrs.itemsPerPage) {\n          ctrl._watchers.push($scope.$parent.$watch($attrs.itemsPerPage, function(value) {\n            ctrl.itemsPerPage = parseInt(value, 10);\n            $scope.totalPages = ctrl.calculateTotalPages();\n            ctrl.updatePage();\n          }));\n        } else {\n          ctrl.itemsPerPage = config.itemsPerPage;\n        }\n\n        $scope.$watch('totalItems', function(newTotal, oldTotal) {\n          if (angular.isDefined(newTotal) || newTotal !== oldTotal) {\n            $scope.totalPages = ctrl.calculateTotalPages();\n            ctrl.updatePage();\n          }\n        });\n      };\n\n      ctrl.calculateTotalPages = function() {\n        var totalPages = ctrl.itemsPerPage < 1 ? 1 : Math.ceil($scope.totalItems / ctrl.itemsPerPage);\n        return Math.max(totalPages || 0, 1);\n      };\n\n      ctrl.render = function() {\n        $scope.page = parseInt(ctrl.ngModelCtrl.$viewValue, 10) || 1;\n      };\n\n      $scope.selectPage = function(page, evt) {\n        if (evt) {\n          evt.preventDefault();\n        }\n\n        var clickAllowed = !$scope.ngDisabled || !evt;\n        if (clickAllowed && $scope.page !== page && page > 0 && page <= $scope.totalPages) {\n          if (evt && evt.target) {\n            evt.target.blur();\n          }\n          ctrl.ngModelCtrl.$setViewValue(page);\n          ctrl.ngModelCtrl.$render();\n        }\n      };\n\n      $scope.getText = function(key) {\n        return $scope[key + 'Text'] || ctrl.config[key + 'Text'];\n      };\n\n      $scope.noPrevious = function() {\n        return $scope.page === 1;\n      };\n\n      $scope.noNext = function() {\n        return $scope.page === $scope.totalPages;\n      };\n\n      ctrl.updatePage = function() {\n        ctrl.setNumPages($scope.$parent, $scope.totalPages); // Readonly variable\n\n        if ($scope.page > $scope.totalPages) {\n          $scope.selectPage($scope.totalPages);\n        } else {\n          ctrl.ngModelCtrl.$render();\n        }\n      };\n\n      $scope.$on('$destroy', function() {\n        while (ctrl._watchers.length) {\n          ctrl._watchers.shift()();\n        }\n      });\n    }\n  };\n}]);\n\nangular.module('ui.bootstrap.pager', ['ui.bootstrap.paging', 'ui.bootstrap.tabindex'])\n\n.controller('UibPagerController', ['$scope', '$attrs', 'uibPaging', 'uibPagerConfig', function($scope, $attrs, uibPaging, uibPagerConfig) {\n  $scope.align = angular.isDefined($attrs.align) ? $scope.$parent.$eval($attrs.align) : uibPagerConfig.align;\n\n  uibPaging.create(this, $scope, $attrs);\n}])\n\n.constant('uibPagerConfig', {\n  itemsPerPage: 10,\n  previousText: ' Previous',\n  nextText: 'Next ',\n  align: true\n})\n\n.directive('uibPager', ['uibPagerConfig', function(uibPagerConfig) {\n  return {\n    scope: {\n      totalItems: '=',\n      previousText: '@',\n      nextText: '@',\n      ngDisabled: '='\n    },\n    require: ['uibPager', '?ngModel'],\n    restrict: 'A',\n    controller: 'UibPagerController',\n    controllerAs: 'pager',\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'uib/template/pager/pager.html';\n    },\n    link: function(scope, element, attrs, ctrls) {\n      element.addClass('pager');\n      var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\n      if (!ngModelCtrl) {\n        return; // do nothing if no ng-model\n      }\n\n      paginationCtrl.init(ngModelCtrl, uibPagerConfig);\n    }\n  };\n}]);\n\nangular.module('ui.bootstrap.pagination', ['ui.bootstrap.paging', 'ui.bootstrap.tabindex'])\n.controller('UibPaginationController', ['$scope', '$attrs', '$parse', 'uibPaging', 'uibPaginationConfig', function($scope, $attrs, $parse, uibPaging, uibPaginationConfig) {\n  var ctrl = this;\n  // Setup configuration parameters\n  var maxSize = angular.isDefined($attrs.maxSize) ? $scope.$parent.$eval($attrs.maxSize) : uibPaginationConfig.maxSize,\n    rotate = angular.isDefined($attrs.rotate) ? $scope.$parent.$eval($attrs.rotate) : uibPaginationConfig.rotate,\n    forceEllipses = angular.isDefined($attrs.forceEllipses) ? $scope.$parent.$eval($attrs.forceEllipses) : uibPaginationConfig.forceEllipses,\n    boundaryLinkNumbers = angular.isDefined($attrs.boundaryLinkNumbers) ? $scope.$parent.$eval($attrs.boundaryLinkNumbers) : uibPaginationConfig.boundaryLinkNumbers,\n    pageLabel = angular.isDefined($attrs.pageLabel) ? function(idx) { return $scope.$parent.$eval($attrs.pageLabel, {$page: idx}); } : angular.identity;\n  $scope.boundaryLinks = angular.isDefined($attrs.boundaryLinks) ? $scope.$parent.$eval($attrs.boundaryLinks) : uibPaginationConfig.boundaryLinks;\n  $scope.directionLinks = angular.isDefined($attrs.directionLinks) ? $scope.$parent.$eval($attrs.directionLinks) : uibPaginationConfig.directionLinks;\n  $attrs.$set('role', 'menu');\n\n  uibPaging.create(this, $scope, $attrs);\n\n  if ($attrs.maxSize) {\n    ctrl._watchers.push($scope.$parent.$watch($parse($attrs.maxSize), function(value) {\n      maxSize = parseInt(value, 10);\n      ctrl.render();\n    }));\n  }\n\n  // Create page object used in template\n  function makePage(number, text, isActive) {\n    return {\n      number: number,\n      text: text,\n      active: isActive\n    };\n  }\n\n  function getPages(currentPage, totalPages) {\n    var pages = [];\n\n    // Default page limits\n    var startPage = 1, endPage = totalPages;\n    var isMaxSized = angular.isDefined(maxSize) && maxSize < totalPages;\n\n    // recompute if maxSize\n    if (isMaxSized) {\n      if (rotate) {\n        // Current page is displayed in the middle of the visible ones\n        startPage = Math.max(currentPage - Math.floor(maxSize / 2), 1);\n        endPage = startPage + maxSize - 1;\n\n        // Adjust if limit is exceeded\n        if (endPage > totalPages) {\n          endPage = totalPages;\n          startPage = endPage - maxSize + 1;\n        }\n      } else {\n        // Visible pages are paginated with maxSize\n        startPage = (Math.ceil(currentPage / maxSize) - 1) * maxSize + 1;\n\n        // Adjust last page if limit is exceeded\n        endPage = Math.min(startPage + maxSize - 1, totalPages);\n      }\n    }\n\n    // Add page number links\n    for (var number = startPage; number <= endPage; number++) {\n      var page = makePage(number, pageLabel(number), number === currentPage);\n      pages.push(page);\n    }\n\n    // Add links to move between page sets\n    if (isMaxSized && maxSize > 0 && (!rotate || forceEllipses || boundaryLinkNumbers)) {\n      if (startPage > 1) {\n        if (!boundaryLinkNumbers || startPage > 3) { //need ellipsis for all options unless range is too close to beginning\n        var previousPageSet = makePage(startPage - 1, '...', false);\n        pages.unshift(previousPageSet);\n      }\n        if (boundaryLinkNumbers) {\n          if (startPage === 3) { //need to replace ellipsis when the buttons would be sequential\n            var secondPageLink = makePage(2, '2', false);\n            pages.unshift(secondPageLink);\n          }\n          //add the first page\n          var firstPageLink = makePage(1, '1', false);\n          pages.unshift(firstPageLink);\n        }\n      }\n\n      if (endPage < totalPages) {\n        if (!boundaryLinkNumbers || endPage < totalPages - 2) { //need ellipsis for all options unless range is too close to end\n        var nextPageSet = makePage(endPage + 1, '...', false);\n        pages.push(nextPageSet);\n      }\n        if (boundaryLinkNumbers) {\n          if (endPage === totalPages - 2) { //need to replace ellipsis when the buttons would be sequential\n            var secondToLastPageLink = makePage(totalPages - 1, totalPages - 1, false);\n            pages.push(secondToLastPageLink);\n          }\n          //add the last page\n          var lastPageLink = makePage(totalPages, totalPages, false);\n          pages.push(lastPageLink);\n        }\n      }\n    }\n    return pages;\n  }\n\n  var originalRender = this.render;\n  this.render = function() {\n    originalRender();\n    if ($scope.page > 0 && $scope.page <= $scope.totalPages) {\n      $scope.pages = getPages($scope.page, $scope.totalPages);\n    }\n  };\n}])\n\n.constant('uibPaginationConfig', {\n  itemsPerPage: 10,\n  boundaryLinks: false,\n  boundaryLinkNumbers: false,\n  directionLinks: true,\n  firstText: 'First',\n  previousText: 'Previous',\n  nextText: 'Next',\n  lastText: 'Last',\n  rotate: true,\n  forceEllipses: false\n})\n\n.directive('uibPagination', ['$parse', 'uibPaginationConfig', function($parse, uibPaginationConfig) {\n  return {\n    scope: {\n      totalItems: '=',\n      firstText: '@',\n      previousText: '@',\n      nextText: '@',\n      lastText: '@',\n      ngDisabled:'='\n    },\n    require: ['uibPagination', '?ngModel'],\n    restrict: 'A',\n    controller: 'UibPaginationController',\n    controllerAs: 'pagination',\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'uib/template/pagination/pagination.html';\n    },\n    link: function(scope, element, attrs, ctrls) {\n      element.addClass('pagination');\n      var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\n      if (!ngModelCtrl) {\n         return; // do nothing if no ng-model\n      }\n\n      paginationCtrl.init(ngModelCtrl, uibPaginationConfig);\n    }\n  };\n}]);\n\n/**\n * The following features are still outstanding: animation as a\n * function, placement as a function, inside, support for more triggers than\n * just mouse enter/leave, html tooltips, and selector delegation.\n */\nangular.module('ui.bootstrap.tooltip', ['ui.bootstrap.position', 'ui.bootstrap.stackedMap'])\n\n/**\n * The $tooltip service creates tooltip- and popover-like directives as well as\n * houses global options for them.\n */\n.provider('$uibTooltip', function() {\n  // The default options tooltip and popover.\n  var defaultOptions = {\n    placement: 'top',\n    placementClassPrefix: '',\n    animation: true,\n    popupDelay: 0,\n    popupCloseDelay: 0,\n    useContentExp: false\n  };\n\n  // Default hide triggers for each show trigger\n  var triggerMap = {\n    'mouseenter': 'mouseleave',\n    'click': 'click',\n    'outsideClick': 'outsideClick',\n    'focus': 'blur',\n    'none': ''\n  };\n\n  // The options specified to the provider globally.\n  var globalOptions = {};\n\n  /**\n   * `options({})` allows global configuration of all tooltips in the\n   * application.\n   *\n   *   var app = angular.module( 'App', ['ui.bootstrap.tooltip'], function( $tooltipProvider ) {\n   *     // place tooltips left instead of top by default\n   *     $tooltipProvider.options( { placement: 'left' } );\n   *   });\n   */\n\tthis.options = function(value) {\n\t\tangular.extend(globalOptions, value);\n\t};\n\n  /**\n   * This allows you to extend the set of trigger mappings available. E.g.:\n   *\n   *   $tooltipProvider.setTriggers( { 'openTrigger': 'closeTrigger' } );\n   */\n  this.setTriggers = function setTriggers(triggers) {\n    angular.extend(triggerMap, triggers);\n  };\n\n  /**\n   * This is a helper function for translating camel-case to snake_case.\n   */\n  function snake_case(name) {\n    var regexp = /[A-Z]/g;\n    var separator = '-';\n    return name.replace(regexp, function(letter, pos) {\n      return (pos ? separator : '') + letter.toLowerCase();\n    });\n  }\n\n  /**\n   * Returns the actual instance of the $tooltip service.\n   * TODO support multiple triggers\n   */\n  this.$get = ['$window', '$compile', '$timeout', '$document', '$uibPosition', '$interpolate', '$rootScope', '$parse', '$$stackedMap', function($window, $compile, $timeout, $document, $position, $interpolate, $rootScope, $parse, $$stackedMap) {\n    var openedTooltips = $$stackedMap.createNew();\n    $document.on('keyup', keypressListener);\n\n    $rootScope.$on('$destroy', function() {\n      $document.off('keyup', keypressListener);\n    });\n\n    function keypressListener(e) {\n      if (e.which === 27) {\n        var last = openedTooltips.top();\n        if (last) {\n          last.value.close();\n          last = null;\n        }\n      }\n    }\n\n    return function $tooltip(ttType, prefix, defaultTriggerShow, options) {\n      options = angular.extend({}, defaultOptions, globalOptions, options);\n\n      /**\n       * Returns an object of show and hide triggers.\n       *\n       * If a trigger is supplied,\n       * it is used to show the tooltip; otherwise, it will use the `trigger`\n       * option passed to the `$tooltipProvider.options` method; else it will\n       * default to the trigger supplied to this directive factory.\n       *\n       * The hide trigger is based on the show trigger. If the `trigger` option\n       * was passed to the `$tooltipProvider.options` method, it will use the\n       * mapped trigger from `triggerMap` or the passed trigger if the map is\n       * undefined; otherwise, it uses the `triggerMap` value of the show\n       * trigger; else it will just use the show trigger.\n       */\n      function getTriggers(trigger) {\n        var show = (trigger || options.trigger || defaultTriggerShow).split(' ');\n        var hide = show.map(function(trigger) {\n          return triggerMap[trigger] || trigger;\n        });\n        return {\n          show: show,\n          hide: hide\n        };\n      }\n\n      var directiveName = snake_case(ttType);\n\n      var startSym = $interpolate.startSymbol();\n      var endSym = $interpolate.endSymbol();\n      var template =\n        '<div '+ directiveName + '-popup ' +\n          'uib-title=\"' + startSym + 'title' + endSym + '\" ' +\n          (options.useContentExp ?\n            'content-exp=\"contentExp()\" ' :\n            'content=\"' + startSym + 'content' + endSym + '\" ') +\n          'origin-scope=\"origScope\" ' +\n          'class=\"uib-position-measure ' + prefix + '\" ' +\n          'tooltip-animation-class=\"fade\"' +\n          'uib-tooltip-classes ' +\n          'ng-class=\"{ in: isOpen }\" ' +\n          '>' +\n        '</div>';\n\n      return {\n        compile: function(tElem, tAttrs) {\n          var tooltipLinker = $compile(template);\n\n          return function link(scope, element, attrs, tooltipCtrl) {\n            var tooltip;\n            var tooltipLinkedScope;\n            var transitionTimeout;\n            var showTimeout;\n            var hideTimeout;\n            var positionTimeout;\n            var adjustmentTimeout;\n            var appendToBody = angular.isDefined(options.appendToBody) ? options.appendToBody : false;\n            var triggers = getTriggers(undefined);\n            var hasEnableExp = angular.isDefined(attrs[prefix + 'Enable']);\n            var ttScope = scope.$new(true);\n            var repositionScheduled = false;\n            var isOpenParse = angular.isDefined(attrs[prefix + 'IsOpen']) ? $parse(attrs[prefix + 'IsOpen']) : false;\n            var contentParse = options.useContentExp ? $parse(attrs[ttType]) : false;\n            var observers = [];\n            var lastPlacement;\n\n            var positionTooltip = function() {\n              // check if tooltip exists and is not empty\n              if (!tooltip || !tooltip.html()) { return; }\n\n              if (!positionTimeout) {\n                positionTimeout = $timeout(function() {\n                  var ttPosition = $position.positionElements(element, tooltip, ttScope.placement, appendToBody);\n                  var initialHeight = angular.isDefined(tooltip.offsetHeight) ? tooltip.offsetHeight : tooltip.prop('offsetHeight');\n                  var elementPos = appendToBody ? $position.offset(element) : $position.position(element);\n                  tooltip.css({ top: ttPosition.top + 'px', left: ttPosition.left + 'px' });\n                  var placementClasses = ttPosition.placement.split('-');\n\n                  if (!tooltip.hasClass(placementClasses[0])) {\n                    tooltip.removeClass(lastPlacement.split('-')[0]);\n                    tooltip.addClass(placementClasses[0]);\n                  }\n\n                  if (!tooltip.hasClass(options.placementClassPrefix + ttPosition.placement)) {\n                    tooltip.removeClass(options.placementClassPrefix + lastPlacement);\n                    tooltip.addClass(options.placementClassPrefix + ttPosition.placement);\n                  }\n\n                  adjustmentTimeout = $timeout(function() {\n                    var currentHeight = angular.isDefined(tooltip.offsetHeight) ? tooltip.offsetHeight : tooltip.prop('offsetHeight');\n                    var adjustment = $position.adjustTop(placementClasses, elementPos, initialHeight, currentHeight);\n                    if (adjustment) {\n                      tooltip.css(adjustment);\n                    }\n                    adjustmentTimeout = null;\n                  }, 0, false);\n\n                  // first time through tt element will have the\n                  // uib-position-measure class or if the placement\n                  // has changed we need to position the arrow.\n                  if (tooltip.hasClass('uib-position-measure')) {\n                    $position.positionArrow(tooltip, ttPosition.placement);\n                    tooltip.removeClass('uib-position-measure');\n                  } else if (lastPlacement !== ttPosition.placement) {\n                    $position.positionArrow(tooltip, ttPosition.placement);\n                  }\n                  lastPlacement = ttPosition.placement;\n\n                  positionTimeout = null;\n                }, 0, false);\n              }\n            };\n\n            // Set up the correct scope to allow transclusion later\n            ttScope.origScope = scope;\n\n            // By default, the tooltip is not open.\n            // TODO add ability to start tooltip opened\n            ttScope.isOpen = false;\n\n            function toggleTooltipBind() {\n              if (!ttScope.isOpen) {\n                showTooltipBind();\n              } else {\n                hideTooltipBind();\n              }\n            }\n\n            // Show the tooltip with delay if specified, otherwise show it immediately\n            function showTooltipBind() {\n              if (hasEnableExp && !scope.$eval(attrs[prefix + 'Enable'])) {\n                return;\n              }\n\n              cancelHide();\n              prepareTooltip();\n\n              if (ttScope.popupDelay) {\n                // Do nothing if the tooltip was already scheduled to pop-up.\n                // This happens if show is triggered multiple times before any hide is triggered.\n                if (!showTimeout) {\n                  showTimeout = $timeout(show, ttScope.popupDelay, false);\n                }\n              } else {\n                show();\n              }\n            }\n\n            function hideTooltipBind() {\n              cancelShow();\n\n              if (ttScope.popupCloseDelay) {\n                if (!hideTimeout) {\n                  hideTimeout = $timeout(hide, ttScope.popupCloseDelay, false);\n                }\n              } else {\n                hide();\n              }\n            }\n\n            // Show the tooltip popup element.\n            function show() {\n              cancelShow();\n              cancelHide();\n\n              // Don't show empty tooltips.\n              if (!ttScope.content) {\n                return angular.noop;\n              }\n\n              createTooltip();\n\n              // And show the tooltip.\n              ttScope.$evalAsync(function() {\n                ttScope.isOpen = true;\n                assignIsOpen(true);\n                positionTooltip();\n              });\n            }\n\n            function cancelShow() {\n              if (showTimeout) {\n                $timeout.cancel(showTimeout);\n                showTimeout = null;\n              }\n\n              if (positionTimeout) {\n                $timeout.cancel(positionTimeout);\n                positionTimeout = null;\n              }\n            }\n\n            // Hide the tooltip popup element.\n            function hide() {\n              if (!ttScope) {\n                return;\n              }\n\n              // First things first: we don't show it anymore.\n              ttScope.$evalAsync(function() {\n                if (ttScope) {\n                  ttScope.isOpen = false;\n                  assignIsOpen(false);\n                  // And now we remove it from the DOM. However, if we have animation, we\n                  // need to wait for it to expire beforehand.\n                  // FIXME: this is a placeholder for a port of the transitions library.\n                  // The fade transition in TWBS is 150ms.\n                  if (ttScope.animation) {\n                    if (!transitionTimeout) {\n                      transitionTimeout = $timeout(removeTooltip, 150, false);\n                    }\n                  } else {\n                    removeTooltip();\n                  }\n                }\n              });\n            }\n\n            function cancelHide() {\n              if (hideTimeout) {\n                $timeout.cancel(hideTimeout);\n                hideTimeout = null;\n              }\n\n              if (transitionTimeout) {\n                $timeout.cancel(transitionTimeout);\n                transitionTimeout = null;\n              }\n            }\n\n            function createTooltip() {\n              // There can only be one tooltip element per directive shown at once.\n              if (tooltip) {\n                return;\n              }\n\n              tooltipLinkedScope = ttScope.$new();\n              tooltip = tooltipLinker(tooltipLinkedScope, function(tooltip) {\n                if (appendToBody) {\n                  $document.find('body').append(tooltip);\n                } else {\n                  element.after(tooltip);\n                }\n              });\n\n              openedTooltips.add(ttScope, {\n                close: hide\n              });\n\n              prepObservers();\n            }\n\n            function removeTooltip() {\n              cancelShow();\n              cancelHide();\n              unregisterObservers();\n\n              if (tooltip) {\n                tooltip.remove();\n                \n                tooltip = null;\n                if (adjustmentTimeout) {\n                  $timeout.cancel(adjustmentTimeout);\n                }\n              }\n\n              openedTooltips.remove(ttScope);\n              \n              if (tooltipLinkedScope) {\n                tooltipLinkedScope.$destroy();\n                tooltipLinkedScope = null;\n              }\n            }\n\n            /**\n             * Set the initial scope values. Once\n             * the tooltip is created, the observers\n             * will be added to keep things in sync.\n             */\n            function prepareTooltip() {\n              ttScope.title = attrs[prefix + 'Title'];\n              if (contentParse) {\n                ttScope.content = contentParse(scope);\n              } else {\n                ttScope.content = attrs[ttType];\n              }\n\n              ttScope.popupClass = attrs[prefix + 'Class'];\n              ttScope.placement = angular.isDefined(attrs[prefix + 'Placement']) ? attrs[prefix + 'Placement'] : options.placement;\n              var placement = $position.parsePlacement(ttScope.placement);\n              lastPlacement = placement[1] ? placement[0] + '-' + placement[1] : placement[0];\n\n              var delay = parseInt(attrs[prefix + 'PopupDelay'], 10);\n              var closeDelay = parseInt(attrs[prefix + 'PopupCloseDelay'], 10);\n              ttScope.popupDelay = !isNaN(delay) ? delay : options.popupDelay;\n              ttScope.popupCloseDelay = !isNaN(closeDelay) ? closeDelay : options.popupCloseDelay;\n            }\n\n            function assignIsOpen(isOpen) {\n              if (isOpenParse && angular.isFunction(isOpenParse.assign)) {\n                isOpenParse.assign(scope, isOpen);\n              }\n            }\n\n            ttScope.contentExp = function() {\n              return ttScope.content;\n            };\n\n            /**\n             * Observe the relevant attributes.\n             */\n            attrs.$observe('disabled', function(val) {\n              if (val) {\n                cancelShow();\n              }\n\n              if (val && ttScope.isOpen) {\n                hide();\n              }\n            });\n\n            if (isOpenParse) {\n              scope.$watch(isOpenParse, function(val) {\n                if (ttScope && !val === ttScope.isOpen) {\n                  toggleTooltipBind();\n                }\n              });\n            }\n\n            function prepObservers() {\n              observers.length = 0;\n\n              if (contentParse) {\n                observers.push(\n                  scope.$watch(contentParse, function(val) {\n                    ttScope.content = val;\n                    if (!val && ttScope.isOpen) {\n                      hide();\n                    }\n                  })\n                );\n\n                observers.push(\n                  tooltipLinkedScope.$watch(function() {\n                    if (!repositionScheduled) {\n                      repositionScheduled = true;\n                      tooltipLinkedScope.$$postDigest(function() {\n                        repositionScheduled = false;\n                        if (ttScope && ttScope.isOpen) {\n                          positionTooltip();\n                        }\n                      });\n                    }\n                  })\n                );\n              } else {\n                observers.push(\n                  attrs.$observe(ttType, function(val) {\n                    ttScope.content = val;\n                    if (!val && ttScope.isOpen) {\n                      hide();\n                    } else {\n                      positionTooltip();\n                    }\n                  })\n                );\n              }\n\n              observers.push(\n                attrs.$observe(prefix + 'Title', function(val) {\n                  ttScope.title = val;\n                  if (ttScope.isOpen) {\n                    positionTooltip();\n                  }\n                })\n              );\n\n              observers.push(\n                attrs.$observe(prefix + 'Placement', function(val) {\n                  ttScope.placement = val ? val : options.placement;\n                  if (ttScope.isOpen) {\n                    positionTooltip();\n                  }\n                })\n              );\n            }\n\n            function unregisterObservers() {\n              if (observers.length) {\n                angular.forEach(observers, function(observer) {\n                  observer();\n                });\n                observers.length = 0;\n              }\n            }\n\n            // hide tooltips/popovers for outsideClick trigger\n            function bodyHideTooltipBind(e) {\n              if (!ttScope || !ttScope.isOpen || !tooltip) {\n                return;\n              }\n              // make sure the tooltip/popover link or tool tooltip/popover itself were not clicked\n              if (!element[0].contains(e.target) && !tooltip[0].contains(e.target)) {\n                hideTooltipBind();\n              }\n            }\n\n            // KeyboardEvent handler to hide the tooltip on Escape key press\n            function hideOnEscapeKey(e) {\n              if (e.which === 27) {\n                hideTooltipBind();\n              }\n            }\n\n            var unregisterTriggers = function() {\n              triggers.show.forEach(function(trigger) {\n                if (trigger === 'outsideClick') {\n                  element.off('click', toggleTooltipBind);\n                } else {\n                  element.off(trigger, showTooltipBind);\n                  element.off(trigger, toggleTooltipBind);\n                }\n                element.off('keypress', hideOnEscapeKey);\n              });\n              triggers.hide.forEach(function(trigger) {\n                if (trigger === 'outsideClick') {\n                  $document.off('click', bodyHideTooltipBind);\n                } else {\n                  element.off(trigger, hideTooltipBind);\n                }\n              });\n            };\n\n            function prepTriggers() {\n              var showTriggers = [], hideTriggers = [];\n              var val = scope.$eval(attrs[prefix + 'Trigger']);\n              unregisterTriggers();\n\n              if (angular.isObject(val)) {\n                Object.keys(val).forEach(function(key) {\n                  showTriggers.push(key);\n                  hideTriggers.push(val[key]);\n                });\n                triggers = {\n                  show: showTriggers,\n                  hide: hideTriggers\n                };\n              } else {\n                triggers = getTriggers(val);\n              }\n\n              if (triggers.show !== 'none') {\n                triggers.show.forEach(function(trigger, idx) {\n                  if (trigger === 'outsideClick') {\n                    element.on('click', toggleTooltipBind);\n                    $document.on('click', bodyHideTooltipBind);\n                  } else if (trigger === triggers.hide[idx]) {\n                    element.on(trigger, toggleTooltipBind);\n                  } else if (trigger) {\n                    element.on(trigger, showTooltipBind);\n                    element.on(triggers.hide[idx], hideTooltipBind);\n                  }\n                  element.on('keypress', hideOnEscapeKey);\n                });\n              }\n            }\n\n            prepTriggers();\n\n            var animation = scope.$eval(attrs[prefix + 'Animation']);\n            ttScope.animation = angular.isDefined(animation) ? !!animation : options.animation;\n\n            var appendToBodyVal;\n            var appendKey = prefix + 'AppendToBody';\n            if (appendKey in attrs && attrs[appendKey] === undefined) {\n              appendToBodyVal = true;\n            } else {\n              appendToBodyVal = scope.$eval(attrs[appendKey]);\n            }\n\n            appendToBody = angular.isDefined(appendToBodyVal) ? appendToBodyVal : appendToBody;\n\n            // Make sure tooltip is destroyed and removed.\n            scope.$on('$destroy', function onDestroyTooltip() {\n              unregisterTriggers();\n              removeTooltip();\n              ttScope = null;\n            });\n          };\n        }\n      };\n    };\n  }];\n})\n\n// This is mostly ngInclude code but with a custom scope\n.directive('uibTooltipTemplateTransclude', [\n         '$animate', '$sce', '$compile', '$templateRequest',\nfunction ($animate, $sce, $compile, $templateRequest) {\n  return {\n    link: function(scope, elem, attrs) {\n      var origScope = scope.$eval(attrs.tooltipTemplateTranscludeScope);\n\n      var changeCounter = 0,\n        currentScope,\n        previousElement,\n        currentElement;\n\n      var cleanupLastIncludeContent = function() {\n        if (previousElement) {\n          previousElement.remove();\n          previousElement = null;\n        }\n\n        if (currentScope) {\n          currentScope.$destroy();\n          currentScope = null;\n        }\n\n        if (currentElement) {\n          $animate.leave(currentElement).then(function() {\n            previousElement = null;\n          });\n          previousElement = currentElement;\n          currentElement = null;\n        }\n      };\n\n      scope.$watch($sce.parseAsResourceUrl(attrs.uibTooltipTemplateTransclude), function(src) {\n        var thisChangeId = ++changeCounter;\n\n        if (src) {\n          //set the 2nd param to true to ignore the template request error so that the inner\n          //contents and scope can be cleaned up.\n          $templateRequest(src, true).then(function(response) {\n            if (thisChangeId !== changeCounter) { return; }\n            var newScope = origScope.$new();\n            var template = response;\n\n            var clone = $compile(template)(newScope, function(clone) {\n              cleanupLastIncludeContent();\n              $animate.enter(clone, elem);\n            });\n\n            currentScope = newScope;\n            currentElement = clone;\n\n            currentScope.$emit('$includeContentLoaded', src);\n          }, function() {\n            if (thisChangeId === changeCounter) {\n              cleanupLastIncludeContent();\n              scope.$emit('$includeContentError', src);\n            }\n          });\n          scope.$emit('$includeContentRequested', src);\n        } else {\n          cleanupLastIncludeContent();\n        }\n      });\n\n      scope.$on('$destroy', cleanupLastIncludeContent);\n    }\n  };\n}])\n\n/**\n * Note that it's intentional that these classes are *not* applied through $animate.\n * They must not be animated as they're expected to be present on the tooltip on\n * initialization.\n */\n.directive('uibTooltipClasses', ['$uibPosition', function($uibPosition) {\n  return {\n    restrict: 'A',\n    link: function(scope, element, attrs) {\n      // need to set the primary position so the\n      // arrow has space during position measure.\n      // tooltip.positionTooltip()\n      if (scope.placement) {\n        // // There are no top-left etc... classes\n        // // in TWBS, so we need the primary position.\n        var position = $uibPosition.parsePlacement(scope.placement);\n        element.addClass(position[0]);\n      }\n\n      if (scope.popupClass) {\n        element.addClass(scope.popupClass);\n      }\n\n      if (scope.animation) {\n        element.addClass(attrs.tooltipAnimationClass);\n      }\n    }\n  };\n}])\n\n.directive('uibTooltipPopup', function() {\n  return {\n    restrict: 'A',\n    scope: { content: '@' },\n    templateUrl: 'uib/template/tooltip/tooltip-popup.html'\n  };\n})\n\n.directive('uibTooltip', [ '$uibTooltip', function($uibTooltip) {\n  return $uibTooltip('uibTooltip', 'tooltip', 'mouseenter');\n}])\n\n.directive('uibTooltipTemplatePopup', function() {\n  return {\n    restrict: 'A',\n    scope: { contentExp: '&', originScope: '&' },\n    templateUrl: 'uib/template/tooltip/tooltip-template-popup.html'\n  };\n})\n\n.directive('uibTooltipTemplate', ['$uibTooltip', function($uibTooltip) {\n  return $uibTooltip('uibTooltipTemplate', 'tooltip', 'mouseenter', {\n    useContentExp: true\n  });\n}])\n\n.directive('uibTooltipHtmlPopup', function() {\n  return {\n    restrict: 'A',\n    scope: { contentExp: '&' },\n    templateUrl: 'uib/template/tooltip/tooltip-html-popup.html'\n  };\n})\n\n.directive('uibTooltipHtml', ['$uibTooltip', function($uibTooltip) {\n  return $uibTooltip('uibTooltipHtml', 'tooltip', 'mouseenter', {\n    useContentExp: true\n  });\n}]);\n\n/**\n * The following features are still outstanding: popup delay, animation as a\n * function, placement as a function, inside, support for more triggers than\n * just mouse enter/leave, and selector delegatation.\n */\nangular.module('ui.bootstrap.popover', ['ui.bootstrap.tooltip'])\n\n.directive('uibPopoverTemplatePopup', function() {\n  return {\n    restrict: 'A',\n    scope: { uibTitle: '@', contentExp: '&', originScope: '&' },\n    templateUrl: 'uib/template/popover/popover-template.html'\n  };\n})\n\n.directive('uibPopoverTemplate', ['$uibTooltip', function($uibTooltip) {\n  return $uibTooltip('uibPopoverTemplate', 'popover', 'click', {\n    useContentExp: true\n  });\n}])\n\n.directive('uibPopoverHtmlPopup', function() {\n  return {\n    restrict: 'A',\n    scope: { contentExp: '&', uibTitle: '@' },\n    templateUrl: 'uib/template/popover/popover-html.html'\n  };\n})\n\n.directive('uibPopoverHtml', ['$uibTooltip', function($uibTooltip) {\n  return $uibTooltip('uibPopoverHtml', 'popover', 'click', {\n    useContentExp: true\n  });\n}])\n\n.directive('uibPopoverPopup', function() {\n  return {\n    restrict: 'A',\n    scope: { uibTitle: '@', content: '@' },\n    templateUrl: 'uib/template/popover/popover.html'\n  };\n})\n\n.directive('uibPopover', ['$uibTooltip', function($uibTooltip) {\n  return $uibTooltip('uibPopover', 'popover', 'click');\n}]);\n\nangular.module('ui.bootstrap.progressbar', [])\n\n.constant('uibProgressConfig', {\n  animate: true,\n  max: 100\n})\n\n.controller('UibProgressController', ['$scope', '$attrs', 'uibProgressConfig', function($scope, $attrs, progressConfig) {\n  var self = this,\n      animate = angular.isDefined($attrs.animate) ? $scope.$parent.$eval($attrs.animate) : progressConfig.animate;\n\n  this.bars = [];\n  $scope.max = getMaxOrDefault();\n\n  this.addBar = function(bar, element, attrs) {\n    if (!animate) {\n      element.css({'transition': 'none'});\n    }\n\n    this.bars.push(bar);\n\n    bar.max = getMaxOrDefault();\n    bar.title = attrs && angular.isDefined(attrs.title) ? attrs.title : 'progressbar';\n\n    bar.$watch('value', function(value) {\n      bar.recalculatePercentage();\n    });\n\n    bar.recalculatePercentage = function() {\n      var totalPercentage = self.bars.reduce(function(total, bar) {\n        bar.percent = +(100 * bar.value / bar.max).toFixed(2);\n        return total + bar.percent;\n      }, 0);\n\n      if (totalPercentage > 100) {\n        bar.percent -= totalPercentage - 100;\n      }\n    };\n\n    bar.$on('$destroy', function() {\n      element = null;\n      self.removeBar(bar);\n    });\n  };\n\n  this.removeBar = function(bar) {\n    this.bars.splice(this.bars.indexOf(bar), 1);\n    this.bars.forEach(function (bar) {\n      bar.recalculatePercentage();\n    });\n  };\n\n  //$attrs.$observe('maxParam', function(maxParam) {\n  $scope.$watch('maxParam', function(maxParam) {\n    self.bars.forEach(function(bar) {\n      bar.max = getMaxOrDefault();\n      bar.recalculatePercentage();\n    });\n  });\n\n  function getMaxOrDefault () {\n    return angular.isDefined($scope.maxParam) ? $scope.maxParam : progressConfig.max;\n  }\n}])\n\n.directive('uibProgress', function() {\n  return {\n    replace: true,\n    transclude: true,\n    controller: 'UibProgressController',\n    require: 'uibProgress',\n    scope: {\n      maxParam: '=?max'\n    },\n    templateUrl: 'uib/template/progressbar/progress.html'\n  };\n})\n\n.directive('uibBar', function() {\n  return {\n    replace: true,\n    transclude: true,\n    require: '^uibProgress',\n    scope: {\n      value: '=',\n      type: '@'\n    },\n    templateUrl: 'uib/template/progressbar/bar.html',\n    link: function(scope, element, attrs, progressCtrl) {\n      progressCtrl.addBar(scope, element, attrs);\n    }\n  };\n})\n\n.directive('uibProgressbar', function() {\n  return {\n    replace: true,\n    transclude: true,\n    controller: 'UibProgressController',\n    scope: {\n      value: '=',\n      maxParam: '=?max',\n      type: '@'\n    },\n    templateUrl: 'uib/template/progressbar/progressbar.html',\n    link: function(scope, element, attrs, progressCtrl) {\n      progressCtrl.addBar(scope, angular.element(element.children()[0]), {title: attrs.title});\n    }\n  };\n});\n\nangular.module('ui.bootstrap.rating', [])\n\n.constant('uibRatingConfig', {\n  max: 5,\n  stateOn: null,\n  stateOff: null,\n  enableReset: true,\n  titles: ['one', 'two', 'three', 'four', 'five']\n})\n\n.controller('UibRatingController', ['$scope', '$attrs', 'uibRatingConfig', function($scope, $attrs, ratingConfig) {\n  var ngModelCtrl = { $setViewValue: angular.noop },\n    self = this;\n\n  this.init = function(ngModelCtrl_) {\n    ngModelCtrl = ngModelCtrl_;\n    ngModelCtrl.$render = this.render;\n\n    ngModelCtrl.$formatters.push(function(value) {\n      if (angular.isNumber(value) && value << 0 !== value) {\n        value = Math.round(value);\n      }\n\n      return value;\n    });\n\n    this.stateOn = angular.isDefined($attrs.stateOn) ? $scope.$parent.$eval($attrs.stateOn) : ratingConfig.stateOn;\n    this.stateOff = angular.isDefined($attrs.stateOff) ? $scope.$parent.$eval($attrs.stateOff) : ratingConfig.stateOff;\n    this.enableReset = angular.isDefined($attrs.enableReset) ?\n      $scope.$parent.$eval($attrs.enableReset) : ratingConfig.enableReset;\n    var tmpTitles = angular.isDefined($attrs.titles) ? $scope.$parent.$eval($attrs.titles) : ratingConfig.titles;\n    this.titles = angular.isArray(tmpTitles) && tmpTitles.length > 0 ?\n      tmpTitles : ratingConfig.titles;\n\n    var ratingStates = angular.isDefined($attrs.ratingStates) ?\n      $scope.$parent.$eval($attrs.ratingStates) :\n      new Array(angular.isDefined($attrs.max) ? $scope.$parent.$eval($attrs.max) : ratingConfig.max);\n    $scope.range = this.buildTemplateObjects(ratingStates);\n  };\n\n  this.buildTemplateObjects = function(states) {\n    for (var i = 0, n = states.length; i < n; i++) {\n      states[i] = angular.extend({ index: i }, { stateOn: this.stateOn, stateOff: this.stateOff, title: this.getTitle(i) }, states[i]);\n    }\n    return states;\n  };\n\n  this.getTitle = function(index) {\n    if (index >= this.titles.length) {\n      return index + 1;\n    }\n\n    return this.titles[index];\n  };\n\n  $scope.rate = function(value) {\n    if (!$scope.readonly && value >= 0 && value <= $scope.range.length) {\n      var newViewValue = self.enableReset && ngModelCtrl.$viewValue === value ? 0 : value;\n      ngModelCtrl.$setViewValue(newViewValue);\n      ngModelCtrl.$render();\n    }\n  };\n\n  $scope.enter = function(value) {\n    if (!$scope.readonly) {\n      $scope.value = value;\n    }\n    $scope.onHover({value: value});\n  };\n\n  $scope.reset = function() {\n    $scope.value = ngModelCtrl.$viewValue;\n    $scope.onLeave();\n  };\n\n  $scope.onKeydown = function(evt) {\n    if (/(37|38|39|40)/.test(evt.which)) {\n      evt.preventDefault();\n      evt.stopPropagation();\n      $scope.rate($scope.value + (evt.which === 38 || evt.which === 39 ? 1 : -1));\n    }\n  };\n\n  this.render = function() {\n    $scope.value = ngModelCtrl.$viewValue;\n    $scope.title = self.getTitle($scope.value - 1);\n  };\n}])\n\n.directive('uibRating', function() {\n  return {\n    require: ['uibRating', 'ngModel'],\n    restrict: 'A',\n    scope: {\n      readonly: '=?readOnly',\n      onHover: '&',\n      onLeave: '&'\n    },\n    controller: 'UibRatingController',\n    templateUrl: 'uib/template/rating/rating.html',\n    link: function(scope, element, attrs, ctrls) {\n      var ratingCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n      ratingCtrl.init(ngModelCtrl);\n    }\n  };\n});\n\nangular.module('ui.bootstrap.tabs', [])\n\n.controller('UibTabsetController', ['$scope', function ($scope) {\n  var ctrl = this,\n    oldIndex;\n  ctrl.tabs = [];\n\n  ctrl.select = function(index, evt) {\n    if (!destroyed) {\n      var previousIndex = findTabIndex(oldIndex);\n      var previousSelected = ctrl.tabs[previousIndex];\n      if (previousSelected) {\n        previousSelected.tab.onDeselect({\n          $event: evt,\n          $selectedIndex: index\n        });\n        if (evt && evt.isDefaultPrevented()) {\n          return;\n        }\n        previousSelected.tab.active = false;\n      }\n\n      var selected = ctrl.tabs[index];\n      if (selected) {\n        selected.tab.onSelect({\n          $event: evt\n        });\n        selected.tab.active = true;\n        ctrl.active = selected.index;\n        oldIndex = selected.index;\n      } else if (!selected && angular.isDefined(oldIndex)) {\n        ctrl.active = null;\n        oldIndex = null;\n      }\n    }\n  };\n\n  ctrl.addTab = function addTab(tab) {\n    ctrl.tabs.push({\n      tab: tab,\n      index: tab.index\n    });\n    ctrl.tabs.sort(function(t1, t2) {\n      if (t1.index > t2.index) {\n        return 1;\n      }\n\n      if (t1.index < t2.index) {\n        return -1;\n      }\n\n      return 0;\n    });\n\n    if (tab.index === ctrl.active || !angular.isDefined(ctrl.active) && ctrl.tabs.length === 1) {\n      var newActiveIndex = findTabIndex(tab.index);\n      ctrl.select(newActiveIndex);\n    }\n  };\n\n  ctrl.removeTab = function removeTab(tab) {\n    var index;\n    for (var i = 0; i < ctrl.tabs.length; i++) {\n      if (ctrl.tabs[i].tab === tab) {\n        index = i;\n        break;\n      }\n    }\n\n    if (ctrl.tabs[index].index === ctrl.active) {\n      var newActiveTabIndex = index === ctrl.tabs.length - 1 ?\n        index - 1 : index + 1 % ctrl.tabs.length;\n      ctrl.select(newActiveTabIndex);\n    }\n\n    ctrl.tabs.splice(index, 1);\n  };\n\n  $scope.$watch('tabset.active', function(val) {\n    if (angular.isDefined(val) && val !== oldIndex) {\n      ctrl.select(findTabIndex(val));\n    }\n  });\n\n  var destroyed;\n  $scope.$on('$destroy', function() {\n    destroyed = true;\n  });\n\n  function findTabIndex(index) {\n    for (var i = 0; i < ctrl.tabs.length; i++) {\n      if (ctrl.tabs[i].index === index) {\n        return i;\n      }\n    }\n  }\n}])\n\n.directive('uibTabset', function() {\n  return {\n    transclude: true,\n    replace: true,\n    scope: {},\n    bindToController: {\n      active: '=?',\n      type: '@'\n    },\n    controller: 'UibTabsetController',\n    controllerAs: 'tabset',\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'uib/template/tabs/tabset.html';\n    },\n    link: function(scope, element, attrs) {\n      scope.vertical = angular.isDefined(attrs.vertical) ?\n        scope.$parent.$eval(attrs.vertical) : false;\n      scope.justified = angular.isDefined(attrs.justified) ?\n        scope.$parent.$eval(attrs.justified) : false;\n    }\n  };\n})\n\n.directive('uibTab', ['$parse', function($parse) {\n  return {\n    require: '^uibTabset',\n    replace: true,\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'uib/template/tabs/tab.html';\n    },\n    transclude: true,\n    scope: {\n      heading: '@',\n      index: '=?',\n      classes: '@?',\n      onSelect: '&select', //This callback is called in contentHeadingTransclude\n                          //once it inserts the tab's content into the dom\n      onDeselect: '&deselect'\n    },\n    controller: function() {\n      //Empty controller so other directives can require being 'under' a tab\n    },\n    controllerAs: 'tab',\n    link: function(scope, elm, attrs, tabsetCtrl, transclude) {\n      scope.disabled = false;\n      if (attrs.disable) {\n        scope.$parent.$watch($parse(attrs.disable), function(value) {\n          scope.disabled = !! value;\n        });\n      }\n\n      if (angular.isUndefined(attrs.index)) {\n        if (tabsetCtrl.tabs && tabsetCtrl.tabs.length) {\n          scope.index = Math.max.apply(null, tabsetCtrl.tabs.map(function(t) { return t.index; })) + 1;\n        } else {\n          scope.index = 0;\n        }\n      }\n\n      if (angular.isUndefined(attrs.classes)) {\n        scope.classes = '';\n      }\n\n      scope.select = function(evt) {\n        if (!scope.disabled) {\n          var index;\n          for (var i = 0; i < tabsetCtrl.tabs.length; i++) {\n            if (tabsetCtrl.tabs[i].tab === scope) {\n              index = i;\n              break;\n            }\n          }\n\n          tabsetCtrl.select(index, evt);\n        }\n      };\n\n      tabsetCtrl.addTab(scope);\n      scope.$on('$destroy', function() {\n        tabsetCtrl.removeTab(scope);\n      });\n\n      //We need to transclude later, once the content container is ready.\n      //when this link happens, we're inside a tab heading.\n      scope.$transcludeFn = transclude;\n    }\n  };\n}])\n\n.directive('uibTabHeadingTransclude', function() {\n  return {\n    restrict: 'A',\n    require: '^uibTab',\n    link: function(scope, elm) {\n      scope.$watch('headingElement', function updateHeadingElement(heading) {\n        if (heading) {\n          elm.html('');\n          elm.append(heading);\n        }\n      });\n    }\n  };\n})\n\n.directive('uibTabContentTransclude', function() {\n  return {\n    restrict: 'A',\n    require: '^uibTabset',\n    link: function(scope, elm, attrs) {\n      var tab = scope.$eval(attrs.uibTabContentTransclude).tab;\n\n      //Now our tab is ready to be transcluded: both the tab heading area\n      //and the tab content area are loaded.  Transclude 'em both.\n      tab.$transcludeFn(tab.$parent, function(contents) {\n        angular.forEach(contents, function(node) {\n          if (isTabHeading(node)) {\n            //Let tabHeadingTransclude know.\n            tab.headingElement = node;\n          } else {\n            elm.append(node);\n          }\n        });\n      });\n    }\n  };\n\n  function isTabHeading(node) {\n    return node.tagName && (\n      node.hasAttribute('uib-tab-heading') ||\n      node.hasAttribute('data-uib-tab-heading') ||\n      node.hasAttribute('x-uib-tab-heading') ||\n      node.tagName.toLowerCase() === 'uib-tab-heading' ||\n      node.tagName.toLowerCase() === 'data-uib-tab-heading' ||\n      node.tagName.toLowerCase() === 'x-uib-tab-heading' ||\n      node.tagName.toLowerCase() === 'uib:tab-heading'\n    );\n  }\n});\n\nangular.module('ui.bootstrap.timepicker', [])\n\n.constant('uibTimepickerConfig', {\n  hourStep: 1,\n  minuteStep: 1,\n  secondStep: 1,\n  showMeridian: true,\n  showSeconds: false,\n  meridians: null,\n  readonlyInput: false,\n  mousewheel: true,\n  arrowkeys: true,\n  showSpinners: true,\n  templateUrl: 'uib/template/timepicker/timepicker.html'\n})\n\n.controller('UibTimepickerController', ['$scope', '$element', '$attrs', '$parse', '$log', '$locale', 'uibTimepickerConfig', function($scope, $element, $attrs, $parse, $log, $locale, timepickerConfig) {\n  var hoursModelCtrl, minutesModelCtrl, secondsModelCtrl;\n  var selected = new Date(),\n    watchers = [],\n    ngModelCtrl = { $setViewValue: angular.noop }, // nullModelCtrl\n    meridians = angular.isDefined($attrs.meridians) ? $scope.$parent.$eval($attrs.meridians) : timepickerConfig.meridians || $locale.DATETIME_FORMATS.AMPMS,\n    padHours = angular.isDefined($attrs.padHours) ? $scope.$parent.$eval($attrs.padHours) : true;\n\n  $scope.tabindex = angular.isDefined($attrs.tabindex) ? $attrs.tabindex : 0;\n  $element.removeAttr('tabindex');\n\n  this.init = function(ngModelCtrl_, inputs) {\n    ngModelCtrl = ngModelCtrl_;\n    ngModelCtrl.$render = this.render;\n\n    ngModelCtrl.$formatters.unshift(function(modelValue) {\n      return modelValue ? new Date(modelValue) : null;\n    });\n\n    var hoursInputEl = inputs.eq(0),\n        minutesInputEl = inputs.eq(1),\n        secondsInputEl = inputs.eq(2);\n\n    hoursModelCtrl = hoursInputEl.controller('ngModel');\n    minutesModelCtrl = minutesInputEl.controller('ngModel');\n    secondsModelCtrl = secondsInputEl.controller('ngModel');\n\n    var mousewheel = angular.isDefined($attrs.mousewheel) ? $scope.$parent.$eval($attrs.mousewheel) : timepickerConfig.mousewheel;\n\n    if (mousewheel) {\n      this.setupMousewheelEvents(hoursInputEl, minutesInputEl, secondsInputEl);\n    }\n\n    var arrowkeys = angular.isDefined($attrs.arrowkeys) ? $scope.$parent.$eval($attrs.arrowkeys) : timepickerConfig.arrowkeys;\n    if (arrowkeys) {\n      this.setupArrowkeyEvents(hoursInputEl, minutesInputEl, secondsInputEl);\n    }\n\n    $scope.readonlyInput = angular.isDefined($attrs.readonlyInput) ? $scope.$parent.$eval($attrs.readonlyInput) : timepickerConfig.readonlyInput;\n    this.setupInputEvents(hoursInputEl, minutesInputEl, secondsInputEl);\n  };\n\n  var hourStep = timepickerConfig.hourStep;\n  if ($attrs.hourStep) {\n    watchers.push($scope.$parent.$watch($parse($attrs.hourStep), function(value) {\n      hourStep = +value;\n    }));\n  }\n\n  var minuteStep = timepickerConfig.minuteStep;\n  if ($attrs.minuteStep) {\n    watchers.push($scope.$parent.$watch($parse($attrs.minuteStep), function(value) {\n      minuteStep = +value;\n    }));\n  }\n\n  var min;\n  watchers.push($scope.$parent.$watch($parse($attrs.min), function(value) {\n    var dt = new Date(value);\n    min = isNaN(dt) ? undefined : dt;\n  }));\n\n  var max;\n  watchers.push($scope.$parent.$watch($parse($attrs.max), function(value) {\n    var dt = new Date(value);\n    max = isNaN(dt) ? undefined : dt;\n  }));\n\n  var disabled = false;\n  if ($attrs.ngDisabled) {\n    watchers.push($scope.$parent.$watch($parse($attrs.ngDisabled), function(value) {\n      disabled = value;\n    }));\n  }\n\n  $scope.noIncrementHours = function() {\n    var incrementedSelected = addMinutes(selected, hourStep * 60);\n    return disabled || incrementedSelected > max ||\n      incrementedSelected < selected && incrementedSelected < min;\n  };\n\n  $scope.noDecrementHours = function() {\n    var decrementedSelected = addMinutes(selected, -hourStep * 60);\n    return disabled || decrementedSelected < min ||\n      decrementedSelected > selected && decrementedSelected > max;\n  };\n\n  $scope.noIncrementMinutes = function() {\n    var incrementedSelected = addMinutes(selected, minuteStep);\n    return disabled || incrementedSelected > max ||\n      incrementedSelected < selected && incrementedSelected < min;\n  };\n\n  $scope.noDecrementMinutes = function() {\n    var decrementedSelected = addMinutes(selected, -minuteStep);\n    return disabled || decrementedSelected < min ||\n      decrementedSelected > selected && decrementedSelected > max;\n  };\n\n  $scope.noIncrementSeconds = function() {\n    var incrementedSelected = addSeconds(selected, secondStep);\n    return disabled || incrementedSelected > max ||\n      incrementedSelected < selected && incrementedSelected < min;\n  };\n\n  $scope.noDecrementSeconds = function() {\n    var decrementedSelected = addSeconds(selected, -secondStep);\n    return disabled || decrementedSelected < min ||\n      decrementedSelected > selected && decrementedSelected > max;\n  };\n\n  $scope.noToggleMeridian = function() {\n    if (selected.getHours() < 12) {\n      return disabled || addMinutes(selected, 12 * 60) > max;\n    }\n\n    return disabled || addMinutes(selected, -12 * 60) < min;\n  };\n\n  var secondStep = timepickerConfig.secondStep;\n  if ($attrs.secondStep) {\n    watchers.push($scope.$parent.$watch($parse($attrs.secondStep), function(value) {\n      secondStep = +value;\n    }));\n  }\n\n  $scope.showSeconds = timepickerConfig.showSeconds;\n  if ($attrs.showSeconds) {\n    watchers.push($scope.$parent.$watch($parse($attrs.showSeconds), function(value) {\n      $scope.showSeconds = !!value;\n    }));\n  }\n\n  // 12H / 24H mode\n  $scope.showMeridian = timepickerConfig.showMeridian;\n  if ($attrs.showMeridian) {\n    watchers.push($scope.$parent.$watch($parse($attrs.showMeridian), function(value) {\n      $scope.showMeridian = !!value;\n\n      if (ngModelCtrl.$error.time) {\n        // Evaluate from template\n        var hours = getHoursFromTemplate(), minutes = getMinutesFromTemplate();\n        if (angular.isDefined(hours) && angular.isDefined(minutes)) {\n          selected.setHours(hours);\n          refresh();\n        }\n      } else {\n        updateTemplate();\n      }\n    }));\n  }\n\n  // Get $scope.hours in 24H mode if valid\n  function getHoursFromTemplate() {\n    var hours = +$scope.hours;\n    var valid = $scope.showMeridian ? hours > 0 && hours < 13 :\n      hours >= 0 && hours < 24;\n    if (!valid || $scope.hours === '') {\n      return undefined;\n    }\n\n    if ($scope.showMeridian) {\n      if (hours === 12) {\n        hours = 0;\n      }\n      if ($scope.meridian === meridians[1]) {\n        hours = hours + 12;\n      }\n    }\n    return hours;\n  }\n\n  function getMinutesFromTemplate() {\n    var minutes = +$scope.minutes;\n    var valid = minutes >= 0 && minutes < 60;\n    if (!valid || $scope.minutes === '') {\n      return undefined;\n    }\n    return minutes;\n  }\n\n  function getSecondsFromTemplate() {\n    var seconds = +$scope.seconds;\n    return seconds >= 0 && seconds < 60 ? seconds : undefined;\n  }\n\n  function pad(value, noPad) {\n    if (value === null) {\n      return '';\n    }\n\n    return angular.isDefined(value) && value.toString().length < 2 && !noPad ?\n      '0' + value : value.toString();\n  }\n\n  // Respond on mousewheel spin\n  this.setupMousewheelEvents = function(hoursInputEl, minutesInputEl, secondsInputEl) {\n    var isScrollingUp = function(e) {\n      if (e.originalEvent) {\n        e = e.originalEvent;\n      }\n      //pick correct delta variable depending on event\n      var delta = e.wheelDelta ? e.wheelDelta : -e.deltaY;\n      return e.detail || delta > 0;\n    };\n\n    hoursInputEl.on('mousewheel wheel', function(e) {\n      if (!disabled) {\n        $scope.$apply(isScrollingUp(e) ? $scope.incrementHours() : $scope.decrementHours());\n      }\n      e.preventDefault();\n    });\n\n    minutesInputEl.on('mousewheel wheel', function(e) {\n      if (!disabled) {\n        $scope.$apply(isScrollingUp(e) ? $scope.incrementMinutes() : $scope.decrementMinutes());\n      }\n      e.preventDefault();\n    });\n\n     secondsInputEl.on('mousewheel wheel', function(e) {\n      if (!disabled) {\n        $scope.$apply(isScrollingUp(e) ? $scope.incrementSeconds() : $scope.decrementSeconds());\n      }\n      e.preventDefault();\n    });\n  };\n\n  // Respond on up/down arrowkeys\n  this.setupArrowkeyEvents = function(hoursInputEl, minutesInputEl, secondsInputEl) {\n    hoursInputEl.on('keydown', function(e) {\n      if (!disabled) {\n        if (e.which === 38) { // up\n          e.preventDefault();\n          $scope.incrementHours();\n          $scope.$apply();\n        } else if (e.which === 40) { // down\n          e.preventDefault();\n          $scope.decrementHours();\n          $scope.$apply();\n        }\n      }\n    });\n\n    minutesInputEl.on('keydown', function(e) {\n      if (!disabled) {\n        if (e.which === 38) { // up\n          e.preventDefault();\n          $scope.incrementMinutes();\n          $scope.$apply();\n        } else if (e.which === 40) { // down\n          e.preventDefault();\n          $scope.decrementMinutes();\n          $scope.$apply();\n        }\n      }\n    });\n\n    secondsInputEl.on('keydown', function(e) {\n      if (!disabled) {\n        if (e.which === 38) { // up\n          e.preventDefault();\n          $scope.incrementSeconds();\n          $scope.$apply();\n        } else if (e.which === 40) { // down\n          e.preventDefault();\n          $scope.decrementSeconds();\n          $scope.$apply();\n        }\n      }\n    });\n  };\n\n  this.setupInputEvents = function(hoursInputEl, minutesInputEl, secondsInputEl) {\n    if ($scope.readonlyInput) {\n      $scope.updateHours = angular.noop;\n      $scope.updateMinutes = angular.noop;\n      $scope.updateSeconds = angular.noop;\n      return;\n    }\n\n    var invalidate = function(invalidHours, invalidMinutes, invalidSeconds) {\n      ngModelCtrl.$setViewValue(null);\n      ngModelCtrl.$setValidity('time', false);\n      if (angular.isDefined(invalidHours)) {\n        $scope.invalidHours = invalidHours;\n        if (hoursModelCtrl) {\n          hoursModelCtrl.$setValidity('hours', false);\n        }\n      }\n\n      if (angular.isDefined(invalidMinutes)) {\n        $scope.invalidMinutes = invalidMinutes;\n        if (minutesModelCtrl) {\n          minutesModelCtrl.$setValidity('minutes', false);\n        }\n      }\n\n      if (angular.isDefined(invalidSeconds)) {\n        $scope.invalidSeconds = invalidSeconds;\n        if (secondsModelCtrl) {\n          secondsModelCtrl.$setValidity('seconds', false);\n        }\n      }\n    };\n\n    $scope.updateHours = function() {\n      var hours = getHoursFromTemplate(),\n        minutes = getMinutesFromTemplate();\n\n      ngModelCtrl.$setDirty();\n\n      if (angular.isDefined(hours) && angular.isDefined(minutes)) {\n        selected.setHours(hours);\n        selected.setMinutes(minutes);\n        if (selected < min || selected > max) {\n          invalidate(true);\n        } else {\n          refresh('h');\n        }\n      } else {\n        invalidate(true);\n      }\n    };\n\n    hoursInputEl.on('blur', function(e) {\n      ngModelCtrl.$setTouched();\n      if (modelIsEmpty()) {\n        makeValid();\n      } else if ($scope.hours === null || $scope.hours === '') {\n        invalidate(true);\n      } else if (!$scope.invalidHours && $scope.hours < 10) {\n        $scope.$apply(function() {\n          $scope.hours = pad($scope.hours, !padHours);\n        });\n      }\n    });\n\n    $scope.updateMinutes = function() {\n      var minutes = getMinutesFromTemplate(),\n        hours = getHoursFromTemplate();\n\n      ngModelCtrl.$setDirty();\n\n      if (angular.isDefined(minutes) && angular.isDefined(hours)) {\n        selected.setHours(hours);\n        selected.setMinutes(minutes);\n        if (selected < min || selected > max) {\n          invalidate(undefined, true);\n        } else {\n          refresh('m');\n        }\n      } else {\n        invalidate(undefined, true);\n      }\n    };\n\n    minutesInputEl.on('blur', function(e) {\n      ngModelCtrl.$setTouched();\n      if (modelIsEmpty()) {\n        makeValid();\n      } else if ($scope.minutes === null) {\n        invalidate(undefined, true);\n      } else if (!$scope.invalidMinutes && $scope.minutes < 10) {\n        $scope.$apply(function() {\n          $scope.minutes = pad($scope.minutes);\n        });\n      }\n    });\n\n    $scope.updateSeconds = function() {\n      var seconds = getSecondsFromTemplate();\n\n      ngModelCtrl.$setDirty();\n\n      if (angular.isDefined(seconds)) {\n        selected.setSeconds(seconds);\n        refresh('s');\n      } else {\n        invalidate(undefined, undefined, true);\n      }\n    };\n\n    secondsInputEl.on('blur', function(e) {\n      if (modelIsEmpty()) {\n        makeValid();\n      } else if (!$scope.invalidSeconds && $scope.seconds < 10) {\n        $scope.$apply( function() {\n          $scope.seconds = pad($scope.seconds);\n        });\n      }\n    });\n\n  };\n\n  this.render = function() {\n    var date = ngModelCtrl.$viewValue;\n\n    if (isNaN(date)) {\n      ngModelCtrl.$setValidity('time', false);\n      $log.error('Timepicker directive: \"ng-model\" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.');\n    } else {\n      if (date) {\n        selected = date;\n      }\n\n      if (selected < min || selected > max) {\n        ngModelCtrl.$setValidity('time', false);\n        $scope.invalidHours = true;\n        $scope.invalidMinutes = true;\n      } else {\n        makeValid();\n      }\n      updateTemplate();\n    }\n  };\n\n  // Call internally when we know that model is valid.\n  function refresh(keyboardChange) {\n    makeValid();\n    ngModelCtrl.$setViewValue(new Date(selected));\n    updateTemplate(keyboardChange);\n  }\n\n  function makeValid() {\n    if (hoursModelCtrl) {\n      hoursModelCtrl.$setValidity('hours', true);\n    }\n\n    if (minutesModelCtrl) {\n      minutesModelCtrl.$setValidity('minutes', true);\n    }\n\n    if (secondsModelCtrl) {\n      secondsModelCtrl.$setValidity('seconds', true);\n    }\n\n    ngModelCtrl.$setValidity('time', true);\n    $scope.invalidHours = false;\n    $scope.invalidMinutes = false;\n    $scope.invalidSeconds = false;\n  }\n\n  function updateTemplate(keyboardChange) {\n    if (!ngModelCtrl.$modelValue) {\n      $scope.hours = null;\n      $scope.minutes = null;\n      $scope.seconds = null;\n      $scope.meridian = meridians[0];\n    } else {\n      var hours = selected.getHours(),\n        minutes = selected.getMinutes(),\n        seconds = selected.getSeconds();\n\n      if ($scope.showMeridian) {\n        hours = hours === 0 || hours === 12 ? 12 : hours % 12; // Convert 24 to 12 hour system\n      }\n\n      $scope.hours = keyboardChange === 'h' ? hours : pad(hours, !padHours);\n      if (keyboardChange !== 'm') {\n        $scope.minutes = pad(minutes);\n      }\n      $scope.meridian = selected.getHours() < 12 ? meridians[0] : meridians[1];\n\n      if (keyboardChange !== 's') {\n        $scope.seconds = pad(seconds);\n      }\n      $scope.meridian = selected.getHours() < 12 ? meridians[0] : meridians[1];\n    }\n  }\n\n  function addSecondsToSelected(seconds) {\n    selected = addSeconds(selected, seconds);\n    refresh();\n  }\n\n  function addMinutes(selected, minutes) {\n    return addSeconds(selected, minutes*60);\n  }\n\n  function addSeconds(date, seconds) {\n    var dt = new Date(date.getTime() + seconds * 1000);\n    var newDate = new Date(date);\n    newDate.setHours(dt.getHours(), dt.getMinutes(), dt.getSeconds());\n    return newDate;\n  }\n\n  function modelIsEmpty() {\n    return ($scope.hours === null || $scope.hours === '') &&\n      ($scope.minutes === null || $scope.minutes === '') &&\n      (!$scope.showSeconds || $scope.showSeconds && ($scope.seconds === null || $scope.seconds === ''));\n  }\n\n  $scope.showSpinners = angular.isDefined($attrs.showSpinners) ?\n    $scope.$parent.$eval($attrs.showSpinners) : timepickerConfig.showSpinners;\n\n  $scope.incrementHours = function() {\n    if (!$scope.noIncrementHours()) {\n      addSecondsToSelected(hourStep * 60 * 60);\n    }\n  };\n\n  $scope.decrementHours = function() {\n    if (!$scope.noDecrementHours()) {\n      addSecondsToSelected(-hourStep * 60 * 60);\n    }\n  };\n\n  $scope.incrementMinutes = function() {\n    if (!$scope.noIncrementMinutes()) {\n      addSecondsToSelected(minuteStep * 60);\n    }\n  };\n\n  $scope.decrementMinutes = function() {\n    if (!$scope.noDecrementMinutes()) {\n      addSecondsToSelected(-minuteStep * 60);\n    }\n  };\n\n  $scope.incrementSeconds = function() {\n    if (!$scope.noIncrementSeconds()) {\n      addSecondsToSelected(secondStep);\n    }\n  };\n\n  $scope.decrementSeconds = function() {\n    if (!$scope.noDecrementSeconds()) {\n      addSecondsToSelected(-secondStep);\n    }\n  };\n\n  $scope.toggleMeridian = function() {\n    var minutes = getMinutesFromTemplate(),\n        hours = getHoursFromTemplate();\n\n    if (!$scope.noToggleMeridian()) {\n      if (angular.isDefined(minutes) && angular.isDefined(hours)) {\n        addSecondsToSelected(12 * 60 * (selected.getHours() < 12 ? 60 : -60));\n      } else {\n        $scope.meridian = $scope.meridian === meridians[0] ? meridians[1] : meridians[0];\n      }\n    }\n  };\n\n  $scope.blur = function() {\n    ngModelCtrl.$setTouched();\n  };\n\n  $scope.$on('$destroy', function() {\n    while (watchers.length) {\n      watchers.shift()();\n    }\n  });\n}])\n\n.directive('uibTimepicker', ['uibTimepickerConfig', function(uibTimepickerConfig) {\n  return {\n    require: ['uibTimepicker', '?^ngModel'],\n    restrict: 'A',\n    controller: 'UibTimepickerController',\n    controllerAs: 'timepicker',\n    scope: {},\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || uibTimepickerConfig.templateUrl;\n    },\n    link: function(scope, element, attrs, ctrls) {\n      var timepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\n      if (ngModelCtrl) {\n        timepickerCtrl.init(ngModelCtrl, element.find('input'));\n      }\n    }\n  };\n}]);\n\nangular.module('ui.bootstrap.typeahead', ['ui.bootstrap.debounce', 'ui.bootstrap.position'])\n\n/**\n * A helper service that can parse typeahead's syntax (string provided by users)\n * Extracted to a separate service for ease of unit testing\n */\n  .factory('uibTypeaheadParser', ['$parse', function($parse) {\n    //                      000001111111100000000000002222222200000000000000003333333333333330000000000044444444000\n    var TYPEAHEAD_REGEXP = /^\\s*([\\s\\S]+?)(?:\\s+as\\s+([\\s\\S]+?))?\\s+for\\s+(?:([\\$\\w][\\$\\w\\d]*))\\s+in\\s+([\\s\\S]+?)$/;\n    return {\n      parse: function(input) {\n        var match = input.match(TYPEAHEAD_REGEXP);\n        if (!match) {\n          throw new Error(\n            'Expected typeahead specification in form of \"_modelValue_ (as _label_)? for _item_ in _collection_\"' +\n              ' but got \"' + input + '\".');\n        }\n\n        return {\n          itemName: match[3],\n          source: $parse(match[4]),\n          viewMapper: $parse(match[2] || match[1]),\n          modelMapper: $parse(match[1])\n        };\n      }\n    };\n  }])\n\n  .controller('UibTypeaheadController', ['$scope', '$element', '$attrs', '$compile', '$parse', '$q', '$timeout', '$document', '$window', '$rootScope', '$$debounce', '$uibPosition', 'uibTypeaheadParser',\n    function(originalScope, element, attrs, $compile, $parse, $q, $timeout, $document, $window, $rootScope, $$debounce, $position, typeaheadParser) {\n    var HOT_KEYS = [9, 13, 27, 38, 40];\n    var eventDebounceTime = 200;\n    var modelCtrl, ngModelOptions;\n    //SUPPORTED ATTRIBUTES (OPTIONS)\n\n    //minimal no of characters that needs to be entered before typeahead kicks-in\n    var minLength = originalScope.$eval(attrs.typeaheadMinLength);\n    if (!minLength && minLength !== 0) {\n      minLength = 1;\n    }\n\n    originalScope.$watch(attrs.typeaheadMinLength, function (newVal) {\n        minLength = !newVal && newVal !== 0 ? 1 : newVal;\n    });\n\n    //minimal wait time after last character typed before typeahead kicks-in\n    var waitTime = originalScope.$eval(attrs.typeaheadWaitMs) || 0;\n\n    //should it restrict model values to the ones selected from the popup only?\n    var isEditable = originalScope.$eval(attrs.typeaheadEditable) !== false;\n    originalScope.$watch(attrs.typeaheadEditable, function (newVal) {\n      isEditable = newVal !== false;\n    });\n\n    //binding to a variable that indicates if matches are being retrieved asynchronously\n    var isLoadingSetter = $parse(attrs.typeaheadLoading).assign || angular.noop;\n\n    //a function to determine if an event should cause selection\n    var isSelectEvent = attrs.typeaheadShouldSelect ? $parse(attrs.typeaheadShouldSelect) : function(scope, vals) {\n      var evt = vals.$event;\n      return evt.which === 13 || evt.which === 9;\n    };\n\n    //a callback executed when a match is selected\n    var onSelectCallback = $parse(attrs.typeaheadOnSelect);\n\n    //should it select highlighted popup value when losing focus?\n    var isSelectOnBlur = angular.isDefined(attrs.typeaheadSelectOnBlur) ? originalScope.$eval(attrs.typeaheadSelectOnBlur) : false;\n\n    //binding to a variable that indicates if there were no results after the query is completed\n    var isNoResultsSetter = $parse(attrs.typeaheadNoResults).assign || angular.noop;\n\n    var inputFormatter = attrs.typeaheadInputFormatter ? $parse(attrs.typeaheadInputFormatter) : undefined;\n\n    var appendToBody = attrs.typeaheadAppendToBody ? originalScope.$eval(attrs.typeaheadAppendToBody) : false;\n\n    var appendTo = attrs.typeaheadAppendTo ?\n      originalScope.$eval(attrs.typeaheadAppendTo) : null;\n\n    var focusFirst = originalScope.$eval(attrs.typeaheadFocusFirst) !== false;\n\n    //If input matches an item of the list exactly, select it automatically\n    var selectOnExact = attrs.typeaheadSelectOnExact ? originalScope.$eval(attrs.typeaheadSelectOnExact) : false;\n\n    //binding to a variable that indicates if dropdown is open\n    var isOpenSetter = $parse(attrs.typeaheadIsOpen).assign || angular.noop;\n\n    var showHint = originalScope.$eval(attrs.typeaheadShowHint) || false;\n\n    //INTERNAL VARIABLES\n\n    //model setter executed upon match selection\n    var parsedModel = $parse(attrs.ngModel);\n    var invokeModelSetter = $parse(attrs.ngModel + '($$$p)');\n    var $setModelValue = function(scope, newValue) {\n      if (angular.isFunction(parsedModel(originalScope)) &&\n        ngModelOptions.getOption('getterSetter')) {\n        return invokeModelSetter(scope, {$$$p: newValue});\n      }\n\n      return parsedModel.assign(scope, newValue);\n    };\n\n    //expressions used by typeahead\n    var parserResult = typeaheadParser.parse(attrs.uibTypeahead);\n\n    var hasFocus;\n\n    //Used to avoid bug in iOS webview where iOS keyboard does not fire\n    //mousedown & mouseup events\n    //Issue #3699\n    var selected;\n\n    //create a child scope for the typeahead directive so we are not polluting original scope\n    //with typeahead-specific data (matches, query etc.)\n    var scope = originalScope.$new();\n    var offDestroy = originalScope.$on('$destroy', function() {\n      scope.$destroy();\n    });\n    scope.$on('$destroy', offDestroy);\n\n    // WAI-ARIA\n    var popupId = 'typeahead-' + scope.$id + '-' + Math.floor(Math.random() * 10000);\n    element.attr({\n      'aria-autocomplete': 'list',\n      'aria-expanded': false,\n      'aria-owns': popupId\n    });\n\n    var inputsContainer, hintInputElem;\n    //add read-only input to show hint\n    if (showHint) {\n      inputsContainer = angular.element('<div></div>');\n      inputsContainer.css('position', 'relative');\n      element.after(inputsContainer);\n      hintInputElem = element.clone();\n      hintInputElem.attr('placeholder', '');\n      hintInputElem.attr('tabindex', '-1');\n      hintInputElem.val('');\n      hintInputElem.css({\n        'position': 'absolute',\n        'top': '0px',\n        'left': '0px',\n        'border-color': 'transparent',\n        'box-shadow': 'none',\n        'opacity': 1,\n        'background': 'none 0% 0% / auto repeat scroll padding-box border-box rgb(255, 255, 255)',\n        'color': '#999'\n      });\n      element.css({\n        'position': 'relative',\n        'vertical-align': 'top',\n        'background-color': 'transparent'\n      });\n\n      if (hintInputElem.attr('id')) {\n        hintInputElem.removeAttr('id'); // remove duplicate id if present.\n      }\n      inputsContainer.append(hintInputElem);\n      hintInputElem.after(element);\n    }\n\n    //pop-up element used to display matches\n    var popUpEl = angular.element('<div uib-typeahead-popup></div>');\n    popUpEl.attr({\n      id: popupId,\n      matches: 'matches',\n      active: 'activeIdx',\n      select: 'select(activeIdx, evt)',\n      'move-in-progress': 'moveInProgress',\n      query: 'query',\n      position: 'position',\n      'assign-is-open': 'assignIsOpen(isOpen)',\n      debounce: 'debounceUpdate'\n    });\n    //custom item template\n    if (angular.isDefined(attrs.typeaheadTemplateUrl)) {\n      popUpEl.attr('template-url', attrs.typeaheadTemplateUrl);\n    }\n\n    if (angular.isDefined(attrs.typeaheadPopupTemplateUrl)) {\n      popUpEl.attr('popup-template-url', attrs.typeaheadPopupTemplateUrl);\n    }\n\n    var resetHint = function() {\n      if (showHint) {\n        hintInputElem.val('');\n      }\n    };\n\n    var resetMatches = function() {\n      scope.matches = [];\n      scope.activeIdx = -1;\n      element.attr('aria-expanded', false);\n      resetHint();\n    };\n\n    var getMatchId = function(index) {\n      return popupId + '-option-' + index;\n    };\n\n    // Indicate that the specified match is the active (pre-selected) item in the list owned by this typeahead.\n    // This attribute is added or removed automatically when the `activeIdx` changes.\n    scope.$watch('activeIdx', function(index) {\n      if (index < 0) {\n        element.removeAttr('aria-activedescendant');\n      } else {\n        element.attr('aria-activedescendant', getMatchId(index));\n      }\n    });\n\n    var inputIsExactMatch = function(inputValue, index) {\n      if (scope.matches.length > index && inputValue) {\n        return inputValue.toUpperCase() === scope.matches[index].label.toUpperCase();\n      }\n\n      return false;\n    };\n\n    var getMatchesAsync = function(inputValue, evt) {\n      var locals = {$viewValue: inputValue};\n      isLoadingSetter(originalScope, true);\n      isNoResultsSetter(originalScope, false);\n      $q.when(parserResult.source(originalScope, locals)).then(function(matches) {\n        //it might happen that several async queries were in progress if a user were typing fast\n        //but we are interested only in responses that correspond to the current view value\n        var onCurrentRequest = inputValue === modelCtrl.$viewValue;\n        if (onCurrentRequest && hasFocus) {\n          if (matches && matches.length > 0) {\n            scope.activeIdx = focusFirst ? 0 : -1;\n            isNoResultsSetter(originalScope, false);\n            scope.matches.length = 0;\n\n            //transform labels\n            for (var i = 0; i < matches.length; i++) {\n              locals[parserResult.itemName] = matches[i];\n              scope.matches.push({\n                id: getMatchId(i),\n                label: parserResult.viewMapper(scope, locals),\n                model: matches[i]\n              });\n            }\n\n            scope.query = inputValue;\n            //position pop-up with matches - we need to re-calculate its position each time we are opening a window\n            //with matches as a pop-up might be absolute-positioned and position of an input might have changed on a page\n            //due to other elements being rendered\n            recalculatePosition();\n\n            element.attr('aria-expanded', true);\n\n            //Select the single remaining option if user input matches\n            if (selectOnExact && scope.matches.length === 1 && inputIsExactMatch(inputValue, 0)) {\n              if (angular.isNumber(scope.debounceUpdate) || angular.isObject(scope.debounceUpdate)) {\n                $$debounce(function() {\n                  scope.select(0, evt);\n                }, angular.isNumber(scope.debounceUpdate) ? scope.debounceUpdate : scope.debounceUpdate['default']);\n              } else {\n                scope.select(0, evt);\n              }\n            }\n\n            if (showHint) {\n              var firstLabel = scope.matches[0].label;\n              if (angular.isString(inputValue) &&\n                inputValue.length > 0 &&\n                firstLabel.slice(0, inputValue.length).toUpperCase() === inputValue.toUpperCase()) {\n                hintInputElem.val(inputValue + firstLabel.slice(inputValue.length));\n              } else {\n                hintInputElem.val('');\n              }\n            }\n          } else {\n            resetMatches();\n            isNoResultsSetter(originalScope, true);\n          }\n        }\n        if (onCurrentRequest) {\n          isLoadingSetter(originalScope, false);\n        }\n      }, function() {\n        resetMatches();\n        isLoadingSetter(originalScope, false);\n        isNoResultsSetter(originalScope, true);\n      });\n    };\n\n    // bind events only if appendToBody params exist - performance feature\n    if (appendToBody) {\n      angular.element($window).on('resize', fireRecalculating);\n      $document.find('body').on('scroll', fireRecalculating);\n    }\n\n    // Declare the debounced function outside recalculating for\n    // proper debouncing\n    var debouncedRecalculate = $$debounce(function() {\n      // if popup is visible\n      if (scope.matches.length) {\n        recalculatePosition();\n      }\n\n      scope.moveInProgress = false;\n    }, eventDebounceTime);\n\n    // Default progress type\n    scope.moveInProgress = false;\n\n    function fireRecalculating() {\n      if (!scope.moveInProgress) {\n        scope.moveInProgress = true;\n        scope.$digest();\n      }\n\n      debouncedRecalculate();\n    }\n\n    // recalculate actual position and set new values to scope\n    // after digest loop is popup in right position\n    function recalculatePosition() {\n      scope.position = appendToBody ? $position.offset(element) : $position.position(element);\n      scope.position.top += element.prop('offsetHeight');\n    }\n\n    //we need to propagate user's query so we can higlight matches\n    scope.query = undefined;\n\n    //Declare the timeout promise var outside the function scope so that stacked calls can be cancelled later\n    var timeoutPromise;\n\n    var scheduleSearchWithTimeout = function(inputValue) {\n      timeoutPromise = $timeout(function() {\n        getMatchesAsync(inputValue);\n      }, waitTime);\n    };\n\n    var cancelPreviousTimeout = function() {\n      if (timeoutPromise) {\n        $timeout.cancel(timeoutPromise);\n      }\n    };\n\n    resetMatches();\n\n    scope.assignIsOpen = function (isOpen) {\n      isOpenSetter(originalScope, isOpen);\n    };\n\n    scope.select = function(activeIdx, evt) {\n      //called from within the $digest() cycle\n      var locals = {};\n      var model, item;\n\n      selected = true;\n      locals[parserResult.itemName] = item = scope.matches[activeIdx].model;\n      model = parserResult.modelMapper(originalScope, locals);\n      $setModelValue(originalScope, model);\n      modelCtrl.$setValidity('editable', true);\n      modelCtrl.$setValidity('parse', true);\n\n      onSelectCallback(originalScope, {\n        $item: item,\n        $model: model,\n        $label: parserResult.viewMapper(originalScope, locals),\n        $event: evt\n      });\n\n      resetMatches();\n\n      //return focus to the input element if a match was selected via a mouse click event\n      // use timeout to avoid $rootScope:inprog error\n      if (scope.$eval(attrs.typeaheadFocusOnSelect) !== false) {\n        $timeout(function() { element[0].focus(); }, 0, false);\n      }\n    };\n\n    //bind keyboard events: arrows up(38) / down(40), enter(13) and tab(9), esc(27)\n    element.on('keydown', function(evt) {\n      //typeahead is open and an \"interesting\" key was pressed\n      if (scope.matches.length === 0 || HOT_KEYS.indexOf(evt.which) === -1) {\n        return;\n      }\n\n      var shouldSelect = isSelectEvent(originalScope, {$event: evt});\n\n      /**\n       * if there's nothing selected (i.e. focusFirst) and enter or tab is hit\n       * or\n       * shift + tab is pressed to bring focus to the previous element\n       * then clear the results\n       */\n      if (scope.activeIdx === -1 && shouldSelect || evt.which === 9 && !!evt.shiftKey) {\n        resetMatches();\n        scope.$digest();\n        return;\n      }\n\n      evt.preventDefault();\n      var target;\n      switch (evt.which) {\n        case 27: // escape\n          evt.stopPropagation();\n\n          resetMatches();\n          originalScope.$digest();\n          break;\n        case 38: // up arrow\n          scope.activeIdx = (scope.activeIdx > 0 ? scope.activeIdx : scope.matches.length) - 1;\n          scope.$digest();\n          target = popUpEl[0].querySelectorAll('.uib-typeahead-match')[scope.activeIdx];\n          target.parentNode.scrollTop = target.offsetTop;\n          break;\n        case 40: // down arrow\n          scope.activeIdx = (scope.activeIdx + 1) % scope.matches.length;\n          scope.$digest();\n          target = popUpEl[0].querySelectorAll('.uib-typeahead-match')[scope.activeIdx];\n          target.parentNode.scrollTop = target.offsetTop;\n          break;\n        default:\n          if (shouldSelect) {\n            scope.$apply(function() {\n              if (angular.isNumber(scope.debounceUpdate) || angular.isObject(scope.debounceUpdate)) {\n                $$debounce(function() {\n                  scope.select(scope.activeIdx, evt);\n                }, angular.isNumber(scope.debounceUpdate) ? scope.debounceUpdate : scope.debounceUpdate['default']);\n              } else {\n                scope.select(scope.activeIdx, evt);\n              }\n            });\n          }\n      }\n    });\n\n    element.on('focus', function (evt) {\n      hasFocus = true;\n      if (minLength === 0 && !modelCtrl.$viewValue) {\n        $timeout(function() {\n          getMatchesAsync(modelCtrl.$viewValue, evt);\n        }, 0);\n      }\n    });\n\n    element.on('blur', function(evt) {\n      if (isSelectOnBlur && scope.matches.length && scope.activeIdx !== -1 && !selected) {\n        selected = true;\n        scope.$apply(function() {\n          if (angular.isObject(scope.debounceUpdate) && angular.isNumber(scope.debounceUpdate.blur)) {\n            $$debounce(function() {\n              scope.select(scope.activeIdx, evt);\n            }, scope.debounceUpdate.blur);\n          } else {\n            scope.select(scope.activeIdx, evt);\n          }\n        });\n      }\n      if (!isEditable && modelCtrl.$error.editable) {\n        modelCtrl.$setViewValue();\n        scope.$apply(function() {\n          // Reset validity as we are clearing\n          modelCtrl.$setValidity('editable', true);\n          modelCtrl.$setValidity('parse', true);\n        });\n        element.val('');\n      }\n      hasFocus = false;\n      selected = false;\n    });\n\n    // Keep reference to click handler to unbind it.\n    var dismissClickHandler = function(evt) {\n      // Issue #3973\n      // Firefox treats right click as a click on document\n      if (element[0] !== evt.target && evt.which !== 3 && scope.matches.length !== 0) {\n        resetMatches();\n        if (!$rootScope.$$phase) {\n          originalScope.$digest();\n        }\n      }\n    };\n\n    $document.on('click', dismissClickHandler);\n\n    originalScope.$on('$destroy', function() {\n      $document.off('click', dismissClickHandler);\n      if (appendToBody || appendTo) {\n        $popup.remove();\n      }\n\n      if (appendToBody) {\n        angular.element($window).off('resize', fireRecalculating);\n        $document.find('body').off('scroll', fireRecalculating);\n      }\n      // Prevent jQuery cache memory leak\n      popUpEl.remove();\n\n      if (showHint) {\n          inputsContainer.remove();\n      }\n    });\n\n    var $popup = $compile(popUpEl)(scope);\n\n    if (appendToBody) {\n      $document.find('body').append($popup);\n    } else if (appendTo) {\n      angular.element(appendTo).eq(0).append($popup);\n    } else {\n      element.after($popup);\n    }\n\n    this.init = function(_modelCtrl) {\n      modelCtrl = _modelCtrl;\n      ngModelOptions = extractOptions(modelCtrl);\n\n      scope.debounceUpdate = $parse(ngModelOptions.getOption('debounce'))(originalScope);\n\n      //plug into $parsers pipeline to open a typeahead on view changes initiated from DOM\n      //$parsers kick-in on all the changes coming from the view as well as manually triggered by $setViewValue\n      modelCtrl.$parsers.unshift(function(inputValue) {\n        hasFocus = true;\n\n        if (minLength === 0 || inputValue && inputValue.length >= minLength) {\n          if (waitTime > 0) {\n            cancelPreviousTimeout();\n            scheduleSearchWithTimeout(inputValue);\n          } else {\n            getMatchesAsync(inputValue);\n          }\n        } else {\n          isLoadingSetter(originalScope, false);\n          cancelPreviousTimeout();\n          resetMatches();\n        }\n\n        if (isEditable) {\n          return inputValue;\n        }\n\n        if (!inputValue) {\n          // Reset in case user had typed something previously.\n          modelCtrl.$setValidity('editable', true);\n          return null;\n        }\n\n        modelCtrl.$setValidity('editable', false);\n        return undefined;\n      });\n\n      modelCtrl.$formatters.push(function(modelValue) {\n        var candidateViewValue, emptyViewValue;\n        var locals = {};\n\n        // The validity may be set to false via $parsers (see above) if\n        // the model is restricted to selected values. If the model\n        // is set manually it is considered to be valid.\n        if (!isEditable) {\n          modelCtrl.$setValidity('editable', true);\n        }\n\n        if (inputFormatter) {\n          locals.$model = modelValue;\n          return inputFormatter(originalScope, locals);\n        }\n\n        //it might happen that we don't have enough info to properly render input value\n        //we need to check for this situation and simply return model value if we can't apply custom formatting\n        locals[parserResult.itemName] = modelValue;\n        candidateViewValue = parserResult.viewMapper(originalScope, locals);\n        locals[parserResult.itemName] = undefined;\n        emptyViewValue = parserResult.viewMapper(originalScope, locals);\n\n        return candidateViewValue !== emptyViewValue ? candidateViewValue : modelValue;\n      });\n    };\n\n    function extractOptions(ngModelCtrl) {\n      var ngModelOptions;\n\n      if (angular.version.minor < 6) { // in angular < 1.6 $options could be missing\n        // guarantee a value\n        ngModelOptions = ngModelCtrl.$options || {};\n\n        // mimic 1.6+ api\n        ngModelOptions.getOption = function (key) {\n          return ngModelOptions[key];\n        };\n      } else { // in angular >=1.6 $options is always present\n        ngModelOptions = ngModelCtrl.$options;\n      }\n\n      return ngModelOptions;\n    }\n  }])\n\n  .directive('uibTypeahead', function() {\n    return {\n      controller: 'UibTypeaheadController',\n      require: ['ngModel', 'uibTypeahead'],\n      link: function(originalScope, element, attrs, ctrls) {\n        ctrls[1].init(ctrls[0]);\n      }\n    };\n  })\n\n  .directive('uibTypeaheadPopup', ['$$debounce', function($$debounce) {\n    return {\n      scope: {\n        matches: '=',\n        query: '=',\n        active: '=',\n        position: '&',\n        moveInProgress: '=',\n        select: '&',\n        assignIsOpen: '&',\n        debounce: '&'\n      },\n      replace: true,\n      templateUrl: function(element, attrs) {\n        return attrs.popupTemplateUrl || 'uib/template/typeahead/typeahead-popup.html';\n      },\n      link: function(scope, element, attrs) {\n        scope.templateUrl = attrs.templateUrl;\n\n        scope.isOpen = function() {\n          var isDropdownOpen = scope.matches.length > 0;\n          scope.assignIsOpen({ isOpen: isDropdownOpen });\n          return isDropdownOpen;\n        };\n\n        scope.isActive = function(matchIdx) {\n          return scope.active === matchIdx;\n        };\n\n        scope.selectActive = function(matchIdx) {\n          scope.active = matchIdx;\n        };\n\n        scope.selectMatch = function(activeIdx, evt) {\n          var debounce = scope.debounce();\n          if (angular.isNumber(debounce) || angular.isObject(debounce)) {\n            $$debounce(function() {\n              scope.select({activeIdx: activeIdx, evt: evt});\n            }, angular.isNumber(debounce) ? debounce : debounce['default']);\n          } else {\n            scope.select({activeIdx: activeIdx, evt: evt});\n          }\n        };\n      }\n    };\n  }])\n\n  .directive('uibTypeaheadMatch', ['$templateRequest', '$compile', '$parse', function($templateRequest, $compile, $parse) {\n    return {\n      scope: {\n        index: '=',\n        match: '=',\n        query: '='\n      },\n      link: function(scope, element, attrs) {\n        var tplUrl = $parse(attrs.templateUrl)(scope.$parent) || 'uib/template/typeahead/typeahead-match.html';\n        $templateRequest(tplUrl).then(function(tplContent) {\n          var tplEl = angular.element(tplContent.trim());\n          element.replaceWith(tplEl);\n          $compile(tplEl)(scope);\n        });\n      }\n    };\n  }])\n\n  .filter('uibTypeaheadHighlight', ['$sce', '$injector', '$log', function($sce, $injector, $log) {\n    var isSanitizePresent;\n    isSanitizePresent = $injector.has('$sanitize');\n\n    function escapeRegexp(queryToEscape) {\n      // Regex: capture the whole query string and replace it with the string that will be used to match\n      // the results, for example if the capture is \"a\" the result will be \\a\n      return queryToEscape.replace(/([.?*+^$[\\]\\\\(){}|-])/g, '\\\\$1');\n    }\n\n    function containsHtml(matchItem) {\n      return /<.*>/g.test(matchItem);\n    }\n\n    return function(matchItem, query) {\n      if (!isSanitizePresent && containsHtml(matchItem)) {\n        $log.warn('Unsafe use of typeahead please use ngSanitize'); // Warn the user about the danger\n      }\n      matchItem = query ? ('' + matchItem).replace(new RegExp(escapeRegexp(query), 'gi'), '<strong>$&</strong>') : matchItem; // Replaces the capture string with a the same string inside of a \"strong\" tag\n      if (!isSanitizePresent) {\n        matchItem = $sce.trustAsHtml(matchItem); // If $sanitize is not present we pack the string in a $sce object for the ng-bind-html directive\n      }\n      return matchItem;\n    };\n  }]);\n\nangular.module(\"uib/template/accordion/accordion-group.html\", []).run([\"$templateCache\", function ($templateCache) {\n  $templateCache.put(\"uib/template/accordion/accordion-group.html\",\n    \"<div role=\\\"tab\\\" id=\\\"{{::headingId}}\\\" aria-selected=\\\"{{isOpen}}\\\" class=\\\"panel-heading\\\" ng-keypress=\\\"toggleOpen($event)\\\">\\n\" +\n    \"  <h4 class=\\\"panel-title\\\">\\n\" +\n    \"    <a role=\\\"button\\\" data-toggle=\\\"collapse\\\" href aria-expanded=\\\"{{isOpen}}\\\" aria-controls=\\\"{{::panelId}}\\\" tabindex=\\\"0\\\" class=\\\"accordion-toggle\\\" ng-click=\\\"toggleOpen()\\\" uib-accordion-transclude=\\\"heading\\\" ng-disabled=\\\"isDisabled\\\" uib-tabindex-toggle><span uib-accordion-header ng-class=\\\"{'text-muted': isDisabled}\\\">{{heading}}</span></a>\\n\" +\n    \"  </h4>\\n\" +\n    \"</div>\\n\" +\n    \"<div id=\\\"{{::panelId}}\\\" aria-labelledby=\\\"{{::headingId}}\\\" aria-hidden=\\\"{{!isOpen}}\\\" role=\\\"tabpanel\\\" class=\\\"panel-collapse collapse\\\" uib-collapse=\\\"!isOpen\\\">\\n\" +\n    \"  <div class=\\\"panel-body\\\" ng-transclude></div>\\n\" +\n    \"</div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/accordion/accordion.html\", []).run([\"$templateCache\", function ($templateCache) {\n  $templateCache.put(\"uib/template/accordion/accordion.html\",\n    \"<div role=\\\"tablist\\\" class=\\\"panel-group\\\" ng-transclude></div>\");\n}]);\n\nangular.module(\"uib/template/alert/alert.html\", []).run([\"$templateCache\", function ($templateCache) {\n  $templateCache.put(\"uib/template/alert/alert.html\",\n    \"<button ng-show=\\\"closeable\\\" type=\\\"button\\\" class=\\\"close\\\" ng-click=\\\"close({$event: $event})\\\">\\n\" +\n    \"  <span aria-hidden=\\\"true\\\">&times;</span>\\n\" +\n    \"  <span class=\\\"sr-only\\\">Close</span>\\n\" +\n    \"</button>\\n\" +\n    \"<div ng-transclude></div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/carousel/carousel.html\", []).run([\"$templateCache\", function ($templateCache) {\n  $templateCache.put(\"uib/template/carousel/carousel.html\",\n    \"<div class=\\\"carousel-inner\\\" ng-transclude></div>\\n\" +\n    \"<a role=\\\"button\\\" href class=\\\"left carousel-control\\\" ng-click=\\\"prev()\\\" ng-class=\\\"{ disabled: isPrevDisabled() }\\\" ng-show=\\\"slides.length > 1\\\">\\n\" +\n    \"  <span aria-hidden=\\\"true\\\" class=\\\"glyphicon glyphicon-chevron-left\\\"></span>\\n\" +\n    \"  <span class=\\\"sr-only\\\">previous</span>\\n\" +\n    \"</a>\\n\" +\n    \"<a role=\\\"button\\\" href class=\\\"right carousel-control\\\" ng-click=\\\"next()\\\" ng-class=\\\"{ disabled: isNextDisabled() }\\\" ng-show=\\\"slides.length > 1\\\">\\n\" +\n    \"  <span aria-hidden=\\\"true\\\" class=\\\"glyphicon glyphicon-chevron-right\\\"></span>\\n\" +\n    \"  <span class=\\\"sr-only\\\">next</span>\\n\" +\n    \"</a>\\n\" +\n    \"<ol class=\\\"carousel-indicators\\\" ng-show=\\\"slides.length > 1\\\">\\n\" +\n    \"  <li ng-repeat=\\\"slide in slides | orderBy:indexOfSlide track by $index\\\" ng-class=\\\"{ active: isActive(slide) }\\\" ng-click=\\\"select(slide)\\\">\\n\" +\n    \"    <span class=\\\"sr-only\\\">slide {{ $index + 1 }} of {{ slides.length }}<span ng-if=\\\"isActive(slide)\\\">, currently active</span></span>\\n\" +\n    \"  </li>\\n\" +\n    \"</ol>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/carousel/slide.html\", []).run([\"$templateCache\", function ($templateCache) {\n  $templateCache.put(\"uib/template/carousel/slide.html\",\n    \"<div class=\\\"text-center\\\" ng-transclude></div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/datepicker/datepicker.html\", []).run([\"$templateCache\", function ($templateCache) {\n  $templateCache.put(\"uib/template/datepicker/datepicker.html\",\n    \"<div ng-switch=\\\"datepickerMode\\\">\\n\" +\n    \"  <div uib-daypicker ng-switch-when=\\\"day\\\" tabindex=\\\"0\\\" class=\\\"uib-daypicker\\\"></div>\\n\" +\n    \"  <div uib-monthpicker ng-switch-when=\\\"month\\\" tabindex=\\\"0\\\" class=\\\"uib-monthpicker\\\"></div>\\n\" +\n    \"  <div uib-yearpicker ng-switch-when=\\\"year\\\" tabindex=\\\"0\\\" class=\\\"uib-yearpicker\\\"></div>\\n\" +\n    \"</div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/datepicker/day.html\", []).run([\"$templateCache\", function ($templateCache) {\n  $templateCache.put(\"uib/template/datepicker/day.html\",\n    \"<table role=\\\"grid\\\" aria-labelledby=\\\"{{::uniqueId}}-title\\\" aria-activedescendant=\\\"{{activeDateId}}\\\">\\n\" +\n    \"  <thead>\\n\" +\n    \"    <tr>\\n\" +\n    \"      <th><button type=\\\"button\\\" class=\\\"btn btn-default btn-sm pull-left uib-left\\\" ng-click=\\\"move(-1)\\\" tabindex=\\\"-1\\\"><i aria-hidden=\\\"true\\\" class=\\\"glyphicon glyphicon-chevron-left\\\"></i><span class=\\\"sr-only\\\">previous</span></button></th>\\n\" +\n    \"      <th colspan=\\\"{{::5 + showWeeks}}\\\"><button id=\\\"{{::uniqueId}}-title\\\" role=\\\"heading\\\" aria-live=\\\"assertive\\\" aria-atomic=\\\"true\\\" type=\\\"button\\\" class=\\\"btn btn-default btn-sm uib-title\\\" ng-click=\\\"toggleMode()\\\" ng-disabled=\\\"datepickerMode === maxMode\\\" tabindex=\\\"-1\\\"><strong>{{title}}</strong></button></th>\\n\" +\n    \"      <th><button type=\\\"button\\\" class=\\\"btn btn-default btn-sm pull-right uib-right\\\" ng-click=\\\"move(1)\\\" tabindex=\\\"-1\\\"><i aria-hidden=\\\"true\\\" class=\\\"glyphicon glyphicon-chevron-right\\\"></i><span class=\\\"sr-only\\\">next</span></button></th>\\n\" +\n    \"    </tr>\\n\" +\n    \"    <tr>\\n\" +\n    \"      <th ng-if=\\\"showWeeks\\\" class=\\\"text-center\\\"></th>\\n\" +\n    \"      <th ng-repeat=\\\"label in ::labels track by $index\\\" class=\\\"text-center\\\"><small aria-label=\\\"{{::label.full}}\\\">{{::label.abbr}}</small></th>\\n\" +\n    \"    </tr>\\n\" +\n    \"  </thead>\\n\" +\n    \"  <tbody>\\n\" +\n    \"    <tr class=\\\"uib-weeks\\\" ng-repeat=\\\"row in rows track by $index\\\" role=\\\"row\\\">\\n\" +\n    \"      <td ng-if=\\\"showWeeks\\\" class=\\\"text-center h6\\\"><em>{{ weekNumbers[$index] }}</em></td>\\n\" +\n    \"      <td ng-repeat=\\\"dt in row\\\" class=\\\"uib-day text-center\\\" role=\\\"gridcell\\\"\\n\" +\n    \"        id=\\\"{{::dt.uid}}\\\"\\n\" +\n    \"        ng-class=\\\"::dt.customClass\\\">\\n\" +\n    \"        <button type=\\\"button\\\" class=\\\"btn btn-default btn-sm\\\"\\n\" +\n    \"          uib-is-class=\\\"\\n\" +\n    \"            'btn-info' for selectedDt,\\n\" +\n    \"            'active' for activeDt\\n\" +\n    \"            on dt\\\"\\n\" +\n    \"          ng-click=\\\"select(dt.date)\\\"\\n\" +\n    \"          ng-disabled=\\\"::dt.disabled\\\"\\n\" +\n    \"          tabindex=\\\"-1\\\"><span ng-class=\\\"::{'text-muted': dt.secondary, 'text-info': dt.current}\\\">{{::dt.label}}</span></button>\\n\" +\n    \"      </td>\\n\" +\n    \"    </tr>\\n\" +\n    \"  </tbody>\\n\" +\n    \"</table>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/datepicker/month.html\", []).run([\"$templateCache\", function ($templateCache) {\n  $templateCache.put(\"uib/template/datepicker/month.html\",\n    \"<table role=\\\"grid\\\" aria-labelledby=\\\"{{::uniqueId}}-title\\\" aria-activedescendant=\\\"{{activeDateId}}\\\">\\n\" +\n    \"  <thead>\\n\" +\n    \"    <tr>\\n\" +\n    \"      <th><button type=\\\"button\\\" class=\\\"btn btn-default btn-sm pull-left uib-left\\\" ng-click=\\\"move(-1)\\\" tabindex=\\\"-1\\\"><i aria-hidden=\\\"true\\\" class=\\\"glyphicon glyphicon-chevron-left\\\"></i><span class=\\\"sr-only\\\">previous</span></button></th>\\n\" +\n    \"      <th colspan=\\\"{{::yearHeaderColspan}}\\\"><button id=\\\"{{::uniqueId}}-title\\\" role=\\\"heading\\\" aria-live=\\\"assertive\\\" aria-atomic=\\\"true\\\" type=\\\"button\\\" class=\\\"btn btn-default btn-sm uib-title\\\" ng-click=\\\"toggleMode()\\\" ng-disabled=\\\"datepickerMode === maxMode\\\" tabindex=\\\"-1\\\"><strong>{{title}}</strong></button></th>\\n\" +\n    \"      <th><button type=\\\"button\\\" class=\\\"btn btn-default btn-sm pull-right uib-right\\\" ng-click=\\\"move(1)\\\" tabindex=\\\"-1\\\"><i aria-hidden=\\\"true\\\" class=\\\"glyphicon glyphicon-chevron-right\\\"></i><span class=\\\"sr-only\\\">next</span></i></button></th>\\n\" +\n    \"    </tr>\\n\" +\n    \"  </thead>\\n\" +\n    \"  <tbody>\\n\" +\n    \"    <tr class=\\\"uib-months\\\" ng-repeat=\\\"row in rows track by $index\\\" role=\\\"row\\\">\\n\" +\n    \"      <td ng-repeat=\\\"dt in row\\\" class=\\\"uib-month text-center\\\" role=\\\"gridcell\\\"\\n\" +\n    \"        id=\\\"{{::dt.uid}}\\\"\\n\" +\n    \"        ng-class=\\\"::dt.customClass\\\">\\n\" +\n    \"        <button type=\\\"button\\\" class=\\\"btn btn-default\\\"\\n\" +\n    \"          uib-is-class=\\\"\\n\" +\n    \"            'btn-info' for selectedDt,\\n\" +\n    \"            'active' for activeDt\\n\" +\n    \"            on dt\\\"\\n\" +\n    \"          ng-click=\\\"select(dt.date)\\\"\\n\" +\n    \"          ng-disabled=\\\"::dt.disabled\\\"\\n\" +\n    \"          tabindex=\\\"-1\\\"><span ng-class=\\\"::{'text-info': dt.current}\\\">{{::dt.label}}</span></button>\\n\" +\n    \"      </td>\\n\" +\n    \"    </tr>\\n\" +\n    \"  </tbody>\\n\" +\n    \"</table>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/datepicker/popup.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"uib/template/datepicker/popup.html\",\n    \"<div>\\n\" +\n    \"  <ul class=\\\"uib-datepicker-popup dropdown-menu uib-position-measure\\\" dropdown-nested ng-if=\\\"isOpen\\\" ng-keydown=\\\"keydown($event)\\\" ng-click=\\\"$event.stopPropagation()\\\">\\n\" +\n    \"    <li ng-transclude></li>\\n\" +\n    \"    <li ng-if=\\\"showButtonBar\\\" class=\\\"uib-button-bar\\\">\\n\" +\n    \"      <span class=\\\"btn-group pull-left\\\">\\n\" +\n    \"        <button type=\\\"button\\\" class=\\\"btn btn-sm btn-info uib-datepicker-current\\\" ng-click=\\\"select('today', $event)\\\" ng-disabled=\\\"isDisabled('today')\\\">{{ getText('current') }}</button>\\n\" +\n    \"        <button type=\\\"button\\\" class=\\\"btn btn-sm btn-danger uib-clear\\\" ng-click=\\\"select(null, $event)\\\">{{ getText('clear') }}</button>\\n\" +\n    \"      </span>\\n\" +\n    \"      <button type=\\\"button\\\" class=\\\"btn btn-sm btn-success pull-right uib-close\\\" ng-click=\\\"close($event)\\\">{{ getText('close') }}</button>\\n\" +\n    \"    </li>\\n\" +\n    \"  </ul>\\n\" +\n    \"</div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/datepicker/year.html\", []).run([\"$templateCache\", function ($templateCache) {\n  $templateCache.put(\"uib/template/datepicker/year.html\",\n    \"<table role=\\\"grid\\\" aria-labelledby=\\\"{{::uniqueId}}-title\\\" aria-activedescendant=\\\"{{activeDateId}}\\\">\\n\" +\n    \"  <thead>\\n\" +\n    \"    <tr>\\n\" +\n    \"      <th><button type=\\\"button\\\" class=\\\"btn btn-default btn-sm pull-left uib-left\\\" ng-click=\\\"move(-1)\\\" tabindex=\\\"-1\\\"><i aria-hidden=\\\"true\\\" class=\\\"glyphicon glyphicon-chevron-left\\\"></i><span class=\\\"sr-only\\\">previous</span></button></th>\\n\" +\n    \"      <th colspan=\\\"{{::columns - 2}}\\\"><button id=\\\"{{::uniqueId}}-title\\\" role=\\\"heading\\\" aria-live=\\\"assertive\\\" aria-atomic=\\\"true\\\" type=\\\"button\\\" class=\\\"btn btn-default btn-sm uib-title\\\" ng-click=\\\"toggleMode()\\\" ng-disabled=\\\"datepickerMode === maxMode\\\" tabindex=\\\"-1\\\"><strong>{{title}}</strong></button></th>\\n\" +\n    \"      <th><button type=\\\"button\\\" class=\\\"btn btn-default btn-sm pull-right uib-right\\\" ng-click=\\\"move(1)\\\" tabindex=\\\"-1\\\"><i aria-hidden=\\\"true\\\" class=\\\"glyphicon glyphicon-chevron-right\\\"></i><span class=\\\"sr-only\\\">next</span></button></th>\\n\" +\n    \"    </tr>\\n\" +\n    \"  </thead>\\n\" +\n    \"  <tbody>\\n\" +\n    \"    <tr class=\\\"uib-years\\\" ng-repeat=\\\"row in rows track by $index\\\" role=\\\"row\\\">\\n\" +\n    \"      <td ng-repeat=\\\"dt in row\\\" class=\\\"uib-year text-center\\\" role=\\\"gridcell\\\"\\n\" +\n    \"        id=\\\"{{::dt.uid}}\\\"\\n\" +\n    \"        ng-class=\\\"::dt.customClass\\\">\\n\" +\n    \"        <button type=\\\"button\\\" class=\\\"btn btn-default\\\"\\n\" +\n    \"          uib-is-class=\\\"\\n\" +\n    \"            'btn-info' for selectedDt,\\n\" +\n    \"            'active' for activeDt\\n\" +\n    \"            on dt\\\"\\n\" +\n    \"          ng-click=\\\"select(dt.date)\\\"\\n\" +\n    \"          ng-disabled=\\\"::dt.disabled\\\"\\n\" +\n    \"          tabindex=\\\"-1\\\"><span ng-class=\\\"::{'text-info': dt.current}\\\">{{::dt.label}}</span></button>\\n\" +\n    \"      </td>\\n\" +\n    \"    </tr>\\n\" +\n    \"  </tbody>\\n\" +\n    \"</table>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/datepickerPopup/popup.html\", []).run([\"$templateCache\", function ($templateCache) {\n  $templateCache.put(\"uib/template/datepickerPopup/popup.html\",\n    \"<ul role=\\\"presentation\\\" class=\\\"uib-datepicker-popup dropdown-menu uib-position-measure\\\" dropdown-nested ng-if=\\\"isOpen\\\" ng-keydown=\\\"keydown($event)\\\" ng-click=\\\"$event.stopPropagation()\\\">\\n\" +\n    \"  <li ng-transclude></li>\\n\" +\n    \"  <li ng-if=\\\"showButtonBar\\\" class=\\\"uib-button-bar\\\">\\n\" +\n    \"    <span class=\\\"btn-group pull-left\\\">\\n\" +\n    \"      <button type=\\\"button\\\" class=\\\"btn btn-sm btn-info uib-datepicker-current\\\" ng-click=\\\"select('today', $event)\\\" ng-disabled=\\\"isDisabled('today')\\\">{{ getText('current') }}</button>\\n\" +\n    \"      <button type=\\\"button\\\" class=\\\"btn btn-sm btn-danger uib-clear\\\" ng-click=\\\"select(null, $event)\\\">{{ getText('clear') }}</button>\\n\" +\n    \"    </span>\\n\" +\n    \"    <button type=\\\"button\\\" class=\\\"btn btn-sm btn-success pull-right uib-close\\\" ng-click=\\\"close($event)\\\">{{ getText('close') }}</button>\\n\" +\n    \"  </li>\\n\" +\n    \"</ul>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/modal/backdrop.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"uib/template/modal/backdrop.html\",\n    \"<div class=\\\"modal-backdrop\\\"\\n\" +\n    \"     uib-modal-animation-class=\\\"fade\\\"\\n\" +\n    \"     modal-in-class=\\\"in\\\"\\n\" +\n    \"     ng-style=\\\"{'z-index': 1040 + (index && 1 || 0) + index*10}\\\"\\n\" +\n    \"></div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/modal/window.html\", []).run([\"$templateCache\", function ($templateCache) {\n  $templateCache.put(\"uib/template/modal/window.html\",\n    \"<div class=\\\"modal-dialog {{size ? 'modal-' + size : ''}}\\\"><div class=\\\"modal-content\\\" uib-modal-transclude></div></div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/pager/pager.html\", []).run([\"$templateCache\", function ($templateCache) {\n  $templateCache.put(\"uib/template/pager/pager.html\",\n    \"<li ng-class=\\\"{disabled: noPrevious()||ngDisabled, previous: align}\\\"><a href ng-click=\\\"selectPage(page - 1, $event)\\\" ng-disabled=\\\"noPrevious()||ngDisabled\\\" uib-tabindex-toggle>{{::getText('previous')}}</a></li>\\n\" +\n    \"<li ng-class=\\\"{disabled: noNext()||ngDisabled, next: align}\\\"><a href ng-click=\\\"selectPage(page + 1, $event)\\\" ng-disabled=\\\"noNext()||ngDisabled\\\" uib-tabindex-toggle>{{::getText('next')}}</a></li>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/pagination/pagination.html\", []).run([\"$templateCache\", function ($templateCache) {\n  $templateCache.put(\"uib/template/pagination/pagination.html\",\n    \"<li role=\\\"menuitem\\\" ng-if=\\\"::boundaryLinks\\\" ng-class=\\\"{disabled: noPrevious()||ngDisabled}\\\" class=\\\"pagination-first\\\"><a href ng-click=\\\"selectPage(1, $event)\\\" ng-disabled=\\\"noPrevious()||ngDisabled\\\" uib-tabindex-toggle>{{::getText('first')}}</a></li>\\n\" +\n    \"<li role=\\\"menuitem\\\" ng-if=\\\"::directionLinks\\\" ng-class=\\\"{disabled: noPrevious()||ngDisabled}\\\" class=\\\"pagination-prev\\\"><a href ng-click=\\\"selectPage(page - 1, $event)\\\" ng-disabled=\\\"noPrevious()||ngDisabled\\\" uib-tabindex-toggle>{{::getText('previous')}}</a></li>\\n\" +\n    \"<li role=\\\"menuitem\\\" ng-repeat=\\\"page in pages track by $index\\\" ng-class=\\\"{active: page.active,disabled: ngDisabled&&!page.active}\\\" class=\\\"pagination-page\\\"><a href ng-click=\\\"selectPage(page.number, $event)\\\" ng-disabled=\\\"ngDisabled&&!page.active\\\" uib-tabindex-toggle>{{page.text}}</a></li>\\n\" +\n    \"<li role=\\\"menuitem\\\" ng-if=\\\"::directionLinks\\\" ng-class=\\\"{disabled: noNext()||ngDisabled}\\\" class=\\\"pagination-next\\\"><a href ng-click=\\\"selectPage(page + 1, $event)\\\" ng-disabled=\\\"noNext()||ngDisabled\\\" uib-tabindex-toggle>{{::getText('next')}}</a></li>\\n\" +\n    \"<li role=\\\"menuitem\\\" ng-if=\\\"::boundaryLinks\\\" ng-class=\\\"{disabled: noNext()||ngDisabled}\\\" class=\\\"pagination-last\\\"><a href ng-click=\\\"selectPage(totalPages, $event)\\\" ng-disabled=\\\"noNext()||ngDisabled\\\" uib-tabindex-toggle>{{::getText('last')}}</a></li>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/tooltip/tooltip-html-popup.html\", []).run([\"$templateCache\", function ($templateCache) {\n  $templateCache.put(\"uib/template/tooltip/tooltip-html-popup.html\",\n    \"<div class=\\\"tooltip-arrow\\\"></div>\\n\" +\n    \"<div class=\\\"tooltip-inner\\\" ng-bind-html=\\\"contentExp()\\\"></div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/tooltip/tooltip-popup.html\", []).run([\"$templateCache\", function ($templateCache) {\n  $templateCache.put(\"uib/template/tooltip/tooltip-popup.html\",\n    \"<div class=\\\"tooltip-arrow\\\"></div>\\n\" +\n    \"<div class=\\\"tooltip-inner\\\" ng-bind=\\\"content\\\"></div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/tooltip/tooltip-template-popup.html\", []).run([\"$templateCache\", function ($templateCache) {\n  $templateCache.put(\"uib/template/tooltip/tooltip-template-popup.html\",\n    \"<div class=\\\"tooltip-arrow\\\"></div>\\n\" +\n    \"<div class=\\\"tooltip-inner\\\"\\n\" +\n    \"  uib-tooltip-template-transclude=\\\"contentExp()\\\"\\n\" +\n    \"  tooltip-template-transclude-scope=\\\"originScope()\\\"></div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/popover/popover-html.html\", []).run([\"$templateCache\", function ($templateCache) {\n  $templateCache.put(\"uib/template/popover/popover-html.html\",\n    \"<div class=\\\"arrow\\\"></div>\\n\" +\n    \"\\n\" +\n    \"<div class=\\\"popover-inner\\\">\\n\" +\n    \"    <h3 class=\\\"popover-title\\\" ng-bind=\\\"uibTitle\\\" ng-if=\\\"uibTitle\\\"></h3>\\n\" +\n    \"    <div class=\\\"popover-content\\\" ng-bind-html=\\\"contentExp()\\\"></div>\\n\" +\n    \"</div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/popover/popover-template.html\", []).run([\"$templateCache\", function ($templateCache) {\n  $templateCache.put(\"uib/template/popover/popover-template.html\",\n    \"<div class=\\\"arrow\\\"></div>\\n\" +\n    \"\\n\" +\n    \"<div class=\\\"popover-inner\\\">\\n\" +\n    \"    <h3 class=\\\"popover-title\\\" ng-bind=\\\"uibTitle\\\" ng-if=\\\"uibTitle\\\"></h3>\\n\" +\n    \"    <div class=\\\"popover-content\\\"\\n\" +\n    \"      uib-tooltip-template-transclude=\\\"contentExp()\\\"\\n\" +\n    \"      tooltip-template-transclude-scope=\\\"originScope()\\\"></div>\\n\" +\n    \"</div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/popover/popover.html\", []).run([\"$templateCache\", function ($templateCache) {\n  $templateCache.put(\"uib/template/popover/popover.html\",\n    \"<div class=\\\"arrow\\\"></div>\\n\" +\n    \"\\n\" +\n    \"<div class=\\\"popover-inner\\\">\\n\" +\n    \"    <h3 class=\\\"popover-title\\\" ng-bind=\\\"uibTitle\\\" ng-if=\\\"uibTitle\\\"></h3>\\n\" +\n    \"    <div class=\\\"popover-content\\\" ng-bind=\\\"content\\\"></div>\\n\" +\n    \"</div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/progressbar/bar.html\", []).run([\"$templateCache\", function ($templateCache) {\n  $templateCache.put(\"uib/template/progressbar/bar.html\",\n    \"<div class=\\\"progress-bar\\\" ng-class=\\\"type && 'progress-bar-' + type\\\" role=\\\"progressbar\\\" aria-valuenow=\\\"{{value}}\\\" aria-valuemin=\\\"0\\\" aria-valuemax=\\\"{{max}}\\\" ng-style=\\\"{width: (percent < 100 ? percent : 100) + '%'}\\\" aria-valuetext=\\\"{{percent | number:0}}%\\\" aria-labelledby=\\\"{{::title}}\\\" ng-transclude></div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/progressbar/progress.html\", []).run([\"$templateCache\", function ($templateCache) {\n  $templateCache.put(\"uib/template/progressbar/progress.html\",\n    \"<div class=\\\"progress\\\" ng-transclude aria-labelledby=\\\"{{::title}}\\\"></div>\");\n}]);\n\nangular.module(\"uib/template/progressbar/progressbar.html\", []).run([\"$templateCache\", function ($templateCache) {\n  $templateCache.put(\"uib/template/progressbar/progressbar.html\",\n    \"<div class=\\\"progress\\\">\\n\" +\n    \"  <div class=\\\"progress-bar\\\" ng-class=\\\"type && 'progress-bar-' + type\\\" role=\\\"progressbar\\\" aria-valuenow=\\\"{{value}}\\\" aria-valuemin=\\\"0\\\" aria-valuemax=\\\"{{max}}\\\" ng-style=\\\"{width: (percent < 100 ? percent : 100) + '%'}\\\" aria-valuetext=\\\"{{percent | number:0}}%\\\" aria-labelledby=\\\"{{::title}}\\\" ng-transclude></div>\\n\" +\n    \"</div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/rating/rating.html\", []).run([\"$templateCache\", function ($templateCache) {\n  $templateCache.put(\"uib/template/rating/rating.html\",\n    \"<span ng-mouseleave=\\\"reset()\\\" ng-keydown=\\\"onKeydown($event)\\\" tabindex=\\\"0\\\" role=\\\"slider\\\" aria-valuemin=\\\"0\\\" aria-valuemax=\\\"{{range.length}}\\\" aria-valuenow=\\\"{{value}}\\\" aria-valuetext=\\\"{{title}}\\\">\\n\" +\n    \"    <span ng-repeat-start=\\\"r in range track by $index\\\" class=\\\"sr-only\\\">({{ $index < value ? '*' : ' ' }})</span>\\n\" +\n    \"    <i ng-repeat-end ng-mouseenter=\\\"enter($index + 1)\\\" ng-click=\\\"rate($index + 1)\\\" class=\\\"glyphicon\\\" ng-class=\\\"$index < value && (r.stateOn || 'glyphicon-star') || (r.stateOff || 'glyphicon-star-empty')\\\" ng-attr-title=\\\"{{r.title}}\\\"></i>\\n\" +\n    \"</span>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/tabs/tab.html\", []).run([\"$templateCache\", function ($templateCache) {\n  $templateCache.put(\"uib/template/tabs/tab.html\",\n    \"<li ng-class=\\\"[{active: active, disabled: disabled}, classes]\\\" class=\\\"uib-tab nav-item\\\">\\n\" +\n    \"  <a href ng-click=\\\"select($event)\\\" class=\\\"nav-link\\\" uib-tab-heading-transclude>{{heading}}</a>\\n\" +\n    \"</li>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/tabs/tabset.html\", []).run([\"$templateCache\", function ($templateCache) {\n  $templateCache.put(\"uib/template/tabs/tabset.html\",\n    \"<div>\\n\" +\n    \"  <ul class=\\\"nav nav-{{tabset.type || 'tabs'}}\\\" ng-class=\\\"{'nav-stacked': vertical, 'nav-justified': justified}\\\" ng-transclude></ul>\\n\" +\n    \"  <div class=\\\"tab-content\\\">\\n\" +\n    \"    <div class=\\\"tab-pane\\\"\\n\" +\n    \"         ng-repeat=\\\"tab in tabset.tabs\\\"\\n\" +\n    \"         ng-class=\\\"{active: tabset.active === tab.index}\\\"\\n\" +\n    \"         uib-tab-content-transclude=\\\"tab\\\">\\n\" +\n    \"    </div>\\n\" +\n    \"  </div>\\n\" +\n    \"</div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/timepicker/timepicker.html\", []).run([\"$templateCache\", function ($templateCache) {\n  $templateCache.put(\"uib/template/timepicker/timepicker.html\",\n    \"<table class=\\\"uib-timepicker\\\">\\n\" +\n    \"  <tbody>\\n\" +\n    \"    <tr class=\\\"text-center\\\" ng-show=\\\"::showSpinners\\\">\\n\" +\n    \"      <td class=\\\"uib-increment hours\\\"><a ng-click=\\\"incrementHours()\\\" ng-class=\\\"{disabled: noIncrementHours()}\\\" class=\\\"btn btn-link\\\" ng-disabled=\\\"noIncrementHours()\\\" tabindex=\\\"-1\\\"><span class=\\\"glyphicon glyphicon-chevron-up\\\"></span></a></td>\\n\" +\n    \"      <td>&nbsp;</td>\\n\" +\n    \"      <td class=\\\"uib-increment minutes\\\"><a ng-click=\\\"incrementMinutes()\\\" ng-class=\\\"{disabled: noIncrementMinutes()}\\\" class=\\\"btn btn-link\\\" ng-disabled=\\\"noIncrementMinutes()\\\" tabindex=\\\"-1\\\"><span class=\\\"glyphicon glyphicon-chevron-up\\\"></span></a></td>\\n\" +\n    \"      <td ng-show=\\\"showSeconds\\\">&nbsp;</td>\\n\" +\n    \"      <td ng-show=\\\"showSeconds\\\" class=\\\"uib-increment seconds\\\"><a ng-click=\\\"incrementSeconds()\\\" ng-class=\\\"{disabled: noIncrementSeconds()}\\\" class=\\\"btn btn-link\\\" ng-disabled=\\\"noIncrementSeconds()\\\" tabindex=\\\"-1\\\"><span class=\\\"glyphicon glyphicon-chevron-up\\\"></span></a></td>\\n\" +\n    \"      <td ng-show=\\\"showMeridian\\\"></td>\\n\" +\n    \"    </tr>\\n\" +\n    \"    <tr>\\n\" +\n    \"      <td class=\\\"form-group uib-time hours\\\" ng-class=\\\"{'has-error': invalidHours}\\\">\\n\" +\n    \"        <input type=\\\"text\\\" placeholder=\\\"HH\\\" ng-model=\\\"hours\\\" ng-change=\\\"updateHours()\\\" class=\\\"form-control text-center\\\" ng-readonly=\\\"::readonlyInput\\\" maxlength=\\\"2\\\" tabindex=\\\"{{::tabindex}}\\\" ng-disabled=\\\"noIncrementHours()\\\" ng-blur=\\\"blur()\\\">\\n\" +\n    \"      </td>\\n\" +\n    \"      <td class=\\\"uib-separator\\\">:</td>\\n\" +\n    \"      <td class=\\\"form-group uib-time minutes\\\" ng-class=\\\"{'has-error': invalidMinutes}\\\">\\n\" +\n    \"        <input type=\\\"text\\\" placeholder=\\\"MM\\\" ng-model=\\\"minutes\\\" ng-change=\\\"updateMinutes()\\\" class=\\\"form-control text-center\\\" ng-readonly=\\\"::readonlyInput\\\" maxlength=\\\"2\\\" tabindex=\\\"{{::tabindex}}\\\" ng-disabled=\\\"noIncrementMinutes()\\\" ng-blur=\\\"blur()\\\">\\n\" +\n    \"      </td>\\n\" +\n    \"      <td ng-show=\\\"showSeconds\\\" class=\\\"uib-separator\\\">:</td>\\n\" +\n    \"      <td class=\\\"form-group uib-time seconds\\\" ng-class=\\\"{'has-error': invalidSeconds}\\\" ng-show=\\\"showSeconds\\\">\\n\" +\n    \"        <input type=\\\"text\\\" placeholder=\\\"SS\\\" ng-model=\\\"seconds\\\" ng-change=\\\"updateSeconds()\\\" class=\\\"form-control text-center\\\" ng-readonly=\\\"readonlyInput\\\" maxlength=\\\"2\\\" tabindex=\\\"{{::tabindex}}\\\" ng-disabled=\\\"noIncrementSeconds()\\\" ng-blur=\\\"blur()\\\">\\n\" +\n    \"      </td>\\n\" +\n    \"      <td ng-show=\\\"showMeridian\\\" class=\\\"uib-time am-pm\\\"><button type=\\\"button\\\" ng-class=\\\"{disabled: noToggleMeridian()}\\\" class=\\\"btn btn-default text-center\\\" ng-click=\\\"toggleMeridian()\\\" ng-disabled=\\\"noToggleMeridian()\\\" tabindex=\\\"{{::tabindex}}\\\">{{meridian}}</button></td>\\n\" +\n    \"    </tr>\\n\" +\n    \"    <tr class=\\\"text-center\\\" ng-show=\\\"::showSpinners\\\">\\n\" +\n    \"      <td class=\\\"uib-decrement hours\\\"><a ng-click=\\\"decrementHours()\\\" ng-class=\\\"{disabled: noDecrementHours()}\\\" class=\\\"btn btn-link\\\" ng-disabled=\\\"noDecrementHours()\\\" tabindex=\\\"-1\\\"><span class=\\\"glyphicon glyphicon-chevron-down\\\"></span></a></td>\\n\" +\n    \"      <td>&nbsp;</td>\\n\" +\n    \"      <td class=\\\"uib-decrement minutes\\\"><a ng-click=\\\"decrementMinutes()\\\" ng-class=\\\"{disabled: noDecrementMinutes()}\\\" class=\\\"btn btn-link\\\" ng-disabled=\\\"noDecrementMinutes()\\\" tabindex=\\\"-1\\\"><span class=\\\"glyphicon glyphicon-chevron-down\\\"></span></a></td>\\n\" +\n    \"      <td ng-show=\\\"showSeconds\\\">&nbsp;</td>\\n\" +\n    \"      <td ng-show=\\\"showSeconds\\\" class=\\\"uib-decrement seconds\\\"><a ng-click=\\\"decrementSeconds()\\\" ng-class=\\\"{disabled: noDecrementSeconds()}\\\" class=\\\"btn btn-link\\\" ng-disabled=\\\"noDecrementSeconds()\\\" tabindex=\\\"-1\\\"><span class=\\\"glyphicon glyphicon-chevron-down\\\"></span></a></td>\\n\" +\n    \"      <td ng-show=\\\"showMeridian\\\"></td>\\n\" +\n    \"    </tr>\\n\" +\n    \"  </tbody>\\n\" +\n    \"</table>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/typeahead/typeahead-match.html\", []).run([\"$templateCache\", function ($templateCache) {\n  $templateCache.put(\"uib/template/typeahead/typeahead-match.html\",\n    \"<a href\\n\" +\n    \"   tabindex=\\\"-1\\\"\\n\" +\n    \"   ng-bind-html=\\\"match.label | uibTypeaheadHighlight:query\\\"\\n\" +\n    \"   ng-attr-title=\\\"{{match.label}}\\\"></a>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/typeahead/typeahead-popup.html\", []).run([\"$templateCache\", function ($templateCache) {\n  $templateCache.put(\"uib/template/typeahead/typeahead-popup.html\",\n    \"<ul class=\\\"dropdown-menu\\\" ng-show=\\\"isOpen() && !moveInProgress\\\" ng-style=\\\"{top: position().top+'px', left: position().left+'px'}\\\" role=\\\"listbox\\\" aria-hidden=\\\"{{!isOpen()}}\\\">\\n\" +\n    \"    <li class=\\\"uib-typeahead-match\\\" ng-repeat=\\\"match in matches track by $index\\\" ng-class=\\\"{active: isActive($index) }\\\" ng-mouseenter=\\\"selectActive($index)\\\" ng-click=\\\"selectMatch($index, $event)\\\" role=\\\"option\\\" id=\\\"{{::match.id}}\\\">\\n\" +\n    \"        <div uib-typeahead-match index=\\\"$index\\\" match=\\\"match\\\" query=\\\"query\\\" template-url=\\\"templateUrl\\\"></div>\\n\" +\n    \"    </li>\\n\" +\n    \"</ul>\\n\" +\n    \"\");\n}]);\nangular.module('ui.bootstrap.carousel').run(function() {!angular.$$csp().noInlineStyle && !angular.$$uibCarouselCss && angular.element(document).find('head').prepend('<style type=\"text/css\">.ng-animate.item:not(.left):not(.right){-webkit-transition:0s ease-in-out left;transition:0s ease-in-out left}</style>'); angular.$$uibCarouselCss = true; });\nangular.module('ui.bootstrap.datepicker').run(function() {!angular.$$csp().noInlineStyle && !angular.$$uibDatepickerCss && angular.element(document).find('head').prepend('<style type=\"text/css\">.uib-datepicker .uib-title{width:100%;}.uib-day button,.uib-month button,.uib-year button{min-width:100%;}.uib-left,.uib-right{width:100%}</style>'); angular.$$uibDatepickerCss = true; });\nangular.module('ui.bootstrap.position').run(function() {!angular.$$csp().noInlineStyle && !angular.$$uibPositionCss && angular.element(document).find('head').prepend('<style type=\"text/css\">.uib-position-measure{display:block !important;visibility:hidden !important;position:absolute !important;top:-9999px !important;left:-9999px !important;}.uib-position-scrollbar-measure{position:absolute !important;top:-9999px !important;width:50px !important;height:50px !important;overflow:scroll !important;}.uib-position-body-scrollbar-measure{overflow:scroll !important;}</style>'); angular.$$uibPositionCss = true; });\nangular.module('ui.bootstrap.datepickerPopup').run(function() {!angular.$$csp().noInlineStyle && !angular.$$uibDatepickerpopupCss && angular.element(document).find('head').prepend('<style type=\"text/css\">.uib-datepicker-popup.dropdown-menu{display:block;float:none;margin:0;}.uib-button-bar{padding:10px 9px 2px;}</style>'); angular.$$uibDatepickerpopupCss = true; });\nangular.module('ui.bootstrap.tooltip').run(function() {!angular.$$csp().noInlineStyle && !angular.$$uibTooltipCss && angular.element(document).find('head').prepend('<style type=\"text/css\">[uib-tooltip-popup].tooltip.top-left > .tooltip-arrow,[uib-tooltip-popup].tooltip.top-right > .tooltip-arrow,[uib-tooltip-popup].tooltip.bottom-left > .tooltip-arrow,[uib-tooltip-popup].tooltip.bottom-right > .tooltip-arrow,[uib-tooltip-popup].tooltip.left-top > .tooltip-arrow,[uib-tooltip-popup].tooltip.left-bottom > .tooltip-arrow,[uib-tooltip-popup].tooltip.right-top > .tooltip-arrow,[uib-tooltip-popup].tooltip.right-bottom > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.top-left > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.top-right > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.bottom-left > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.bottom-right > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.left-top > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.left-bottom > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.right-top > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.right-bottom > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.top-left > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.top-right > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.bottom-left > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.bottom-right > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.left-top > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.left-bottom > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.right-top > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.right-bottom > .tooltip-arrow,[uib-popover-popup].popover.top-left > .arrow,[uib-popover-popup].popover.top-right > .arrow,[uib-popover-popup].popover.bottom-left > .arrow,[uib-popover-popup].popover.bottom-right > .arrow,[uib-popover-popup].popover.left-top > .arrow,[uib-popover-popup].popover.left-bottom > .arrow,[uib-popover-popup].popover.right-top > .arrow,[uib-popover-popup].popover.right-bottom > .arrow,[uib-popover-html-popup].popover.top-left > .arrow,[uib-popover-html-popup].popover.top-right > .arrow,[uib-popover-html-popup].popover.bottom-left > .arrow,[uib-popover-html-popup].popover.bottom-right > .arrow,[uib-popover-html-popup].popover.left-top > .arrow,[uib-popover-html-popup].popover.left-bottom > .arrow,[uib-popover-html-popup].popover.right-top > .arrow,[uib-popover-html-popup].popover.right-bottom > .arrow,[uib-popover-template-popup].popover.top-left > .arrow,[uib-popover-template-popup].popover.top-right > .arrow,[uib-popover-template-popup].popover.bottom-left > .arrow,[uib-popover-template-popup].popover.bottom-right > .arrow,[uib-popover-template-popup].popover.left-top > .arrow,[uib-popover-template-popup].popover.left-bottom > .arrow,[uib-popover-template-popup].popover.right-top > .arrow,[uib-popover-template-popup].popover.right-bottom > .arrow{top:auto;bottom:auto;left:auto;right:auto;margin:0;}[uib-popover-popup].popover,[uib-popover-html-popup].popover,[uib-popover-template-popup].popover{display:block !important;}</style>'); angular.$$uibTooltipCss = true; });\nangular.module('ui.bootstrap.timepicker').run(function() {!angular.$$csp().noInlineStyle && !angular.$$uibTimepickerCss && angular.element(document).find('head').prepend('<style type=\"text/css\">.uib-time input{width:50px;}</style>'); angular.$$uibTimepickerCss = true; });\nangular.module('ui.bootstrap.typeahead').run(function() {!angular.$$csp().noInlineStyle && !angular.$$uibTypeaheadCss && angular.element(document).find('head').prepend('<style type=\"text/css\">[uib-typeahead-popup].dropdown-menu{display:block;}</style>'); angular.$$uibTypeaheadCss = true; });\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYW5ndWxhci11aS1ib290c3RyYXAvZGlzdC91aS1ib290c3RyYXAtdHBscy5qcz81ZDkxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBLGtCQUFrQjtBQUNsQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0EsaUJBQWlCO0FBQ2pCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGVBQWU7QUFDZjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGlEQUFpRCxFQUFFO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQ0FBaUMsZ0JBQWdCOztBQUVqRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQ0FBaUMsZ0JBQWdCOztBQUVqRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixtQkFBbUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQixtQkFBbUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxzQ0FBc0MsT0FBTztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLG1CQUFtQjtBQUN0QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCLHFCQUFxQjtBQUNoRCxtREFBbUQsR0FBRyxxQkFBcUI7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLG1CQUFtQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhCQUE4Qix5QkFBeUI7QUFDdkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4QkFBOEIseUJBQXlCO0FBQ3ZEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQSw4REFBOEQsRUFBRTs7QUFFaEU7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLEVBQUU7QUFDdEIsZ0NBQWdDLG9CQUFvQixFQUFFO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLG9CQUFvQixFQUFFO0FBQ3RCLGdDQUFnQyxnQkFBZ0Isc0RBQXNELEVBQUU7QUFDeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0Esb0JBQW9CLElBQUk7QUFDeEIsZ0NBQWdDLG9CQUFvQixFQUFFO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHdCQUF3QixFQUFFO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsNERBQTRELEVBQUU7QUFDOUYsbUNBQW1DLGlDQUFpQztBQUNwRSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGlFQUFpRSxFQUFFO0FBQ25HLG1DQUFtQyxnQ0FBZ0M7QUFDbkUsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyx3QkFBd0IsRUFBRTtBQUMxRCxtQ0FBbUMsK0JBQStCO0FBQ2xFLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msd0JBQXdCLEVBQUU7QUFDMUQsbUNBQW1DLDhCQUE4QjtBQUNqRSxPQUFPO0FBQ1A7QUFDQTtBQUNBLDRCQUE0QixFQUFFLFFBQVEsRUFBRTtBQUN4QyxnQ0FBZ0Msb0JBQW9CLEVBQUU7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSwyQkFBMkIsRUFBRSxRQUFRLEVBQUU7QUFDdkMsZ0NBQWdDLG9CQUFvQixFQUFFO0FBQ3RELG1DQUFtQywrQkFBK0I7QUFDbEUsT0FBTztBQUNQO0FBQ0E7QUFDQSw0QkFBNEIsRUFBRSxRQUFRLEVBQUU7QUFDeEMsZ0NBQWdDLG9CQUFvQixFQUFFO0FBQ3RELG1DQUFtQyw4QkFBOEI7QUFDakUsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxpQ0FBaUM7QUFDcEUsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxnQ0FBZ0M7QUFDbkUsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxxQkFBcUIsRUFBRTtBQUN2RCxtQ0FBbUMsK0JBQStCO0FBQ2xFLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MscUJBQXFCLEVBQUU7QUFDdkQsbUNBQW1DLCtCQUErQjtBQUNsRSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHFCQUFxQixFQUFFO0FBQ3ZELG1DQUFtQyw4QkFBOEI7QUFDakUsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxxQkFBcUIsRUFBRTtBQUN2RCxtQ0FBbUMsOEJBQThCO0FBQ2pFLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsdUJBQXVCLEVBQUU7QUFDekQsbUNBQW1DLCtCQUErQjtBQUNsRSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHVCQUF1QixFQUFFO0FBQ3pELG1DQUFtQyw4QkFBOEI7QUFDakUsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyw0QkFBNEIsRUFBRTtBQUM5RCxtQ0FBbUMsZ0NBQWdDO0FBQ25FLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsdUJBQXVCLEVBQUU7QUFDekQsbUNBQW1DLCtCQUErQjtBQUNsRSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHVCQUF1QixFQUFFO0FBQ3pELG1DQUFtQyw4QkFBOEI7QUFDakUsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxtQ0FBbUMsOEJBQThCO0FBQ2pFLE9BQU87QUFDUDtBQUNBO0FBQ0Esd0JBQXdCLEVBQUU7QUFDMUI7QUFDQSwrQ0FBK0MsRUFBRSxLQUFLLEVBQUU7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLCtCQUErQjtBQUNsRSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLDhCQUE4QjtBQUNqRSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGlDQUFpQztBQUNwRSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGdDQUFnQztBQUNuRSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLCtCQUErQjtBQUNsRSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLDhCQUE4QjtBQUNqRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHNFQUFzRSxFQUFFO0FBQ3hHLG1DQUFtQyxpQ0FBaUM7QUFDcEUsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSw0Q0FBNEMsU0FBUztBQUNyRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixtQkFBbUI7QUFDakQ7QUFDQTtBQUNBLGdFQUFnRTtBQUNoRTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QjtBQUM1Qiw0REFBNEQsT0FBTztBQUNuRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQiw4QkFBOEI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCOztBQUVBLHlDQUF5QyxPQUFPO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsOEJBQThCO0FBQ25ELHlCQUF5QjtBQUN6Qjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxzQ0FBc0MsRUFBRTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Qsd0NBQXdDO0FBQzFGOztBQUVBO0FBQ0EsK0JBQStCLHdDQUF3QztBQUN2RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxPQUFPO0FBQ1osb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG1CQUFtQixFQUFFO0FBQzNDOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUEsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQSxtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsb0JBQW9CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJFQUEyRTtBQUMzRTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQSxlQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7O0FBRUEsMkVBQTJFLFdBQVc7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCOztBQUU1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQSxtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCOztBQUV6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBLG1CQUFtQixNQUFNO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QixpQkFBaUIsUUFBUTtBQUN6QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsNkJBQTZCOztBQUU3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixNQUFNO0FBQ3ZCO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQSxpQkFBaUIsT0FBTztBQUN4QixpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRTtBQUMvRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0Esb0RBQW9ELCtCQUErQixFQUFFO0FBQ3JGOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiw0QkFBNEI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIscURBQXFEO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxPQUFPO0FBQ1o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTyxJQUFJO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPLElBQUk7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxRQUFROztBQUVsRCx5REFBeUQsUUFBUTs7QUFFakUsaUNBQWlDLFFBQVE7O0FBRXpDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0NBQXdDO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxpQkFBaUI7QUFDbEQ7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxvQkFBb0IsZ0RBQWdEO0FBQ3BFO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0EsMkJBQTJCLGtCQUFrQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsMkJBQTJCLGtCQUFrQjtBQUM3QztBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsMkJBQTJCLGtCQUFrQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSx5QkFBeUIscUNBQXFDLHdCQUF3QjtBQUNsRzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsYUFBYTtBQUNiOzs7QUFHQTtBQUNBLHVCQUF1QixrQkFBa0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG1CQUFtQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxvREFBb0Q7QUFDdkYsYUFBYTtBQUNiLG1DQUFtQyxpQkFBaUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGlEQUFpRDtBQUMzRTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLDRDQUE0QztBQUMvRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDJEQUEyRDtBQUNuRjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7O0FBRVg7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOEZBQThGO0FBQzlGLGFBQWE7QUFDYjtBQUNBLHNHQUFzRztBQUN0Rzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsK0JBQStCO0FBQ3pEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0REFBNEQ7O0FBRTVEO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLGdEQUFnRCxXQUFXLEVBQUUsRUFBRTtBQUNwSTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQWdDLG1CQUFtQjtBQUNuRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrREFBK0Q7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0I7QUFDaEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0Msb0JBQW9CO0FBQ3hELFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsZ0NBQWdDO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUNBQWlDOztBQUVqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QyxnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixhQUFhO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdEQUFnRCxRQUFROztBQUV4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDJEQUEyRDtBQUMxRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjs7QUFFbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGVBQWU7O0FBRWY7QUFDQTtBQUNBLGVBQWU7O0FBRWY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsUUFBUTtBQUN6RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTs7QUFFQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsWUFBWSxlQUFlO0FBQzNCO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLFlBQVksb0NBQW9DO0FBQ2hEO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLFlBQVksa0JBQWtCO0FBQzlCO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG1EQUFtRDtBQUMvRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxZQUFZLGlDQUFpQztBQUM3QztBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxZQUFZLDhCQUE4QjtBQUMxQztBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIscUJBQXFCO0FBQ3hDOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSwwRUFBMEUsbUJBQW1CO0FBQzdGO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQSxxQkFBcUIsOEJBQThCO0FBQ25EOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNDQUFzQyxPQUFPO0FBQzdDLGtDQUFrQyxXQUFXLEdBQUcsMEVBQTBFO0FBQzFIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixzQkFBc0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBLDhFQUE4RSxnQkFBZ0IsRUFBRTtBQUNoRyxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsNEJBQTRCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw4QkFBOEI7QUFDakQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsU0FBUywyQkFBMkI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxTQUFTLDJCQUEyQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLFNBQVMsMkJBQTJCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhEQUE4RDtBQUM5RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsZUFBZTtBQUN4RDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQixvQkFBb0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsZUFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLG9CQUFvQixFQUFFO0FBQ25EO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVEQUF1RCxZQUFZOztBQUVuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGVBQWU7QUFDZjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUEsc0NBQXNDO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLE9BQU87QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhCQUE4Qix5QkFBeUI7QUFDdkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLCtCQUErQjtBQUMzRCxhQUFhO0FBQ2IsV0FBVztBQUNYLDBCQUEwQiwrQkFBK0I7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1FQUFtRTtBQUNuRTtBQUNBLDZIQUE2SDtBQUM3SDtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSw4QkFBOEIsYUFBYSxxQkFBcUIsUUFBUTtBQUN4RTtBQUNBLDRFQUE0RSxRQUFRLHFCQUFxQixXQUFXLGtNQUFrTSx5QkFBeUIsS0FBSyxTQUFTO0FBQzdWO0FBQ0E7QUFDQSxpQkFBaUIsV0FBVyx1QkFBdUIsYUFBYSxtQkFBbUIsU0FBUztBQUM1RjtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLHFGQUFxRixlQUFlO0FBQ3BHLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsNkZBQTZGLDZCQUE2QjtBQUMxSDtBQUNBO0FBQ0E7QUFDQSw4RkFBOEYsNkJBQTZCO0FBQzNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEZBQTRGLDBCQUEwQjtBQUN0SCx5Q0FBeUMsY0FBYyxNQUFNLGlCQUFpQjtBQUM5RTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsOENBQThDLFlBQVksbUNBQW1DLGNBQWM7QUFDM0c7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGlCQUFpQixrQkFBa0IsWUFBWSxpT0FBaU8sT0FBTztBQUNsVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJHQUEyRyxjQUFjLEtBQUssY0FBYztBQUM1STtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSx1QkFBdUI7QUFDekY7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELG9EQUFvRCxLQUFLLFlBQVk7QUFDeEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLDhDQUE4QyxZQUFZLG1DQUFtQyxjQUFjO0FBQzNHO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixxQkFBcUIsa0JBQWtCLFlBQVksaU9BQWlPLE9BQU87QUFDdFQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCx3QkFBd0IsS0FBSyxZQUFZO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUtBQXFLLHNCQUFzQjtBQUMzTCxtSEFBbUgsb0JBQW9CO0FBQ3ZJO0FBQ0Esc0hBQXNILG9CQUFvQjtBQUMxSTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLDhDQUE4QyxZQUFZLG1DQUFtQyxjQUFjO0FBQzNHO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixlQUFlLGtCQUFrQixZQUFZLGlPQUFpTyxPQUFPO0FBQ2hUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsd0JBQXdCLEtBQUssWUFBWTtBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtS0FBbUssc0JBQXNCO0FBQ3pMLGlIQUFpSCxvQkFBb0I7QUFDckk7QUFDQSxvSEFBb0gsb0JBQW9CO0FBQ3hJO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwrQ0FBK0M7QUFDckU7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLGlDQUFpQyw2QkFBNkI7QUFDOUQ7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxxQkFBcUIsb0RBQW9ELG9IQUFvSCx1QkFBdUI7QUFDcE4scUJBQXFCLDRDQUE0QyxnSEFBZ0gsbUJBQW1CO0FBQ3BNO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsaUVBQWlFLG1DQUFtQyx3SUFBd0ksb0JBQW9CO0FBQ2hRLGtFQUFrRSxtQ0FBbUMsOElBQThJLHVCQUF1QjtBQUMxUSxtRkFBbUYsdURBQXVELGlKQUFpSixXQUFXO0FBQ3RTLGtFQUFrRSwrQkFBK0IsMElBQTBJLG1CQUFtQjtBQUM5UCxpRUFBaUUsK0JBQStCLDRJQUE0SSxtQkFBbUI7QUFDL1A7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLG9IQUFvSCxPQUFPLHlDQUF5QyxLQUFLLGVBQWUsNkNBQTZDLHNCQUFzQixvQkFBb0Isd0JBQXdCLFNBQVM7QUFDaFQ7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSwrREFBK0QsU0FBUztBQUN4RSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLHNIQUFzSCxPQUFPLHlDQUF5QyxLQUFLLGVBQWUsNkNBQTZDLHNCQUFzQixvQkFBb0Isd0JBQXdCLFNBQVM7QUFDbFQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLDJJQUEySSxjQUFjLHFCQUFxQixPQUFPLHNCQUFzQixPQUFPO0FBQ2xOLG1GQUFtRiw4QkFBOEI7QUFDakgsMk9BQTJPLFNBQVM7QUFDcFA7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLHNCQUFzQixtQ0FBbUM7QUFDekQsMkZBQTJGLFNBQVM7QUFDcEc7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHVCQUF1QixlQUFlLG9EQUFvRDtBQUN2SDtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsb0NBQW9DO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRkFBMEYsNkJBQTZCO0FBQ3ZILHFCQUFxQjtBQUNyQiw4RkFBOEYsK0JBQStCO0FBQzdILDZDQUE2QztBQUM3QyxzSEFBc0gsK0JBQStCO0FBQ3JKO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCwwQkFBMEI7QUFDekYsb01BQW9NLFlBQVk7QUFDaE47QUFDQTtBQUNBLGlFQUFpRSw0QkFBNEI7QUFDN0Ysd01BQXdNLFlBQVk7QUFDcE47QUFDQTtBQUNBLGlFQUFpRSw0QkFBNEI7QUFDN0Ysc01BQXNNLFlBQVk7QUFDbE47QUFDQSxxR0FBcUcsNkJBQTZCLHVIQUF1SCxZQUFZLEtBQUssVUFBVTtBQUNwUjtBQUNBO0FBQ0EsMEZBQTBGLDZCQUE2QjtBQUN2SCxxQkFBcUI7QUFDckIsOEZBQThGLCtCQUErQjtBQUM3SCw2Q0FBNkM7QUFDN0Msc0hBQXNILCtCQUErQjtBQUNySjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGFBQWE7QUFDdkM7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxxRkFBcUYscURBQXFELG9DQUFvQyxXQUFXO0FBQ3pMLHNHQUFzRywwQkFBMEIsMEdBQTBHLFlBQVk7QUFDdFA7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsd0RBQXdELDhLQUE4Syx1Q0FBdUMsK0JBQStCLFdBQVcsaUNBQWlDLEVBQUU7QUFDMVYsMERBQTBELG1LQUFtSyxZQUFZLG1EQUFtRCxnQkFBZ0IscUJBQXFCLFdBQVcsV0FBVyxtQ0FBbUMsRUFBRTtBQUM1WCx3REFBd0QsNEpBQTRKLHlCQUF5Qiw2QkFBNkIsNkJBQTZCLHVCQUF1Qix5QkFBeUIsZ0NBQWdDLDZCQUE2Qix1QkFBdUIsc0JBQXNCLHVCQUF1Qiw0QkFBNEIscUNBQXFDLDRCQUE0QixXQUFXLGlDQUFpQyxFQUFFO0FBQ25tQiwrREFBK0QsaUxBQWlMLGNBQWMsV0FBVyxVQUFVLGdCQUFnQixzQkFBc0IsV0FBVyx3Q0FBd0MsRUFBRTtBQUM5Vyx1REFBdUQscXlGQUFxeUYsU0FBUyxZQUFZLFVBQVUsV0FBVyxVQUFVLGtHQUFrRywwQkFBMEIsV0FBVyxnQ0FBZ0MsRUFBRTtBQUN6akcsMERBQTBELHdKQUF3SixZQUFZLFdBQVcsbUNBQW1DLEVBQUU7QUFDOVEseURBQXlELDJLQUEySyxlQUFlLFdBQVcsa0NBQWtDLEVBQUUiLCJmaWxlIjoiMy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBhbmd1bGFyLXVpLWJvb3RzdHJhcFxuICogaHR0cDovL2FuZ3VsYXItdWkuZ2l0aHViLmlvL2Jvb3RzdHJhcC9cblxuICogVmVyc2lvbjogMi41LjYgLSAyMDE3LTEwLTE0XG4gKiBMaWNlbnNlOiBNSVRcbiAqL2FuZ3VsYXIubW9kdWxlKFwidWkuYm9vdHN0cmFwXCIsIFtcInVpLmJvb3RzdHJhcC50cGxzXCIsIFwidWkuYm9vdHN0cmFwLmNvbGxhcHNlXCIsXCJ1aS5ib290c3RyYXAudGFiaW5kZXhcIixcInVpLmJvb3RzdHJhcC5hY2NvcmRpb25cIixcInVpLmJvb3RzdHJhcC5hbGVydFwiLFwidWkuYm9vdHN0cmFwLmJ1dHRvbnNcIixcInVpLmJvb3RzdHJhcC5jYXJvdXNlbFwiLFwidWkuYm9vdHN0cmFwLmRhdGVwYXJzZXJcIixcInVpLmJvb3RzdHJhcC5pc0NsYXNzXCIsXCJ1aS5ib290c3RyYXAuZGF0ZXBpY2tlclwiLFwidWkuYm9vdHN0cmFwLnBvc2l0aW9uXCIsXCJ1aS5ib290c3RyYXAuZGF0ZXBpY2tlclBvcHVwXCIsXCJ1aS5ib290c3RyYXAuZGVib3VuY2VcIixcInVpLmJvb3RzdHJhcC5tdWx0aU1hcFwiLFwidWkuYm9vdHN0cmFwLmRyb3Bkb3duXCIsXCJ1aS5ib290c3RyYXAuc3RhY2tlZE1hcFwiLFwidWkuYm9vdHN0cmFwLm1vZGFsXCIsXCJ1aS5ib290c3RyYXAucGFnaW5nXCIsXCJ1aS5ib290c3RyYXAucGFnZXJcIixcInVpLmJvb3RzdHJhcC5wYWdpbmF0aW9uXCIsXCJ1aS5ib290c3RyYXAudG9vbHRpcFwiLFwidWkuYm9vdHN0cmFwLnBvcG92ZXJcIixcInVpLmJvb3RzdHJhcC5wcm9ncmVzc2JhclwiLFwidWkuYm9vdHN0cmFwLnJhdGluZ1wiLFwidWkuYm9vdHN0cmFwLnRhYnNcIixcInVpLmJvb3RzdHJhcC50aW1lcGlja2VyXCIsXCJ1aS5ib290c3RyYXAudHlwZWFoZWFkXCJdKTtcbmFuZ3VsYXIubW9kdWxlKFwidWkuYm9vdHN0cmFwLnRwbHNcIiwgW1widWliL3RlbXBsYXRlL2FjY29yZGlvbi9hY2NvcmRpb24tZ3JvdXAuaHRtbFwiLFwidWliL3RlbXBsYXRlL2FjY29yZGlvbi9hY2NvcmRpb24uaHRtbFwiLFwidWliL3RlbXBsYXRlL2FsZXJ0L2FsZXJ0Lmh0bWxcIixcInVpYi90ZW1wbGF0ZS9jYXJvdXNlbC9jYXJvdXNlbC5odG1sXCIsXCJ1aWIvdGVtcGxhdGUvY2Fyb3VzZWwvc2xpZGUuaHRtbFwiLFwidWliL3RlbXBsYXRlL2RhdGVwaWNrZXIvZGF0ZXBpY2tlci5odG1sXCIsXCJ1aWIvdGVtcGxhdGUvZGF0ZXBpY2tlci9kYXkuaHRtbFwiLFwidWliL3RlbXBsYXRlL2RhdGVwaWNrZXIvbW9udGguaHRtbFwiLFwidWliL3RlbXBsYXRlL2RhdGVwaWNrZXIveWVhci5odG1sXCIsXCJ1aWIvdGVtcGxhdGUvZGF0ZXBpY2tlclBvcHVwL3BvcHVwLmh0bWxcIixcInVpYi90ZW1wbGF0ZS9tb2RhbC93aW5kb3cuaHRtbFwiLFwidWliL3RlbXBsYXRlL3BhZ2VyL3BhZ2VyLmh0bWxcIixcInVpYi90ZW1wbGF0ZS9wYWdpbmF0aW9uL3BhZ2luYXRpb24uaHRtbFwiLFwidWliL3RlbXBsYXRlL3Rvb2x0aXAvdG9vbHRpcC1odG1sLXBvcHVwLmh0bWxcIixcInVpYi90ZW1wbGF0ZS90b29sdGlwL3Rvb2x0aXAtcG9wdXAuaHRtbFwiLFwidWliL3RlbXBsYXRlL3Rvb2x0aXAvdG9vbHRpcC10ZW1wbGF0ZS1wb3B1cC5odG1sXCIsXCJ1aWIvdGVtcGxhdGUvcG9wb3Zlci9wb3BvdmVyLWh0bWwuaHRtbFwiLFwidWliL3RlbXBsYXRlL3BvcG92ZXIvcG9wb3Zlci10ZW1wbGF0ZS5odG1sXCIsXCJ1aWIvdGVtcGxhdGUvcG9wb3Zlci9wb3BvdmVyLmh0bWxcIixcInVpYi90ZW1wbGF0ZS9wcm9ncmVzc2Jhci9iYXIuaHRtbFwiLFwidWliL3RlbXBsYXRlL3Byb2dyZXNzYmFyL3Byb2dyZXNzLmh0bWxcIixcInVpYi90ZW1wbGF0ZS9wcm9ncmVzc2Jhci9wcm9ncmVzc2Jhci5odG1sXCIsXCJ1aWIvdGVtcGxhdGUvcmF0aW5nL3JhdGluZy5odG1sXCIsXCJ1aWIvdGVtcGxhdGUvdGFicy90YWIuaHRtbFwiLFwidWliL3RlbXBsYXRlL3RhYnMvdGFic2V0Lmh0bWxcIixcInVpYi90ZW1wbGF0ZS90aW1lcGlja2VyL3RpbWVwaWNrZXIuaHRtbFwiLFwidWliL3RlbXBsYXRlL3R5cGVhaGVhZC90eXBlYWhlYWQtbWF0Y2guaHRtbFwiLFwidWliL3RlbXBsYXRlL3R5cGVhaGVhZC90eXBlYWhlYWQtcG9wdXAuaHRtbFwiXSk7XG5hbmd1bGFyLm1vZHVsZSgndWkuYm9vdHN0cmFwLmNvbGxhcHNlJywgW10pXG5cbiAgLmRpcmVjdGl2ZSgndWliQ29sbGFwc2UnLCBbJyRhbmltYXRlJywgJyRxJywgJyRwYXJzZScsICckaW5qZWN0b3InLCBmdW5jdGlvbigkYW5pbWF0ZSwgJHEsICRwYXJzZSwgJGluamVjdG9yKSB7XG4gICAgdmFyICRhbmltYXRlQ3NzID0gJGluamVjdG9yLmhhcygnJGFuaW1hdGVDc3MnKSA/ICRpbmplY3Rvci5nZXQoJyRhbmltYXRlQ3NzJykgOiBudWxsO1xuICAgIHJldHVybiB7XG4gICAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cnMpIHtcbiAgICAgICAgdmFyIGV4cGFuZGluZ0V4cHIgPSAkcGFyc2UoYXR0cnMuZXhwYW5kaW5nKSxcbiAgICAgICAgICBleHBhbmRlZEV4cHIgPSAkcGFyc2UoYXR0cnMuZXhwYW5kZWQpLFxuICAgICAgICAgIGNvbGxhcHNpbmdFeHByID0gJHBhcnNlKGF0dHJzLmNvbGxhcHNpbmcpLFxuICAgICAgICAgIGNvbGxhcHNlZEV4cHIgPSAkcGFyc2UoYXR0cnMuY29sbGFwc2VkKSxcbiAgICAgICAgICBob3Jpem9udGFsID0gZmFsc2UsXG4gICAgICAgICAgY3NzID0ge30sXG4gICAgICAgICAgY3NzVG8gPSB7fTtcblxuICAgICAgICBpbml0KCk7XG5cbiAgICAgICAgZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgICAgICBob3Jpem9udGFsID0gISEoJ2hvcml6b250YWwnIGluIGF0dHJzKTtcbiAgICAgICAgICBpZiAoaG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgY3NzID0ge1xuICAgICAgICAgICAgICB3aWR0aDogJydcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjc3NUbyA9IHt3aWR0aDogJzAnfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3NzID0ge1xuICAgICAgICAgICAgICBoZWlnaHQ6ICcnXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY3NzVG8gPSB7aGVpZ2h0OiAnMCd9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXNjb3BlLiRldmFsKGF0dHJzLnVpYkNvbGxhcHNlKSkge1xuICAgICAgICAgICAgZWxlbWVudC5hZGRDbGFzcygnaW4nKVxuICAgICAgICAgICAgICAuYWRkQ2xhc3MoJ2NvbGxhcHNlJylcbiAgICAgICAgICAgICAgLmF0dHIoJ2FyaWEtZXhwYW5kZWQnLCB0cnVlKVxuICAgICAgICAgICAgICAuYXR0cignYXJpYS1oaWRkZW4nLCBmYWxzZSlcbiAgICAgICAgICAgICAgLmNzcyhjc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdldFNjcm9sbEZyb21FbGVtZW50KGVsZW1lbnQpIHtcbiAgICAgICAgICBpZiAoaG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgcmV0dXJuIHt3aWR0aDogZWxlbWVudC5zY3JvbGxXaWR0aCArICdweCd9O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4ge2hlaWdodDogZWxlbWVudC5zY3JvbGxIZWlnaHQgKyAncHgnfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGV4cGFuZCgpIHtcbiAgICAgICAgICBpZiAoZWxlbWVudC5oYXNDbGFzcygnY29sbGFwc2UnKSAmJiBlbGVtZW50Lmhhc0NsYXNzKCdpbicpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgJHEucmVzb2x2ZShleHBhbmRpbmdFeHByKHNjb3BlKSlcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBlbGVtZW50LnJlbW92ZUNsYXNzKCdjb2xsYXBzZScpXG4gICAgICAgICAgICAgICAgLmFkZENsYXNzKCdjb2xsYXBzaW5nJylcbiAgICAgICAgICAgICAgICAuYXR0cignYXJpYS1leHBhbmRlZCcsIHRydWUpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2FyaWEtaGlkZGVuJywgZmFsc2UpO1xuXG4gICAgICAgICAgICAgIGlmICgkYW5pbWF0ZUNzcykge1xuICAgICAgICAgICAgICAgICRhbmltYXRlQ3NzKGVsZW1lbnQsIHtcbiAgICAgICAgICAgICAgICAgIGFkZENsYXNzOiAnaW4nLFxuICAgICAgICAgICAgICAgICAgZWFzaW5nOiAnZWFzZScsXG4gICAgICAgICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgdG86IGdldFNjcm9sbEZyb21FbGVtZW50KGVsZW1lbnRbMF0pXG4gICAgICAgICAgICAgICAgfSkuc3RhcnQoKVsnZmluYWxseSddKGV4cGFuZERvbmUpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICRhbmltYXRlLmFkZENsYXNzKGVsZW1lbnQsICdpbicsIHtcbiAgICAgICAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICAgICAgICBvdmVyZmxvdzogJ2hpZGRlbidcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICB0bzogZ2V0U2Nyb2xsRnJvbUVsZW1lbnQoZWxlbWVudFswXSlcbiAgICAgICAgICAgICAgICB9KS50aGVuKGV4cGFuZERvbmUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBhbmd1bGFyLm5vb3ApO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZXhwYW5kRG9uZSgpIHtcbiAgICAgICAgICBlbGVtZW50LnJlbW92ZUNsYXNzKCdjb2xsYXBzaW5nJylcbiAgICAgICAgICAgIC5hZGRDbGFzcygnY29sbGFwc2UnKVxuICAgICAgICAgICAgLmNzcyhjc3MpO1xuICAgICAgICAgIGV4cGFuZGVkRXhwcihzY29wZSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBjb2xsYXBzZSgpIHtcbiAgICAgICAgICBpZiAoIWVsZW1lbnQuaGFzQ2xhc3MoJ2NvbGxhcHNlJykgJiYgIWVsZW1lbnQuaGFzQ2xhc3MoJ2luJykpIHtcbiAgICAgICAgICAgIHJldHVybiBjb2xsYXBzZURvbmUoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAkcS5yZXNvbHZlKGNvbGxhcHNpbmdFeHByKHNjb3BlKSlcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBlbGVtZW50XG4gICAgICAgICAgICAgIC8vIElNUE9SVEFOVDogVGhlIHdpZHRoIG11c3QgYmUgc2V0IGJlZm9yZSBhZGRpbmcgXCJjb2xsYXBzaW5nXCIgY2xhc3MuXG4gICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgdGhlIGJyb3dzZXIgYXR0ZW1wdHMgdG8gYW5pbWF0ZSBmcm9tIHdpZHRoIDAgKGluXG4gICAgICAgICAgICAgIC8vIGNvbGxhcHNpbmcgY2xhc3MpIHRvIHRoZSBnaXZlbiB3aWR0aCBoZXJlLlxuICAgICAgICAgICAgICAgIC5jc3MoZ2V0U2Nyb2xsRnJvbUVsZW1lbnQoZWxlbWVudFswXSkpXG4gICAgICAgICAgICAgICAgLy8gaW5pdGlhbGx5IGFsbCBwYW5lbCBjb2xsYXBzZSBoYXZlIHRoZSBjb2xsYXBzZSBjbGFzcywgdGhpcyByZW1vdmFsXG4gICAgICAgICAgICAgICAgLy8gcHJldmVudHMgdGhlIGFuaW1hdGlvbiBmcm9tIGp1bXBpbmcgdG8gY29sbGFwc2VkIHN0YXRlXG4gICAgICAgICAgICAgICAgLnJlbW92ZUNsYXNzKCdjb2xsYXBzZScpXG4gICAgICAgICAgICAgICAgLmFkZENsYXNzKCdjb2xsYXBzaW5nJylcbiAgICAgICAgICAgICAgICAuYXR0cignYXJpYS1leHBhbmRlZCcsIGZhbHNlKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdhcmlhLWhpZGRlbicsIHRydWUpO1xuXG4gICAgICAgICAgICAgIGlmICgkYW5pbWF0ZUNzcykge1xuICAgICAgICAgICAgICAgICRhbmltYXRlQ3NzKGVsZW1lbnQsIHtcbiAgICAgICAgICAgICAgICAgIHJlbW92ZUNsYXNzOiAnaW4nLFxuICAgICAgICAgICAgICAgICAgdG86IGNzc1RvXG4gICAgICAgICAgICAgICAgfSkuc3RhcnQoKVsnZmluYWxseSddKGNvbGxhcHNlRG9uZSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgJGFuaW1hdGUucmVtb3ZlQ2xhc3MoZWxlbWVudCwgJ2luJywge1xuICAgICAgICAgICAgICAgICAgdG86IGNzc1RvXG4gICAgICAgICAgICAgICAgfSkudGhlbihjb2xsYXBzZURvbmUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBhbmd1bGFyLm5vb3ApO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gY29sbGFwc2VEb25lKCkge1xuICAgICAgICAgIGVsZW1lbnQuY3NzKGNzc1RvKTsgLy8gUmVxdWlyZWQgc28gdGhhdCBjb2xsYXBzZSB3b3JrcyB3aGVuIGFuaW1hdGlvbiBpcyBkaXNhYmxlZFxuICAgICAgICAgIGVsZW1lbnQucmVtb3ZlQ2xhc3MoJ2NvbGxhcHNpbmcnKVxuICAgICAgICAgICAgLmFkZENsYXNzKCdjb2xsYXBzZScpO1xuICAgICAgICAgIGNvbGxhcHNlZEV4cHIoc2NvcGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2NvcGUuJHdhdGNoKGF0dHJzLnVpYkNvbGxhcHNlLCBmdW5jdGlvbihzaG91bGRDb2xsYXBzZSkge1xuICAgICAgICAgIGlmIChzaG91bGRDb2xsYXBzZSkge1xuICAgICAgICAgICAgY29sbGFwc2UoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXhwYW5kKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICB9XSk7XG5cbmFuZ3VsYXIubW9kdWxlKCd1aS5ib290c3RyYXAudGFiaW5kZXgnLCBbXSlcblxuLmRpcmVjdGl2ZSgndWliVGFiaW5kZXhUb2dnbGUnLCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHtcbiAgICByZXN0cmljdDogJ0EnLFxuICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtLCBhdHRycykge1xuICAgICAgYXR0cnMuJG9ic2VydmUoJ2Rpc2FibGVkJywgZnVuY3Rpb24oZGlzYWJsZWQpIHtcbiAgICAgICAgYXR0cnMuJHNldCgndGFiaW5kZXgnLCBkaXNhYmxlZCA/IC0xIDogbnVsbCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG59KTtcblxuYW5ndWxhci5tb2R1bGUoJ3VpLmJvb3RzdHJhcC5hY2NvcmRpb24nLCBbJ3VpLmJvb3RzdHJhcC5jb2xsYXBzZScsICd1aS5ib290c3RyYXAudGFiaW5kZXgnXSlcblxuLmNvbnN0YW50KCd1aWJBY2NvcmRpb25Db25maWcnLCB7XG4gIGNsb3NlT3RoZXJzOiB0cnVlXG59KVxuXG4uY29udHJvbGxlcignVWliQWNjb3JkaW9uQ29udHJvbGxlcicsIFsnJHNjb3BlJywgJyRhdHRycycsICd1aWJBY2NvcmRpb25Db25maWcnLCBmdW5jdGlvbigkc2NvcGUsICRhdHRycywgYWNjb3JkaW9uQ29uZmlnKSB7XG4gIC8vIFRoaXMgYXJyYXkga2VlcHMgdHJhY2sgb2YgdGhlIGFjY29yZGlvbiBncm91cHNcbiAgdGhpcy5ncm91cHMgPSBbXTtcblxuICAvLyBFbnN1cmUgdGhhdCBhbGwgdGhlIGdyb3VwcyBpbiB0aGlzIGFjY29yZGlvbiBhcmUgY2xvc2VkLCB1bmxlc3MgY2xvc2Utb3RoZXJzIGV4cGxpY2l0bHkgc2F5cyBub3QgdG9cbiAgdGhpcy5jbG9zZU90aGVycyA9IGZ1bmN0aW9uKG9wZW5Hcm91cCkge1xuICAgIHZhciBjbG9zZU90aGVycyA9IGFuZ3VsYXIuaXNEZWZpbmVkKCRhdHRycy5jbG9zZU90aGVycykgP1xuICAgICAgJHNjb3BlLiRldmFsKCRhdHRycy5jbG9zZU90aGVycykgOiBhY2NvcmRpb25Db25maWcuY2xvc2VPdGhlcnM7XG4gICAgaWYgKGNsb3NlT3RoZXJzKSB7XG4gICAgICBhbmd1bGFyLmZvckVhY2godGhpcy5ncm91cHMsIGZ1bmN0aW9uKGdyb3VwKSB7XG4gICAgICAgIGlmIChncm91cCAhPT0gb3Blbkdyb3VwKSB7XG4gICAgICAgICAgZ3JvdXAuaXNPcGVuID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICAvLyBUaGlzIGlzIGNhbGxlZCBmcm9tIHRoZSBhY2NvcmRpb24tZ3JvdXAgZGlyZWN0aXZlIHRvIGFkZCBpdHNlbGYgdG8gdGhlIGFjY29yZGlvblxuICB0aGlzLmFkZEdyb3VwID0gZnVuY3Rpb24oZ3JvdXBTY29wZSkge1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICB0aGlzLmdyb3Vwcy5wdXNoKGdyb3VwU2NvcGUpO1xuXG4gICAgZ3JvdXBTY29wZS4kb24oJyRkZXN0cm95JywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIHRoYXQucmVtb3ZlR3JvdXAoZ3JvdXBTY29wZSk7XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gVGhpcyBpcyBjYWxsZWQgZnJvbSB0aGUgYWNjb3JkaW9uLWdyb3VwIGRpcmVjdGl2ZSB3aGVuIHRvIHJlbW92ZSBpdHNlbGZcbiAgdGhpcy5yZW1vdmVHcm91cCA9IGZ1bmN0aW9uKGdyb3VwKSB7XG4gICAgdmFyIGluZGV4ID0gdGhpcy5ncm91cHMuaW5kZXhPZihncm91cCk7XG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgdGhpcy5ncm91cHMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9XG4gIH07XG59XSlcblxuLy8gVGhlIGFjY29yZGlvbiBkaXJlY3RpdmUgc2ltcGx5IHNldHMgdXAgdGhlIGRpcmVjdGl2ZSBjb250cm9sbGVyXG4vLyBhbmQgYWRkcyBhbiBhY2NvcmRpb24gQ1NTIGNsYXNzIHRvIGl0c2VsZiBlbGVtZW50LlxuLmRpcmVjdGl2ZSgndWliQWNjb3JkaW9uJywgZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7XG4gICAgY29udHJvbGxlcjogJ1VpYkFjY29yZGlvbkNvbnRyb2xsZXInLFxuICAgIGNvbnRyb2xsZXJBczogJ2FjY29yZGlvbicsXG4gICAgdHJhbnNjbHVkZTogdHJ1ZSxcbiAgICB0ZW1wbGF0ZVVybDogZnVuY3Rpb24oZWxlbWVudCwgYXR0cnMpIHtcbiAgICAgIHJldHVybiBhdHRycy50ZW1wbGF0ZVVybCB8fCAndWliL3RlbXBsYXRlL2FjY29yZGlvbi9hY2NvcmRpb24uaHRtbCc7XG4gICAgfVxuICB9O1xufSlcblxuLy8gVGhlIGFjY29yZGlvbi1ncm91cCBkaXJlY3RpdmUgaW5kaWNhdGVzIGEgYmxvY2sgb2YgaHRtbCB0aGF0IHdpbGwgZXhwYW5kIGFuZCBjb2xsYXBzZSBpbiBhbiBhY2NvcmRpb25cbi5kaXJlY3RpdmUoJ3VpYkFjY29yZGlvbkdyb3VwJywgZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7XG4gICAgcmVxdWlyZTogJ151aWJBY2NvcmRpb24nLCAgICAgICAgIC8vIFdlIG5lZWQgdGhpcyBkaXJlY3RpdmUgdG8gYmUgaW5zaWRlIGFuIGFjY29yZGlvblxuICAgIHRyYW5zY2x1ZGU6IHRydWUsICAgICAgICAgICAgICAvLyBJdCB0cmFuc2NsdWRlcyB0aGUgY29udGVudHMgb2YgdGhlIGRpcmVjdGl2ZSBpbnRvIHRoZSB0ZW1wbGF0ZVxuICAgIHJlc3RyaWN0OiAnQScsXG4gICAgdGVtcGxhdGVVcmw6IGZ1bmN0aW9uKGVsZW1lbnQsIGF0dHJzKSB7XG4gICAgICByZXR1cm4gYXR0cnMudGVtcGxhdGVVcmwgfHwgJ3VpYi90ZW1wbGF0ZS9hY2NvcmRpb24vYWNjb3JkaW9uLWdyb3VwLmh0bWwnO1xuICAgIH0sXG4gICAgc2NvcGU6IHtcbiAgICAgIGhlYWRpbmc6ICdAJywgICAgICAgICAgICAgICAvLyBJbnRlcnBvbGF0ZSB0aGUgaGVhZGluZyBhdHRyaWJ1dGUgb250byB0aGlzIHNjb3BlXG4gICAgICBwYW5lbENsYXNzOiAnQD8nLCAgICAgICAgICAgLy8gRGl0dG8gd2l0aCBwYW5lbENsYXNzXG4gICAgICBpc09wZW46ICc9PycsXG4gICAgICBpc0Rpc2FibGVkOiAnPT8nXG4gICAgfSxcbiAgICBjb250cm9sbGVyOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuc2V0SGVhZGluZyA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5oZWFkaW5nID0gZWxlbWVudDtcbiAgICAgIH07XG4gICAgfSxcbiAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cnMsIGFjY29yZGlvbkN0cmwpIHtcbiAgICAgIGVsZW1lbnQuYWRkQ2xhc3MoJ3BhbmVsJyk7XG4gICAgICBhY2NvcmRpb25DdHJsLmFkZEdyb3VwKHNjb3BlKTtcblxuICAgICAgc2NvcGUub3BlbkNsYXNzID0gYXR0cnMub3BlbkNsYXNzIHx8ICdwYW5lbC1vcGVuJztcbiAgICAgIHNjb3BlLnBhbmVsQ2xhc3MgPSBhdHRycy5wYW5lbENsYXNzIHx8ICdwYW5lbC1kZWZhdWx0JztcbiAgICAgIHNjb3BlLiR3YXRjaCgnaXNPcGVuJywgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgZWxlbWVudC50b2dnbGVDbGFzcyhzY29wZS5vcGVuQ2xhc3MsICEhdmFsdWUpO1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICBhY2NvcmRpb25DdHJsLmNsb3NlT3RoZXJzKHNjb3BlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHNjb3BlLnRvZ2dsZU9wZW4gPSBmdW5jdGlvbigkZXZlbnQpIHtcbiAgICAgICAgaWYgKCFzY29wZS5pc0Rpc2FibGVkKSB7XG4gICAgICAgICAgaWYgKCEkZXZlbnQgfHwgJGV2ZW50LndoaWNoID09PSAzMikge1xuICAgICAgICAgICAgc2NvcGUuaXNPcGVuID0gIXNjb3BlLmlzT3BlbjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHZhciBpZCA9ICdhY2NvcmRpb25ncm91cC0nICsgc2NvcGUuJGlkICsgJy0nICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMDApO1xuICAgICAgc2NvcGUuaGVhZGluZ0lkID0gaWQgKyAnLXRhYic7XG4gICAgICBzY29wZS5wYW5lbElkID0gaWQgKyAnLXBhbmVsJztcbiAgICB9XG4gIH07XG59KVxuXG4vLyBVc2UgYWNjb3JkaW9uLWhlYWRpbmcgYmVsb3cgYW4gYWNjb3JkaW9uLWdyb3VwIHRvIHByb3ZpZGUgYSBoZWFkaW5nIGNvbnRhaW5pbmcgSFRNTFxuLmRpcmVjdGl2ZSgndWliQWNjb3JkaW9uSGVhZGluZycsIGZ1bmN0aW9uKCkge1xuICByZXR1cm4ge1xuICAgIHRyYW5zY2x1ZGU6IHRydWUsICAgLy8gR3JhYiB0aGUgY29udGVudHMgdG8gYmUgdXNlZCBhcyB0aGUgaGVhZGluZ1xuICAgIHRlbXBsYXRlOiAnJywgICAgICAgLy8gSW4gZWZmZWN0IHJlbW92ZSB0aGlzIGVsZW1lbnQhXG4gICAgcmVwbGFjZTogdHJ1ZSxcbiAgICByZXF1aXJlOiAnXnVpYkFjY29yZGlvbkdyb3VwJyxcbiAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cnMsIGFjY29yZGlvbkdyb3VwQ3RybCwgdHJhbnNjbHVkZSkge1xuICAgICAgLy8gUGFzcyB0aGUgaGVhZGluZyB0byB0aGUgYWNjb3JkaW9uLWdyb3VwIGNvbnRyb2xsZXJcbiAgICAgIC8vIHNvIHRoYXQgaXQgY2FuIGJlIHRyYW5zY2x1ZGVkIGludG8gdGhlIHJpZ2h0IHBsYWNlIGluIHRoZSB0ZW1wbGF0ZVxuICAgICAgLy8gW1RoZSBzZWNvbmQgcGFyYW1ldGVyIHRvIHRyYW5zY2x1ZGUgY2F1c2VzIHRoZSBlbGVtZW50cyB0byBiZSBjbG9uZWQgc28gdGhhdCB0aGV5IHdvcmsgaW4gbmctcmVwZWF0XVxuICAgICAgYWNjb3JkaW9uR3JvdXBDdHJsLnNldEhlYWRpbmcodHJhbnNjbHVkZShzY29wZSwgYW5ndWxhci5ub29wKSk7XG4gICAgfVxuICB9O1xufSlcblxuLy8gVXNlIGluIHRoZSBhY2NvcmRpb24tZ3JvdXAgdGVtcGxhdGUgdG8gaW5kaWNhdGUgd2hlcmUgeW91IHdhbnQgdGhlIGhlYWRpbmcgdG8gYmUgdHJhbnNjbHVkZWRcbi8vIFlvdSBtdXN0IHByb3ZpZGUgdGhlIHByb3BlcnR5IG9uIHRoZSBhY2NvcmRpb24tZ3JvdXAgY29udHJvbGxlciB0aGF0IHdpbGwgaG9sZCB0aGUgdHJhbnNjbHVkZWQgZWxlbWVudFxuLmRpcmVjdGl2ZSgndWliQWNjb3JkaW9uVHJhbnNjbHVkZScsIGZ1bmN0aW9uKCkge1xuICByZXR1cm4ge1xuICAgIHJlcXVpcmU6ICdedWliQWNjb3JkaW9uR3JvdXAnLFxuICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRycywgY29udHJvbGxlcikge1xuICAgICAgc2NvcGUuJHdhdGNoKGZ1bmN0aW9uKCkgeyByZXR1cm4gY29udHJvbGxlclthdHRycy51aWJBY2NvcmRpb25UcmFuc2NsdWRlXTsgfSwgZnVuY3Rpb24oaGVhZGluZykge1xuICAgICAgICBpZiAoaGVhZGluZykge1xuICAgICAgICAgIHZhciBlbGVtID0gYW5ndWxhci5lbGVtZW50KGVsZW1lbnRbMF0ucXVlcnlTZWxlY3RvcihnZXRIZWFkZXJTZWxlY3RvcnMoKSkpO1xuICAgICAgICAgIGVsZW0uaHRtbCgnJyk7XG4gICAgICAgICAgZWxlbS5hcHBlbmQoaGVhZGluZyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBnZXRIZWFkZXJTZWxlY3RvcnMoKSB7XG4gICAgICByZXR1cm4gJ3VpYi1hY2NvcmRpb24taGVhZGVyLCcgK1xuICAgICAgICAgICdkYXRhLXVpYi1hY2NvcmRpb24taGVhZGVyLCcgK1xuICAgICAgICAgICd4LXVpYi1hY2NvcmRpb24taGVhZGVyLCcgK1xuICAgICAgICAgICd1aWJcXFxcOmFjY29yZGlvbi1oZWFkZXIsJyArXG4gICAgICAgICAgJ1t1aWItYWNjb3JkaW9uLWhlYWRlcl0sJyArXG4gICAgICAgICAgJ1tkYXRhLXVpYi1hY2NvcmRpb24taGVhZGVyXSwnICtcbiAgICAgICAgICAnW3gtdWliLWFjY29yZGlvbi1oZWFkZXJdJztcbiAgfVxufSk7XG5cbmFuZ3VsYXIubW9kdWxlKCd1aS5ib290c3RyYXAuYWxlcnQnLCBbXSlcblxuLmNvbnRyb2xsZXIoJ1VpYkFsZXJ0Q29udHJvbGxlcicsIFsnJHNjb3BlJywgJyRlbGVtZW50JywgJyRhdHRycycsICckaW50ZXJwb2xhdGUnLCAnJHRpbWVvdXQnLCBmdW5jdGlvbigkc2NvcGUsICRlbGVtZW50LCAkYXR0cnMsICRpbnRlcnBvbGF0ZSwgJHRpbWVvdXQpIHtcbiAgJHNjb3BlLmNsb3NlYWJsZSA9ICEhJGF0dHJzLmNsb3NlO1xuICAkZWxlbWVudC5hZGRDbGFzcygnYWxlcnQnKTtcbiAgJGF0dHJzLiRzZXQoJ3JvbGUnLCAnYWxlcnQnKTtcbiAgaWYgKCRzY29wZS5jbG9zZWFibGUpIHtcbiAgICAkZWxlbWVudC5hZGRDbGFzcygnYWxlcnQtZGlzbWlzc2libGUnKTtcbiAgfVxuXG4gIHZhciBkaXNtaXNzT25UaW1lb3V0ID0gYW5ndWxhci5pc0RlZmluZWQoJGF0dHJzLmRpc21pc3NPblRpbWVvdXQpID9cbiAgICAkaW50ZXJwb2xhdGUoJGF0dHJzLmRpc21pc3NPblRpbWVvdXQpKCRzY29wZS4kcGFyZW50KSA6IG51bGw7XG5cbiAgaWYgKGRpc21pc3NPblRpbWVvdXQpIHtcbiAgICAkdGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICRzY29wZS5jbG9zZSgpO1xuICAgIH0sIHBhcnNlSW50KGRpc21pc3NPblRpbWVvdXQsIDEwKSk7XG4gIH1cbn1dKVxuXG4uZGlyZWN0aXZlKCd1aWJBbGVydCcsIGZ1bmN0aW9uKCkge1xuICByZXR1cm4ge1xuICAgIGNvbnRyb2xsZXI6ICdVaWJBbGVydENvbnRyb2xsZXInLFxuICAgIGNvbnRyb2xsZXJBczogJ2FsZXJ0JyxcbiAgICByZXN0cmljdDogJ0EnLFxuICAgIHRlbXBsYXRlVXJsOiBmdW5jdGlvbihlbGVtZW50LCBhdHRycykge1xuICAgICAgcmV0dXJuIGF0dHJzLnRlbXBsYXRlVXJsIHx8ICd1aWIvdGVtcGxhdGUvYWxlcnQvYWxlcnQuaHRtbCc7XG4gICAgfSxcbiAgICB0cmFuc2NsdWRlOiB0cnVlLFxuICAgIHNjb3BlOiB7XG4gICAgICBjbG9zZTogJyYnXG4gICAgfVxuICB9O1xufSk7XG5cbmFuZ3VsYXIubW9kdWxlKCd1aS5ib290c3RyYXAuYnV0dG9ucycsIFtdKVxuXG4uY29uc3RhbnQoJ3VpYkJ1dHRvbkNvbmZpZycsIHtcbiAgYWN0aXZlQ2xhc3M6ICdhY3RpdmUnLFxuICB0b2dnbGVFdmVudDogJ2NsaWNrJ1xufSlcblxuLmNvbnRyb2xsZXIoJ1VpYkJ1dHRvbnNDb250cm9sbGVyJywgWyd1aWJCdXR0b25Db25maWcnLCBmdW5jdGlvbihidXR0b25Db25maWcpIHtcbiAgdGhpcy5hY3RpdmVDbGFzcyA9IGJ1dHRvbkNvbmZpZy5hY3RpdmVDbGFzcyB8fCAnYWN0aXZlJztcbiAgdGhpcy50b2dnbGVFdmVudCA9IGJ1dHRvbkNvbmZpZy50b2dnbGVFdmVudCB8fCAnY2xpY2snO1xufV0pXG5cbi5kaXJlY3RpdmUoJ3VpYkJ0blJhZGlvJywgWyckcGFyc2UnLCBmdW5jdGlvbigkcGFyc2UpIHtcbiAgcmV0dXJuIHtcbiAgICByZXF1aXJlOiBbJ3VpYkJ0blJhZGlvJywgJ25nTW9kZWwnXSxcbiAgICBjb250cm9sbGVyOiAnVWliQnV0dG9uc0NvbnRyb2xsZXInLFxuICAgIGNvbnRyb2xsZXJBczogJ2J1dHRvbnMnLFxuICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRycywgY3RybHMpIHtcbiAgICAgIHZhciBidXR0b25zQ3RybCA9IGN0cmxzWzBdLCBuZ01vZGVsQ3RybCA9IGN0cmxzWzFdO1xuICAgICAgdmFyIHVuY2hlY2thYmxlRXhwciA9ICRwYXJzZShhdHRycy51aWJVbmNoZWNrYWJsZSk7XG5cbiAgICAgIGVsZW1lbnQuZmluZCgnaW5wdXQnKS5jc3Moe2Rpc3BsYXk6ICdub25lJ30pO1xuXG4gICAgICAvL21vZGVsIC0+IFVJXG4gICAgICBuZ01vZGVsQ3RybC4kcmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGVsZW1lbnQudG9nZ2xlQ2xhc3MoYnV0dG9uc0N0cmwuYWN0aXZlQ2xhc3MsIGFuZ3VsYXIuZXF1YWxzKG5nTW9kZWxDdHJsLiRtb2RlbFZhbHVlLCBzY29wZS4kZXZhbChhdHRycy51aWJCdG5SYWRpbykpKTtcbiAgICAgIH07XG5cbiAgICAgIC8vdWktPm1vZGVsXG4gICAgICBlbGVtZW50Lm9uKGJ1dHRvbnNDdHJsLnRvZ2dsZUV2ZW50LCBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKGF0dHJzLmRpc2FibGVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGlzQWN0aXZlID0gZWxlbWVudC5oYXNDbGFzcyhidXR0b25zQ3RybC5hY3RpdmVDbGFzcyk7XG5cbiAgICAgICAgaWYgKCFpc0FjdGl2ZSB8fCBhbmd1bGFyLmlzRGVmaW5lZChhdHRycy51bmNoZWNrYWJsZSkpIHtcbiAgICAgICAgICBzY29wZS4kYXBwbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBuZ01vZGVsQ3RybC4kc2V0Vmlld1ZhbHVlKGlzQWN0aXZlID8gbnVsbCA6IHNjb3BlLiRldmFsKGF0dHJzLnVpYkJ0blJhZGlvKSk7XG4gICAgICAgICAgICBuZ01vZGVsQ3RybC4kcmVuZGVyKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAoYXR0cnMudWliVW5jaGVja2FibGUpIHtcbiAgICAgICAgc2NvcGUuJHdhdGNoKHVuY2hlY2thYmxlRXhwciwgZnVuY3Rpb24odW5jaGVja2FibGUpIHtcbiAgICAgICAgICBhdHRycy4kc2V0KCd1bmNoZWNrYWJsZScsIHVuY2hlY2thYmxlID8gJycgOiB1bmRlZmluZWQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XSlcblxuLmRpcmVjdGl2ZSgndWliQnRuQ2hlY2tib3gnLCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHtcbiAgICByZXF1aXJlOiBbJ3VpYkJ0bkNoZWNrYm94JywgJ25nTW9kZWwnXSxcbiAgICBjb250cm9sbGVyOiAnVWliQnV0dG9uc0NvbnRyb2xsZXInLFxuICAgIGNvbnRyb2xsZXJBczogJ2J1dHRvbicsXG4gICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHJzLCBjdHJscykge1xuICAgICAgdmFyIGJ1dHRvbnNDdHJsID0gY3RybHNbMF0sIG5nTW9kZWxDdHJsID0gY3RybHNbMV07XG5cbiAgICAgIGVsZW1lbnQuZmluZCgnaW5wdXQnKS5jc3Moe2Rpc3BsYXk6ICdub25lJ30pO1xuXG4gICAgICBmdW5jdGlvbiBnZXRUcnVlVmFsdWUoKSB7XG4gICAgICAgIHJldHVybiBnZXRDaGVja2JveFZhbHVlKGF0dHJzLmJ0bkNoZWNrYm94VHJ1ZSwgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGdldEZhbHNlVmFsdWUoKSB7XG4gICAgICAgIHJldHVybiBnZXRDaGVja2JveFZhbHVlKGF0dHJzLmJ0bkNoZWNrYm94RmFsc2UsIGZhbHNlKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZ2V0Q2hlY2tib3hWYWx1ZShhdHRyaWJ1dGUsIGRlZmF1bHRWYWx1ZSkge1xuICAgICAgICByZXR1cm4gYW5ndWxhci5pc0RlZmluZWQoYXR0cmlidXRlKSA/IHNjb3BlLiRldmFsKGF0dHJpYnV0ZSkgOiBkZWZhdWx0VmFsdWU7XG4gICAgICB9XG5cbiAgICAgIC8vbW9kZWwgLT4gVUlcbiAgICAgIG5nTW9kZWxDdHJsLiRyZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZWxlbWVudC50b2dnbGVDbGFzcyhidXR0b25zQ3RybC5hY3RpdmVDbGFzcywgYW5ndWxhci5lcXVhbHMobmdNb2RlbEN0cmwuJG1vZGVsVmFsdWUsIGdldFRydWVWYWx1ZSgpKSk7XG4gICAgICB9O1xuXG4gICAgICAvL3VpLT5tb2RlbFxuICAgICAgZWxlbWVudC5vbihidXR0b25zQ3RybC50b2dnbGVFdmVudCwgZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChhdHRycy5kaXNhYmxlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHNjb3BlLiRhcHBseShmdW5jdGlvbigpIHtcbiAgICAgICAgICBuZ01vZGVsQ3RybC4kc2V0Vmlld1ZhbHVlKGVsZW1lbnQuaGFzQ2xhc3MoYnV0dG9uc0N0cmwuYWN0aXZlQ2xhc3MpID8gZ2V0RmFsc2VWYWx1ZSgpIDogZ2V0VHJ1ZVZhbHVlKCkpO1xuICAgICAgICAgIG5nTW9kZWxDdHJsLiRyZW5kZXIoKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG59KTtcblxuYW5ndWxhci5tb2R1bGUoJ3VpLmJvb3RzdHJhcC5jYXJvdXNlbCcsIFtdKVxuXG4uY29udHJvbGxlcignVWliQ2Fyb3VzZWxDb250cm9sbGVyJywgWyckc2NvcGUnLCAnJGVsZW1lbnQnLCAnJGludGVydmFsJywgJyR0aW1lb3V0JywgJyRhbmltYXRlJywgZnVuY3Rpb24oJHNjb3BlLCAkZWxlbWVudCwgJGludGVydmFsLCAkdGltZW91dCwgJGFuaW1hdGUpIHtcbiAgdmFyIHNlbGYgPSB0aGlzLFxuICAgIHNsaWRlcyA9IHNlbGYuc2xpZGVzID0gJHNjb3BlLnNsaWRlcyA9IFtdLFxuICAgIFNMSURFX0RJUkVDVElPTiA9ICd1aWItc2xpZGVEaXJlY3Rpb24nLFxuICAgIGN1cnJlbnRJbmRleCA9ICRzY29wZS5hY3RpdmUsXG4gICAgY3VycmVudEludGVydmFsLCBpc1BsYXlpbmc7XG5cbiAgdmFyIGRlc3Ryb3llZCA9IGZhbHNlO1xuICAkZWxlbWVudC5hZGRDbGFzcygnY2Fyb3VzZWwnKTtcblxuICBzZWxmLmFkZFNsaWRlID0gZnVuY3Rpb24oc2xpZGUsIGVsZW1lbnQpIHtcbiAgICBzbGlkZXMucHVzaCh7XG4gICAgICBzbGlkZTogc2xpZGUsXG4gICAgICBlbGVtZW50OiBlbGVtZW50XG4gICAgfSk7XG4gICAgc2xpZGVzLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgcmV0dXJuICthLnNsaWRlLmluZGV4IC0gK2Iuc2xpZGUuaW5kZXg7XG4gICAgfSk7XG4gICAgLy9pZiB0aGlzIGlzIHRoZSBmaXJzdCBzbGlkZSBvciB0aGUgc2xpZGUgaXMgc2V0IHRvIGFjdGl2ZSwgc2VsZWN0IGl0XG4gICAgaWYgKHNsaWRlLmluZGV4ID09PSAkc2NvcGUuYWN0aXZlIHx8IHNsaWRlcy5sZW5ndGggPT09IDEgJiYgIWFuZ3VsYXIuaXNOdW1iZXIoJHNjb3BlLmFjdGl2ZSkpIHtcbiAgICAgIGlmICgkc2NvcGUuJGN1cnJlbnRUcmFuc2l0aW9uKSB7XG4gICAgICAgICRzY29wZS4kY3VycmVudFRyYW5zaXRpb24gPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBjdXJyZW50SW5kZXggPSBzbGlkZS5pbmRleDtcbiAgICAgICRzY29wZS5hY3RpdmUgPSBzbGlkZS5pbmRleDtcbiAgICAgIHNldEFjdGl2ZShjdXJyZW50SW5kZXgpO1xuICAgICAgc2VsZi5zZWxlY3Qoc2xpZGVzW2ZpbmRTbGlkZUluZGV4KHNsaWRlKV0pO1xuICAgICAgaWYgKHNsaWRlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgJHNjb3BlLnBsYXkoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgc2VsZi5nZXRDdXJyZW50SW5kZXggPSBmdW5jdGlvbigpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNsaWRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHNsaWRlc1tpXS5zbGlkZS5pbmRleCA9PT0gY3VycmVudEluZGV4KSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBzZWxmLm5leHQgPSAkc2NvcGUubmV4dCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBuZXdJbmRleCA9IChzZWxmLmdldEN1cnJlbnRJbmRleCgpICsgMSkgJSBzbGlkZXMubGVuZ3RoO1xuXG4gICAgaWYgKG5ld0luZGV4ID09PSAwICYmICRzY29wZS5ub1dyYXAoKSkge1xuICAgICAgJHNjb3BlLnBhdXNlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlbGYuc2VsZWN0KHNsaWRlc1tuZXdJbmRleF0sICduZXh0Jyk7XG4gIH07XG5cbiAgc2VsZi5wcmV2ID0gJHNjb3BlLnByZXYgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbmV3SW5kZXggPSBzZWxmLmdldEN1cnJlbnRJbmRleCgpIC0gMSA8IDAgPyBzbGlkZXMubGVuZ3RoIC0gMSA6IHNlbGYuZ2V0Q3VycmVudEluZGV4KCkgLSAxO1xuXG4gICAgaWYgKCRzY29wZS5ub1dyYXAoKSAmJiBuZXdJbmRleCA9PT0gc2xpZGVzLmxlbmd0aCAtIDEpIHtcbiAgICAgICRzY29wZS5wYXVzZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJldHVybiBzZWxmLnNlbGVjdChzbGlkZXNbbmV3SW5kZXhdLCAncHJldicpO1xuICB9O1xuXG4gIHNlbGYucmVtb3ZlU2xpZGUgPSBmdW5jdGlvbihzbGlkZSkge1xuICAgIHZhciBpbmRleCA9IGZpbmRTbGlkZUluZGV4KHNsaWRlKTtcblxuICAgIC8vZ2V0IHRoZSBpbmRleCBvZiB0aGUgc2xpZGUgaW5zaWRlIHRoZSBjYXJvdXNlbFxuICAgIHNsaWRlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIGlmIChzbGlkZXMubGVuZ3RoID4gMCAmJiBjdXJyZW50SW5kZXggPT09IGluZGV4KSB7XG4gICAgICBpZiAoaW5kZXggPj0gc2xpZGVzLmxlbmd0aCkge1xuICAgICAgICBjdXJyZW50SW5kZXggPSBzbGlkZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgJHNjb3BlLmFjdGl2ZSA9IGN1cnJlbnRJbmRleDtcbiAgICAgICAgc2V0QWN0aXZlKGN1cnJlbnRJbmRleCk7XG4gICAgICAgIHNlbGYuc2VsZWN0KHNsaWRlc1tzbGlkZXMubGVuZ3RoIC0gMV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3VycmVudEluZGV4ID0gaW5kZXg7XG4gICAgICAgICRzY29wZS5hY3RpdmUgPSBjdXJyZW50SW5kZXg7XG4gICAgICAgIHNldEFjdGl2ZShjdXJyZW50SW5kZXgpO1xuICAgICAgICBzZWxmLnNlbGVjdChzbGlkZXNbaW5kZXhdKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGN1cnJlbnRJbmRleCA+IGluZGV4KSB7XG4gICAgICBjdXJyZW50SW5kZXgtLTtcbiAgICAgICRzY29wZS5hY3RpdmUgPSBjdXJyZW50SW5kZXg7XG4gICAgfVxuXG4gICAgLy9jbGVhbiB0aGUgYWN0aXZlIHZhbHVlIHdoZW4gbm8gbW9yZSBzbGlkZVxuICAgIGlmIChzbGlkZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICBjdXJyZW50SW5kZXggPSBudWxsO1xuICAgICAgJHNjb3BlLmFjdGl2ZSA9IG51bGw7XG4gICAgfVxuICB9O1xuXG4gIC8qIGRpcmVjdGlvbjogXCJwcmV2XCIgb3IgXCJuZXh0XCIgKi9cbiAgc2VsZi5zZWxlY3QgPSAkc2NvcGUuc2VsZWN0ID0gZnVuY3Rpb24obmV4dFNsaWRlLCBkaXJlY3Rpb24pIHtcbiAgICB2YXIgbmV4dEluZGV4ID0gZmluZFNsaWRlSW5kZXgobmV4dFNsaWRlLnNsaWRlKTtcbiAgICAvL0RlY2lkZSBkaXJlY3Rpb24gaWYgaXQncyBub3QgZ2l2ZW5cbiAgICBpZiAoZGlyZWN0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGRpcmVjdGlvbiA9IG5leHRJbmRleCA+IHNlbGYuZ2V0Q3VycmVudEluZGV4KCkgPyAnbmV4dCcgOiAncHJldic7XG4gICAgfVxuICAgIC8vUHJldmVudCB0aGlzIHVzZXItdHJpZ2dlcmVkIHRyYW5zaXRpb24gZnJvbSBvY2N1cnJpbmcgaWYgdGhlcmUgaXMgYWxyZWFkeSBvbmUgaW4gcHJvZ3Jlc3NcbiAgICBpZiAobmV4dFNsaWRlLnNsaWRlLmluZGV4ICE9PSBjdXJyZW50SW5kZXggJiZcbiAgICAgICEkc2NvcGUuJGN1cnJlbnRUcmFuc2l0aW9uKSB7XG4gICAgICBnb05leHQobmV4dFNsaWRlLnNsaWRlLCBuZXh0SW5kZXgsIGRpcmVjdGlvbik7XG4gICAgfVxuICB9O1xuXG4gIC8qIEFsbG93IG91dHNpZGUgcGVvcGxlIHRvIGNhbGwgaW5kZXhPZiBvbiBzbGlkZXMgYXJyYXkgKi9cbiAgJHNjb3BlLmluZGV4T2ZTbGlkZSA9IGZ1bmN0aW9uKHNsaWRlKSB7XG4gICAgcmV0dXJuICtzbGlkZS5zbGlkZS5pbmRleDtcbiAgfTtcblxuICAkc2NvcGUuaXNBY3RpdmUgPSBmdW5jdGlvbihzbGlkZSkge1xuICAgIHJldHVybiAkc2NvcGUuYWN0aXZlID09PSBzbGlkZS5zbGlkZS5pbmRleDtcbiAgfTtcblxuICAkc2NvcGUuaXNQcmV2RGlzYWJsZWQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gJHNjb3BlLmFjdGl2ZSA9PT0gMCAmJiAkc2NvcGUubm9XcmFwKCk7XG4gIH07XG5cbiAgJHNjb3BlLmlzTmV4dERpc2FibGVkID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICRzY29wZS5hY3RpdmUgPT09IHNsaWRlcy5sZW5ndGggLSAxICYmICRzY29wZS5ub1dyYXAoKTtcbiAgfTtcblxuICAkc2NvcGUucGF1c2UgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoISRzY29wZS5ub1BhdXNlKSB7XG4gICAgICBpc1BsYXlpbmcgPSBmYWxzZTtcbiAgICAgIHJlc2V0VGltZXIoKTtcbiAgICB9XG4gIH07XG5cbiAgJHNjb3BlLnBsYXkgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoIWlzUGxheWluZykge1xuICAgICAgaXNQbGF5aW5nID0gdHJ1ZTtcbiAgICAgIHJlc3RhcnRUaW1lcigpO1xuICAgIH1cbiAgfTtcblxuICAkZWxlbWVudC5vbignbW91c2VlbnRlcicsICRzY29wZS5wYXVzZSk7XG4gICRlbGVtZW50Lm9uKCdtb3VzZWxlYXZlJywgJHNjb3BlLnBsYXkpO1xuXG4gICRzY29wZS4kb24oJyRkZXN0cm95JywgZnVuY3Rpb24oKSB7XG4gICAgZGVzdHJveWVkID0gdHJ1ZTtcbiAgICByZXNldFRpbWVyKCk7XG4gIH0pO1xuXG4gICRzY29wZS4kd2F0Y2goJ25vVHJhbnNpdGlvbicsIGZ1bmN0aW9uKG5vVHJhbnNpdGlvbikge1xuICAgICRhbmltYXRlLmVuYWJsZWQoJGVsZW1lbnQsICFub1RyYW5zaXRpb24pO1xuICB9KTtcblxuICAkc2NvcGUuJHdhdGNoKCdpbnRlcnZhbCcsIHJlc3RhcnRUaW1lcik7XG5cbiAgJHNjb3BlLiR3YXRjaENvbGxlY3Rpb24oJ3NsaWRlcycsIHJlc2V0VHJhbnNpdGlvbik7XG5cbiAgJHNjb3BlLiR3YXRjaCgnYWN0aXZlJywgZnVuY3Rpb24oaW5kZXgpIHtcbiAgICBpZiAoYW5ndWxhci5pc051bWJlcihpbmRleCkgJiYgY3VycmVudEluZGV4ICE9PSBpbmRleCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzbGlkZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHNsaWRlc1tpXS5zbGlkZS5pbmRleCA9PT0gaW5kZXgpIHtcbiAgICAgICAgICBpbmRleCA9IGk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHNsaWRlID0gc2xpZGVzW2luZGV4XTtcbiAgICAgIGlmIChzbGlkZSkge1xuICAgICAgICBzZXRBY3RpdmUoaW5kZXgpO1xuICAgICAgICBzZWxmLnNlbGVjdChzbGlkZXNbaW5kZXhdKTtcbiAgICAgICAgY3VycmVudEluZGV4ID0gaW5kZXg7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICBmdW5jdGlvbiBnZXRTbGlkZUJ5SW5kZXgoaW5kZXgpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHNsaWRlcy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgIGlmIChzbGlkZXNbaV0uaW5kZXggPT09IGluZGV4KSB7XG4gICAgICAgIHJldHVybiBzbGlkZXNbaV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2V0QWN0aXZlKGluZGV4KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzbGlkZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHNsaWRlc1tpXS5zbGlkZS5hY3RpdmUgPSBpID09PSBpbmRleDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnb05leHQoc2xpZGUsIGluZGV4LCBkaXJlY3Rpb24pIHtcbiAgICBpZiAoZGVzdHJveWVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgYW5ndWxhci5leHRlbmQoc2xpZGUsIHtkaXJlY3Rpb246IGRpcmVjdGlvbn0pO1xuICAgIGFuZ3VsYXIuZXh0ZW5kKHNsaWRlc1tjdXJyZW50SW5kZXhdLnNsaWRlIHx8IHt9LCB7ZGlyZWN0aW9uOiBkaXJlY3Rpb259KTtcbiAgICBpZiAoJGFuaW1hdGUuZW5hYmxlZCgkZWxlbWVudCkgJiYgISRzY29wZS4kY3VycmVudFRyYW5zaXRpb24gJiZcbiAgICAgIHNsaWRlc1tpbmRleF0uZWxlbWVudCAmJiBzZWxmLnNsaWRlcy5sZW5ndGggPiAxKSB7XG4gICAgICBzbGlkZXNbaW5kZXhdLmVsZW1lbnQuZGF0YShTTElERV9ESVJFQ1RJT04sIHNsaWRlLmRpcmVjdGlvbik7XG4gICAgICB2YXIgY3VycmVudElkeCA9IHNlbGYuZ2V0Q3VycmVudEluZGV4KCk7XG5cbiAgICAgIGlmIChhbmd1bGFyLmlzTnVtYmVyKGN1cnJlbnRJZHgpICYmIHNsaWRlc1tjdXJyZW50SWR4XS5lbGVtZW50KSB7XG4gICAgICAgIHNsaWRlc1tjdXJyZW50SWR4XS5lbGVtZW50LmRhdGEoU0xJREVfRElSRUNUSU9OLCBzbGlkZS5kaXJlY3Rpb24pO1xuICAgICAgfVxuXG4gICAgICAkc2NvcGUuJGN1cnJlbnRUcmFuc2l0aW9uID0gdHJ1ZTtcbiAgICAgICRhbmltYXRlLm9uKCdhZGRDbGFzcycsIHNsaWRlc1tpbmRleF0uZWxlbWVudCwgZnVuY3Rpb24oZWxlbWVudCwgcGhhc2UpIHtcbiAgICAgICAgaWYgKHBoYXNlID09PSAnY2xvc2UnKSB7XG4gICAgICAgICAgJHNjb3BlLiRjdXJyZW50VHJhbnNpdGlvbiA9IG51bGw7XG4gICAgICAgICAgJGFuaW1hdGUub2ZmKCdhZGRDbGFzcycsIGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAkc2NvcGUuYWN0aXZlID0gc2xpZGUuaW5kZXg7XG4gICAgY3VycmVudEluZGV4ID0gc2xpZGUuaW5kZXg7XG4gICAgc2V0QWN0aXZlKGluZGV4KTtcblxuICAgIC8vZXZlcnkgdGltZSB5b3UgY2hhbmdlIHNsaWRlcywgcmVzZXQgdGhlIHRpbWVyXG4gICAgcmVzdGFydFRpbWVyKCk7XG4gIH1cblxuICBmdW5jdGlvbiBmaW5kU2xpZGVJbmRleChzbGlkZSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2xpZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoc2xpZGVzW2ldLnNsaWRlID09PSBzbGlkZSkge1xuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZXNldFRpbWVyKCkge1xuICAgIGlmIChjdXJyZW50SW50ZXJ2YWwpIHtcbiAgICAgICRpbnRlcnZhbC5jYW5jZWwoY3VycmVudEludGVydmFsKTtcbiAgICAgIGN1cnJlbnRJbnRlcnZhbCA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRUcmFuc2l0aW9uKHNsaWRlcykge1xuICAgIGlmICghc2xpZGVzLmxlbmd0aCkge1xuICAgICAgJHNjb3BlLiRjdXJyZW50VHJhbnNpdGlvbiA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVzdGFydFRpbWVyKCkge1xuICAgIHJlc2V0VGltZXIoKTtcbiAgICB2YXIgaW50ZXJ2YWwgPSArJHNjb3BlLmludGVydmFsO1xuICAgIGlmICghaXNOYU4oaW50ZXJ2YWwpICYmIGludGVydmFsID4gMCkge1xuICAgICAgY3VycmVudEludGVydmFsID0gJGludGVydmFsKHRpbWVyRm4sIGludGVydmFsKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB0aW1lckZuKCkge1xuICAgIHZhciBpbnRlcnZhbCA9ICskc2NvcGUuaW50ZXJ2YWw7XG4gICAgaWYgKGlzUGxheWluZyAmJiAhaXNOYU4oaW50ZXJ2YWwpICYmIGludGVydmFsID4gMCAmJiBzbGlkZXMubGVuZ3RoKSB7XG4gICAgICAkc2NvcGUubmV4dCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAkc2NvcGUucGF1c2UoKTtcbiAgICB9XG4gIH1cbn1dKVxuXG4uZGlyZWN0aXZlKCd1aWJDYXJvdXNlbCcsIGZ1bmN0aW9uKCkge1xuICByZXR1cm4ge1xuICAgIHRyYW5zY2x1ZGU6IHRydWUsXG4gICAgY29udHJvbGxlcjogJ1VpYkNhcm91c2VsQ29udHJvbGxlcicsXG4gICAgY29udHJvbGxlckFzOiAnY2Fyb3VzZWwnLFxuICAgIHJlc3RyaWN0OiAnQScsXG4gICAgdGVtcGxhdGVVcmw6IGZ1bmN0aW9uKGVsZW1lbnQsIGF0dHJzKSB7XG4gICAgICByZXR1cm4gYXR0cnMudGVtcGxhdGVVcmwgfHwgJ3VpYi90ZW1wbGF0ZS9jYXJvdXNlbC9jYXJvdXNlbC5odG1sJztcbiAgICB9LFxuICAgIHNjb3BlOiB7XG4gICAgICBhY3RpdmU6ICc9JyxcbiAgICAgIGludGVydmFsOiAnPScsXG4gICAgICBub1RyYW5zaXRpb246ICc9JyxcbiAgICAgIG5vUGF1c2U6ICc9JyxcbiAgICAgIG5vV3JhcDogJyYnXG4gICAgfVxuICB9O1xufSlcblxuLmRpcmVjdGl2ZSgndWliU2xpZGUnLCBbJyRhbmltYXRlJywgZnVuY3Rpb24oJGFuaW1hdGUpIHtcbiAgcmV0dXJuIHtcbiAgICByZXF1aXJlOiAnXnVpYkNhcm91c2VsJyxcbiAgICByZXN0cmljdDogJ0EnLFxuICAgIHRyYW5zY2x1ZGU6IHRydWUsXG4gICAgdGVtcGxhdGVVcmw6IGZ1bmN0aW9uKGVsZW1lbnQsIGF0dHJzKSB7XG4gICAgICByZXR1cm4gYXR0cnMudGVtcGxhdGVVcmwgfHwgJ3VpYi90ZW1wbGF0ZS9jYXJvdXNlbC9zbGlkZS5odG1sJztcbiAgICB9LFxuICAgIHNjb3BlOiB7XG4gICAgICBhY3R1YWw6ICc9PycsXG4gICAgICBpbmRleDogJz0/J1xuICAgIH0sXG4gICAgbGluazogZnVuY3Rpb24gKHNjb3BlLCBlbGVtZW50LCBhdHRycywgY2Fyb3VzZWxDdHJsKSB7XG4gICAgICBlbGVtZW50LmFkZENsYXNzKCdpdGVtJyk7XG4gICAgICBjYXJvdXNlbEN0cmwuYWRkU2xpZGUoc2NvcGUsIGVsZW1lbnQpO1xuICAgICAgLy93aGVuIHRoZSBzY29wZSBpcyBkZXN0cm95ZWQgdGhlbiByZW1vdmUgdGhlIHNsaWRlIGZyb20gdGhlIGN1cnJlbnQgc2xpZGVzIGFycmF5XG4gICAgICBzY29wZS4kb24oJyRkZXN0cm95JywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGNhcm91c2VsQ3RybC5yZW1vdmVTbGlkZShzY29wZSk7XG4gICAgICB9KTtcblxuICAgICAgc2NvcGUuJHdhdGNoKCdhY3RpdmUnLCBmdW5jdGlvbihhY3RpdmUpIHtcbiAgICAgICAgJGFuaW1hdGVbYWN0aXZlID8gJ2FkZENsYXNzJyA6ICdyZW1vdmVDbGFzcyddKGVsZW1lbnQsICdhY3RpdmUnKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbn1dKVxuXG4uYW5pbWF0aW9uKCcuaXRlbScsIFsnJGFuaW1hdGVDc3MnLFxuZnVuY3Rpb24oJGFuaW1hdGVDc3MpIHtcbiAgdmFyIFNMSURFX0RJUkVDVElPTiA9ICd1aWItc2xpZGVEaXJlY3Rpb24nO1xuXG4gIGZ1bmN0aW9uIHJlbW92ZUNsYXNzKGVsZW1lbnQsIGNsYXNzTmFtZSwgY2FsbGJhY2spIHtcbiAgICBlbGVtZW50LnJlbW92ZUNsYXNzKGNsYXNzTmFtZSk7XG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICBjYWxsYmFjaygpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgYmVmb3JlQWRkQ2xhc3M6IGZ1bmN0aW9uKGVsZW1lbnQsIGNsYXNzTmFtZSwgZG9uZSkge1xuICAgICAgaWYgKGNsYXNzTmFtZSA9PT0gJ2FjdGl2ZScpIHtcbiAgICAgICAgdmFyIHN0b3BwZWQgPSBmYWxzZTtcbiAgICAgICAgdmFyIGRpcmVjdGlvbiA9IGVsZW1lbnQuZGF0YShTTElERV9ESVJFQ1RJT04pO1xuICAgICAgICB2YXIgZGlyZWN0aW9uQ2xhc3MgPSBkaXJlY3Rpb24gPT09ICduZXh0JyA/ICdsZWZ0JyA6ICdyaWdodCc7XG4gICAgICAgIHZhciByZW1vdmVDbGFzc0ZuID0gcmVtb3ZlQ2xhc3MuYmluZCh0aGlzLCBlbGVtZW50LFxuICAgICAgICAgIGRpcmVjdGlvbkNsYXNzICsgJyAnICsgZGlyZWN0aW9uLCBkb25lKTtcbiAgICAgICAgZWxlbWVudC5hZGRDbGFzcyhkaXJlY3Rpb24pO1xuXG4gICAgICAgICRhbmltYXRlQ3NzKGVsZW1lbnQsIHthZGRDbGFzczogZGlyZWN0aW9uQ2xhc3N9KVxuICAgICAgICAgIC5zdGFydCgpXG4gICAgICAgICAgLmRvbmUocmVtb3ZlQ2xhc3NGbik7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHN0b3BwZWQgPSB0cnVlO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgZG9uZSgpO1xuICAgIH0sXG4gICAgYmVmb3JlUmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uIChlbGVtZW50LCBjbGFzc05hbWUsIGRvbmUpIHtcbiAgICAgIGlmIChjbGFzc05hbWUgPT09ICdhY3RpdmUnKSB7XG4gICAgICAgIHZhciBzdG9wcGVkID0gZmFsc2U7XG4gICAgICAgIHZhciBkaXJlY3Rpb24gPSBlbGVtZW50LmRhdGEoU0xJREVfRElSRUNUSU9OKTtcbiAgICAgICAgdmFyIGRpcmVjdGlvbkNsYXNzID0gZGlyZWN0aW9uID09PSAnbmV4dCcgPyAnbGVmdCcgOiAncmlnaHQnO1xuICAgICAgICB2YXIgcmVtb3ZlQ2xhc3NGbiA9IHJlbW92ZUNsYXNzLmJpbmQodGhpcywgZWxlbWVudCwgZGlyZWN0aW9uQ2xhc3MsIGRvbmUpO1xuXG4gICAgICAgICRhbmltYXRlQ3NzKGVsZW1lbnQsIHthZGRDbGFzczogZGlyZWN0aW9uQ2xhc3N9KVxuICAgICAgICAgIC5zdGFydCgpXG4gICAgICAgICAgLmRvbmUocmVtb3ZlQ2xhc3NGbik7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHN0b3BwZWQgPSB0cnVlO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgZG9uZSgpO1xuICAgIH1cbiAgfTtcbn1dKTtcblxuYW5ndWxhci5tb2R1bGUoJ3VpLmJvb3RzdHJhcC5kYXRlcGFyc2VyJywgW10pXG5cbi5zZXJ2aWNlKCd1aWJEYXRlUGFyc2VyJywgWyckbG9nJywgJyRsb2NhbGUnLCAnZGF0ZUZpbHRlcicsICdvcmRlckJ5RmlsdGVyJywgJ2ZpbHRlckZpbHRlcicsIGZ1bmN0aW9uKCRsb2csICRsb2NhbGUsIGRhdGVGaWx0ZXIsIG9yZGVyQnlGaWx0ZXIsIGZpbHRlckZpbHRlcikge1xuICAvLyBQdWxsZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vbWJvc3RvY2svZDMvYmxvYi9tYXN0ZXIvc3JjL2Zvcm1hdC9yZXF1b3RlLmpzXG4gIHZhciBTUEVDSUFMX0NIQVJBQ1RFUlNfUkVHRVhQID0gL1tcXFxcXFxeXFwkXFwqXFwrXFw/XFx8XFxbXFxdXFwoXFwpXFwuXFx7XFx9XS9nO1xuXG4gIHZhciBsb2NhbGVJZDtcbiAgdmFyIGZvcm1hdENvZGVUb1JlZ2V4O1xuXG4gIHRoaXMuaW5pdCA9IGZ1bmN0aW9uKCkge1xuICAgIGxvY2FsZUlkID0gJGxvY2FsZS5pZDtcblxuICAgIHRoaXMucGFyc2VycyA9IHt9O1xuICAgIHRoaXMuZm9ybWF0dGVycyA9IHt9O1xuXG4gICAgZm9ybWF0Q29kZVRvUmVnZXggPSBbXG4gICAgICB7XG4gICAgICAgIGtleTogJ3l5eXknLFxuICAgICAgICByZWdleDogJ1xcXFxkezR9JyxcbiAgICAgICAgYXBwbHk6IGZ1bmN0aW9uKHZhbHVlKSB7IHRoaXMueWVhciA9ICt2YWx1ZTsgfSxcbiAgICAgICAgZm9ybWF0dGVyOiBmdW5jdGlvbihkYXRlKSB7XG4gICAgICAgICAgdmFyIF9kYXRlID0gbmV3IERhdGUoKTtcbiAgICAgICAgICBfZGF0ZS5zZXRGdWxsWWVhcihNYXRoLmFicyhkYXRlLmdldEZ1bGxZZWFyKCkpKTtcbiAgICAgICAgICByZXR1cm4gZGF0ZUZpbHRlcihfZGF0ZSwgJ3l5eXknKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAga2V5OiAneXknLFxuICAgICAgICByZWdleDogJ1xcXFxkezJ9JyxcbiAgICAgICAgYXBwbHk6IGZ1bmN0aW9uKHZhbHVlKSB7IHZhbHVlID0gK3ZhbHVlOyB0aGlzLnllYXIgPSB2YWx1ZSA8IDY5ID8gdmFsdWUgKyAyMDAwIDogdmFsdWUgKyAxOTAwOyB9LFxuICAgICAgICBmb3JtYXR0ZXI6IGZ1bmN0aW9uKGRhdGUpIHtcbiAgICAgICAgICB2YXIgX2RhdGUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgIF9kYXRlLnNldEZ1bGxZZWFyKE1hdGguYWJzKGRhdGUuZ2V0RnVsbFllYXIoKSkpO1xuICAgICAgICAgIHJldHVybiBkYXRlRmlsdGVyKF9kYXRlLCAneXknKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAga2V5OiAneScsXG4gICAgICAgIHJlZ2V4OiAnXFxcXGR7MSw0fScsXG4gICAgICAgIGFwcGx5OiBmdW5jdGlvbih2YWx1ZSkgeyB0aGlzLnllYXIgPSArdmFsdWU7IH0sXG4gICAgICAgIGZvcm1hdHRlcjogZnVuY3Rpb24oZGF0ZSkge1xuICAgICAgICAgIHZhciBfZGF0ZSA9IG5ldyBEYXRlKCk7XG4gICAgICAgICAgX2RhdGUuc2V0RnVsbFllYXIoTWF0aC5hYnMoZGF0ZS5nZXRGdWxsWWVhcigpKSk7XG4gICAgICAgICAgcmV0dXJuIGRhdGVGaWx0ZXIoX2RhdGUsICd5Jyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGtleTogJ00hJyxcbiAgICAgICAgcmVnZXg6ICcwP1sxLTldfDFbMC0yXScsXG4gICAgICAgIGFwcGx5OiBmdW5jdGlvbih2YWx1ZSkgeyB0aGlzLm1vbnRoID0gdmFsdWUgLSAxOyB9LFxuICAgICAgICBmb3JtYXR0ZXI6IGZ1bmN0aW9uKGRhdGUpIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBkYXRlLmdldE1vbnRoKCk7XG4gICAgICAgICAgaWYgKC9eWzAtOV0kLy50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGVGaWx0ZXIoZGF0ZSwgJ01NJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGRhdGVGaWx0ZXIoZGF0ZSwgJ00nKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAga2V5OiAnTU1NTScsXG4gICAgICAgIHJlZ2V4OiAkbG9jYWxlLkRBVEVUSU1FX0ZPUk1BVFMuTU9OVEguam9pbignfCcpLFxuICAgICAgICBhcHBseTogZnVuY3Rpb24odmFsdWUpIHsgdGhpcy5tb250aCA9ICRsb2NhbGUuREFURVRJTUVfRk9STUFUUy5NT05USC5pbmRleE9mKHZhbHVlKTsgfSxcbiAgICAgICAgZm9ybWF0dGVyOiBmdW5jdGlvbihkYXRlKSB7IHJldHVybiBkYXRlRmlsdGVyKGRhdGUsICdNTU1NJyk7IH1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGtleTogJ01NTScsXG4gICAgICAgIHJlZ2V4OiAkbG9jYWxlLkRBVEVUSU1FX0ZPUk1BVFMuU0hPUlRNT05USC5qb2luKCd8JyksXG4gICAgICAgIGFwcGx5OiBmdW5jdGlvbih2YWx1ZSkgeyB0aGlzLm1vbnRoID0gJGxvY2FsZS5EQVRFVElNRV9GT1JNQVRTLlNIT1JUTU9OVEguaW5kZXhPZih2YWx1ZSk7IH0sXG4gICAgICAgIGZvcm1hdHRlcjogZnVuY3Rpb24oZGF0ZSkgeyByZXR1cm4gZGF0ZUZpbHRlcihkYXRlLCAnTU1NJyk7IH1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGtleTogJ01NJyxcbiAgICAgICAgcmVnZXg6ICcwWzEtOV18MVswLTJdJyxcbiAgICAgICAgYXBwbHk6IGZ1bmN0aW9uKHZhbHVlKSB7IHRoaXMubW9udGggPSB2YWx1ZSAtIDE7IH0sXG4gICAgICAgIGZvcm1hdHRlcjogZnVuY3Rpb24oZGF0ZSkgeyByZXR1cm4gZGF0ZUZpbHRlcihkYXRlLCAnTU0nKTsgfVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAga2V5OiAnTScsXG4gICAgICAgIHJlZ2V4OiAnWzEtOV18MVswLTJdJyxcbiAgICAgICAgYXBwbHk6IGZ1bmN0aW9uKHZhbHVlKSB7IHRoaXMubW9udGggPSB2YWx1ZSAtIDE7IH0sXG4gICAgICAgIGZvcm1hdHRlcjogZnVuY3Rpb24oZGF0ZSkgeyByZXR1cm4gZGF0ZUZpbHRlcihkYXRlLCAnTScpOyB9XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBrZXk6ICdkIScsXG4gICAgICAgIHJlZ2V4OiAnWzAtMl0/WzAtOV17MX18M1swLTFdezF9JyxcbiAgICAgICAgYXBwbHk6IGZ1bmN0aW9uKHZhbHVlKSB7IHRoaXMuZGF0ZSA9ICt2YWx1ZTsgfSxcbiAgICAgICAgZm9ybWF0dGVyOiBmdW5jdGlvbihkYXRlKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gZGF0ZS5nZXREYXRlKCk7XG4gICAgICAgICAgaWYgKC9eWzEtOV0kLy50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGVGaWx0ZXIoZGF0ZSwgJ2RkJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGRhdGVGaWx0ZXIoZGF0ZSwgJ2QnKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAga2V5OiAnZGQnLFxuICAgICAgICByZWdleDogJ1swLTJdWzAtOV17MX18M1swLTFdezF9JyxcbiAgICAgICAgYXBwbHk6IGZ1bmN0aW9uKHZhbHVlKSB7IHRoaXMuZGF0ZSA9ICt2YWx1ZTsgfSxcbiAgICAgICAgZm9ybWF0dGVyOiBmdW5jdGlvbihkYXRlKSB7IHJldHVybiBkYXRlRmlsdGVyKGRhdGUsICdkZCcpOyB9XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBrZXk6ICdkJyxcbiAgICAgICAgcmVnZXg6ICdbMS0yXT9bMC05XXsxfXwzWzAtMV17MX0nLFxuICAgICAgICBhcHBseTogZnVuY3Rpb24odmFsdWUpIHsgdGhpcy5kYXRlID0gK3ZhbHVlOyB9LFxuICAgICAgICBmb3JtYXR0ZXI6IGZ1bmN0aW9uKGRhdGUpIHsgcmV0dXJuIGRhdGVGaWx0ZXIoZGF0ZSwgJ2QnKTsgfVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAga2V5OiAnRUVFRScsXG4gICAgICAgIHJlZ2V4OiAkbG9jYWxlLkRBVEVUSU1FX0ZPUk1BVFMuREFZLmpvaW4oJ3wnKSxcbiAgICAgICAgZm9ybWF0dGVyOiBmdW5jdGlvbihkYXRlKSB7IHJldHVybiBkYXRlRmlsdGVyKGRhdGUsICdFRUVFJyk7IH1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGtleTogJ0VFRScsXG4gICAgICAgIHJlZ2V4OiAkbG9jYWxlLkRBVEVUSU1FX0ZPUk1BVFMuU0hPUlREQVkuam9pbignfCcpLFxuICAgICAgICBmb3JtYXR0ZXI6IGZ1bmN0aW9uKGRhdGUpIHsgcmV0dXJuIGRhdGVGaWx0ZXIoZGF0ZSwgJ0VFRScpOyB9XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBrZXk6ICdISCcsXG4gICAgICAgIHJlZ2V4OiAnKD86MHwxKVswLTldfDJbMC0zXScsXG4gICAgICAgIGFwcGx5OiBmdW5jdGlvbih2YWx1ZSkgeyB0aGlzLmhvdXJzID0gK3ZhbHVlOyB9LFxuICAgICAgICBmb3JtYXR0ZXI6IGZ1bmN0aW9uKGRhdGUpIHsgcmV0dXJuIGRhdGVGaWx0ZXIoZGF0ZSwgJ0hIJyk7IH1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGtleTogJ2hoJyxcbiAgICAgICAgcmVnZXg6ICcwWzAtOV18MVswLTJdJyxcbiAgICAgICAgYXBwbHk6IGZ1bmN0aW9uKHZhbHVlKSB7IHRoaXMuaG91cnMgPSArdmFsdWU7IH0sXG4gICAgICAgIGZvcm1hdHRlcjogZnVuY3Rpb24oZGF0ZSkgeyByZXR1cm4gZGF0ZUZpbHRlcihkYXRlLCAnaGgnKTsgfVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAga2V5OiAnSCcsXG4gICAgICAgIHJlZ2V4OiAnMT9bMC05XXwyWzAtM10nLFxuICAgICAgICBhcHBseTogZnVuY3Rpb24odmFsdWUpIHsgdGhpcy5ob3VycyA9ICt2YWx1ZTsgfSxcbiAgICAgICAgZm9ybWF0dGVyOiBmdW5jdGlvbihkYXRlKSB7IHJldHVybiBkYXRlRmlsdGVyKGRhdGUsICdIJyk7IH1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGtleTogJ2gnLFxuICAgICAgICByZWdleDogJ1swLTldfDFbMC0yXScsXG4gICAgICAgIGFwcGx5OiBmdW5jdGlvbih2YWx1ZSkgeyB0aGlzLmhvdXJzID0gK3ZhbHVlOyB9LFxuICAgICAgICBmb3JtYXR0ZXI6IGZ1bmN0aW9uKGRhdGUpIHsgcmV0dXJuIGRhdGVGaWx0ZXIoZGF0ZSwgJ2gnKTsgfVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAga2V5OiAnbW0nLFxuICAgICAgICByZWdleDogJ1swLTVdWzAtOV0nLFxuICAgICAgICBhcHBseTogZnVuY3Rpb24odmFsdWUpIHsgdGhpcy5taW51dGVzID0gK3ZhbHVlOyB9LFxuICAgICAgICBmb3JtYXR0ZXI6IGZ1bmN0aW9uKGRhdGUpIHsgcmV0dXJuIGRhdGVGaWx0ZXIoZGF0ZSwgJ21tJyk7IH1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGtleTogJ20nLFxuICAgICAgICByZWdleDogJ1swLTldfFsxLTVdWzAtOV0nLFxuICAgICAgICBhcHBseTogZnVuY3Rpb24odmFsdWUpIHsgdGhpcy5taW51dGVzID0gK3ZhbHVlOyB9LFxuICAgICAgICBmb3JtYXR0ZXI6IGZ1bmN0aW9uKGRhdGUpIHsgcmV0dXJuIGRhdGVGaWx0ZXIoZGF0ZSwgJ20nKTsgfVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAga2V5OiAnc3NzJyxcbiAgICAgICAgcmVnZXg6ICdbMC05XVswLTldWzAtOV0nLFxuICAgICAgICBhcHBseTogZnVuY3Rpb24odmFsdWUpIHsgdGhpcy5taWxsaXNlY29uZHMgPSArdmFsdWU7IH0sXG4gICAgICAgIGZvcm1hdHRlcjogZnVuY3Rpb24oZGF0ZSkgeyByZXR1cm4gZGF0ZUZpbHRlcihkYXRlLCAnc3NzJyk7IH1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGtleTogJ3NzJyxcbiAgICAgICAgcmVnZXg6ICdbMC01XVswLTldJyxcbiAgICAgICAgYXBwbHk6IGZ1bmN0aW9uKHZhbHVlKSB7IHRoaXMuc2Vjb25kcyA9ICt2YWx1ZTsgfSxcbiAgICAgICAgZm9ybWF0dGVyOiBmdW5jdGlvbihkYXRlKSB7IHJldHVybiBkYXRlRmlsdGVyKGRhdGUsICdzcycpOyB9XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBrZXk6ICdzJyxcbiAgICAgICAgcmVnZXg6ICdbMC05XXxbMS01XVswLTldJyxcbiAgICAgICAgYXBwbHk6IGZ1bmN0aW9uKHZhbHVlKSB7IHRoaXMuc2Vjb25kcyA9ICt2YWx1ZTsgfSxcbiAgICAgICAgZm9ybWF0dGVyOiBmdW5jdGlvbihkYXRlKSB7IHJldHVybiBkYXRlRmlsdGVyKGRhdGUsICdzJyk7IH1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGtleTogJ2EnLFxuICAgICAgICByZWdleDogJGxvY2FsZS5EQVRFVElNRV9GT1JNQVRTLkFNUE1TLmpvaW4oJ3wnKSxcbiAgICAgICAgYXBwbHk6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgaWYgKHRoaXMuaG91cnMgPT09IDEyKSB7XG4gICAgICAgICAgICB0aGlzLmhvdXJzID0gMDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodmFsdWUgPT09ICdQTScpIHtcbiAgICAgICAgICAgIHRoaXMuaG91cnMgKz0gMTI7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBmb3JtYXR0ZXI6IGZ1bmN0aW9uKGRhdGUpIHsgcmV0dXJuIGRhdGVGaWx0ZXIoZGF0ZSwgJ2EnKTsgfVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAga2V5OiAnWicsXG4gICAgICAgIHJlZ2V4OiAnWystXVxcXFxkezR9JyxcbiAgICAgICAgYXBwbHk6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgdmFyIG1hdGNoZXMgPSB2YWx1ZS5tYXRjaCgvKFsrLV0pKFxcZHsyfSkoXFxkezJ9KS8pLFxuICAgICAgICAgICAgc2lnbiA9IG1hdGNoZXNbMV0sXG4gICAgICAgICAgICBob3VycyA9IG1hdGNoZXNbMl0sXG4gICAgICAgICAgICBtaW51dGVzID0gbWF0Y2hlc1szXTtcbiAgICAgICAgICB0aGlzLmhvdXJzICs9IHRvSW50KHNpZ24gKyBob3Vycyk7XG4gICAgICAgICAgdGhpcy5taW51dGVzICs9IHRvSW50KHNpZ24gKyBtaW51dGVzKTtcbiAgICAgICAgfSxcbiAgICAgICAgZm9ybWF0dGVyOiBmdW5jdGlvbihkYXRlKSB7XG4gICAgICAgICAgcmV0dXJuIGRhdGVGaWx0ZXIoZGF0ZSwgJ1onKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAga2V5OiAnd3cnLFxuICAgICAgICByZWdleDogJ1swLTRdWzAtOV18NVswLTNdJyxcbiAgICAgICAgZm9ybWF0dGVyOiBmdW5jdGlvbihkYXRlKSB7IHJldHVybiBkYXRlRmlsdGVyKGRhdGUsICd3dycpOyB9XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBrZXk6ICd3JyxcbiAgICAgICAgcmVnZXg6ICdbMC05XXxbMS00XVswLTldfDVbMC0zXScsXG4gICAgICAgIGZvcm1hdHRlcjogZnVuY3Rpb24oZGF0ZSkgeyByZXR1cm4gZGF0ZUZpbHRlcihkYXRlLCAndycpOyB9XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBrZXk6ICdHR0dHJyxcbiAgICAgICAgcmVnZXg6ICRsb2NhbGUuREFURVRJTUVfRk9STUFUUy5FUkFOQU1FUy5qb2luKCd8JykucmVwbGFjZSgvXFxzL2csICdcXFxccycpLFxuICAgICAgICBmb3JtYXR0ZXI6IGZ1bmN0aW9uKGRhdGUpIHsgcmV0dXJuIGRhdGVGaWx0ZXIoZGF0ZSwgJ0dHR0cnKTsgfVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAga2V5OiAnR0dHJyxcbiAgICAgICAgcmVnZXg6ICRsb2NhbGUuREFURVRJTUVfRk9STUFUUy5FUkFTLmpvaW4oJ3wnKSxcbiAgICAgICAgZm9ybWF0dGVyOiBmdW5jdGlvbihkYXRlKSB7IHJldHVybiBkYXRlRmlsdGVyKGRhdGUsICdHR0cnKTsgfVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAga2V5OiAnR0cnLFxuICAgICAgICByZWdleDogJGxvY2FsZS5EQVRFVElNRV9GT1JNQVRTLkVSQVMuam9pbignfCcpLFxuICAgICAgICBmb3JtYXR0ZXI6IGZ1bmN0aW9uKGRhdGUpIHsgcmV0dXJuIGRhdGVGaWx0ZXIoZGF0ZSwgJ0dHJyk7IH1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGtleTogJ0cnLFxuICAgICAgICByZWdleDogJGxvY2FsZS5EQVRFVElNRV9GT1JNQVRTLkVSQVMuam9pbignfCcpLFxuICAgICAgICBmb3JtYXR0ZXI6IGZ1bmN0aW9uKGRhdGUpIHsgcmV0dXJuIGRhdGVGaWx0ZXIoZGF0ZSwgJ0cnKTsgfVxuICAgICAgfVxuICAgIF07XG5cbiAgICBpZiAoYW5ndWxhci52ZXJzaW9uLm1ham9yID49IDEgJiYgYW5ndWxhci52ZXJzaW9uLm1pbm9yID4gNCkge1xuICAgICAgZm9ybWF0Q29kZVRvUmVnZXgucHVzaCh7XG4gICAgICAgIGtleTogJ0xMTEwnLFxuICAgICAgICByZWdleDogJGxvY2FsZS5EQVRFVElNRV9GT1JNQVRTLlNUQU5EQUxPTkVNT05USC5qb2luKCd8JyksXG4gICAgICAgIGFwcGx5OiBmdW5jdGlvbih2YWx1ZSkgeyB0aGlzLm1vbnRoID0gJGxvY2FsZS5EQVRFVElNRV9GT1JNQVRTLlNUQU5EQUxPTkVNT05USC5pbmRleE9mKHZhbHVlKTsgfSxcbiAgICAgICAgZm9ybWF0dGVyOiBmdW5jdGlvbihkYXRlKSB7IHJldHVybiBkYXRlRmlsdGVyKGRhdGUsICdMTExMJyk7IH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICB0aGlzLmluaXQoKTtcblxuICBmdW5jdGlvbiBnZXRGb3JtYXRDb2RlVG9SZWdleChrZXkpIHtcbiAgICByZXR1cm4gZmlsdGVyRmlsdGVyKGZvcm1hdENvZGVUb1JlZ2V4LCB7a2V5OiBrZXl9LCB0cnVlKVswXTtcbiAgfVxuXG4gIHRoaXMuZ2V0UGFyc2VyID0gZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciBmID0gZ2V0Rm9ybWF0Q29kZVRvUmVnZXgoa2V5KTtcbiAgICByZXR1cm4gZiAmJiBmLmFwcGx5IHx8IG51bGw7XG4gIH07XG5cbiAgdGhpcy5vdmVycmlkZVBhcnNlciA9IGZ1bmN0aW9uIChrZXksIHBhcnNlcikge1xuICAgIHZhciBmID0gZ2V0Rm9ybWF0Q29kZVRvUmVnZXgoa2V5KTtcbiAgICBpZiAoZiAmJiBhbmd1bGFyLmlzRnVuY3Rpb24ocGFyc2VyKSkge1xuICAgICAgdGhpcy5wYXJzZXJzID0ge307XG4gICAgICBmLmFwcGx5ID0gcGFyc2VyO1xuICAgIH1cbiAgfS5iaW5kKHRoaXMpO1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZVBhcnNlcihmb3JtYXQpIHtcbiAgICB2YXIgbWFwID0gW10sIHJlZ2V4ID0gZm9ybWF0LnNwbGl0KCcnKTtcblxuICAgIC8vIGNoZWNrIGZvciBsaXRlcmFsIHZhbHVlc1xuICAgIHZhciBxdW90ZUluZGV4ID0gZm9ybWF0LmluZGV4T2YoJ1xcJycpO1xuICAgIGlmIChxdW90ZUluZGV4ID4gLTEpIHtcbiAgICAgIHZhciBpbkxpdGVyYWwgPSBmYWxzZTtcbiAgICAgIGZvcm1hdCA9IGZvcm1hdC5zcGxpdCgnJyk7XG4gICAgICBmb3IgKHZhciBpID0gcXVvdGVJbmRleDsgaSA8IGZvcm1hdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaW5MaXRlcmFsKSB7XG4gICAgICAgICAgaWYgKGZvcm1hdFtpXSA9PT0gJ1xcJycpIHtcbiAgICAgICAgICAgIGlmIChpICsgMSA8IGZvcm1hdC5sZW5ndGggJiYgZm9ybWF0W2krMV0gPT09ICdcXCcnKSB7IC8vIGVzY2FwZWQgc2luZ2xlIHF1b3RlXG4gICAgICAgICAgICAgIGZvcm1hdFtpKzFdID0gJyQnO1xuICAgICAgICAgICAgICByZWdleFtpKzFdID0gJyc7XG4gICAgICAgICAgICB9IGVsc2UgeyAvLyBlbmQgb2YgbGl0ZXJhbFxuICAgICAgICAgICAgICByZWdleFtpXSA9ICcnO1xuICAgICAgICAgICAgICBpbkxpdGVyYWwgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZm9ybWF0W2ldID0gJyQnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChmb3JtYXRbaV0gPT09ICdcXCcnKSB7IC8vIHN0YXJ0IG9mIGxpdGVyYWxcbiAgICAgICAgICAgIGZvcm1hdFtpXSA9ICckJztcbiAgICAgICAgICAgIHJlZ2V4W2ldID0gJyc7XG4gICAgICAgICAgICBpbkxpdGVyYWwgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3JtYXQgPSBmb3JtYXQuam9pbignJyk7XG4gICAgfVxuXG4gICAgYW5ndWxhci5mb3JFYWNoKGZvcm1hdENvZGVUb1JlZ2V4LCBmdW5jdGlvbihkYXRhKSB7XG4gICAgICB2YXIgaW5kZXggPSBmb3JtYXQuaW5kZXhPZihkYXRhLmtleSk7XG5cbiAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgIGZvcm1hdCA9IGZvcm1hdC5zcGxpdCgnJyk7XG5cbiAgICAgICAgcmVnZXhbaW5kZXhdID0gJygnICsgZGF0YS5yZWdleCArICcpJztcbiAgICAgICAgZm9ybWF0W2luZGV4XSA9ICckJzsgLy8gQ3VzdG9tIHN5bWJvbCB0byBkZWZpbmUgY29uc3VtZWQgcGFydCBvZiBmb3JtYXRcbiAgICAgICAgZm9yICh2YXIgaSA9IGluZGV4ICsgMSwgbiA9IGluZGV4ICsgZGF0YS5rZXkubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgcmVnZXhbaV0gPSAnJztcbiAgICAgICAgICBmb3JtYXRbaV0gPSAnJCc7XG4gICAgICAgIH1cbiAgICAgICAgZm9ybWF0ID0gZm9ybWF0LmpvaW4oJycpO1xuXG4gICAgICAgIG1hcC5wdXNoKHtcbiAgICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgICAga2V5OiBkYXRhLmtleSxcbiAgICAgICAgICBhcHBseTogZGF0YS5hcHBseSxcbiAgICAgICAgICBtYXRjaGVyOiBkYXRhLnJlZ2V4XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHJlZ2V4OiBuZXcgUmVnRXhwKCdeJyArIHJlZ2V4LmpvaW4oJycpICsgJyQnKSxcbiAgICAgIG1hcDogb3JkZXJCeUZpbHRlcihtYXAsICdpbmRleCcpXG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUZvcm1hdHRlcihmb3JtYXQpIHtcbiAgICB2YXIgZm9ybWF0dGVycyA9IFtdO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgZm9ybWF0dGVyLCBsaXRlcmFsSWR4O1xuICAgIHdoaWxlIChpIDwgZm9ybWF0Lmxlbmd0aCkge1xuICAgICAgaWYgKGFuZ3VsYXIuaXNOdW1iZXIobGl0ZXJhbElkeCkpIHtcbiAgICAgICAgaWYgKGZvcm1hdC5jaGFyQXQoaSkgPT09ICdcXCcnKSB7XG4gICAgICAgICAgaWYgKGkgKyAxID49IGZvcm1hdC5sZW5ndGggfHwgZm9ybWF0LmNoYXJBdChpICsgMSkgIT09ICdcXCcnKSB7XG4gICAgICAgICAgICBmb3JtYXR0ZXJzLnB1c2goY29uc3RydWN0TGl0ZXJhbEZvcm1hdHRlcihmb3JtYXQsIGxpdGVyYWxJZHgsIGkpKTtcbiAgICAgICAgICAgIGxpdGVyYWxJZHggPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChpID09PSBmb3JtYXQubGVuZ3RoKSB7XG4gICAgICAgICAgd2hpbGUgKGxpdGVyYWxJZHggPCBmb3JtYXQubGVuZ3RoKSB7XG4gICAgICAgICAgICBmb3JtYXR0ZXIgPSBjb25zdHJ1Y3RGb3JtYXR0ZXJGcm9tSWR4KGZvcm1hdCwgbGl0ZXJhbElkeCk7XG4gICAgICAgICAgICBmb3JtYXR0ZXJzLnB1c2goZm9ybWF0dGVyKTtcbiAgICAgICAgICAgIGxpdGVyYWxJZHggPSBmb3JtYXR0ZXIuZW5kSWR4O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGkrKztcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChmb3JtYXQuY2hhckF0KGkpID09PSAnXFwnJykge1xuICAgICAgICBsaXRlcmFsSWR4ID0gaTtcbiAgICAgICAgaSsrO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgZm9ybWF0dGVyID0gY29uc3RydWN0Rm9ybWF0dGVyRnJvbUlkeChmb3JtYXQsIGkpO1xuXG4gICAgICBmb3JtYXR0ZXJzLnB1c2goZm9ybWF0dGVyLnBhcnNlcik7XG4gICAgICBpID0gZm9ybWF0dGVyLmVuZElkeDtcbiAgICB9XG5cbiAgICByZXR1cm4gZm9ybWF0dGVycztcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbnN0cnVjdExpdGVyYWxGb3JtYXR0ZXIoZm9ybWF0LCBsaXRlcmFsSWR4LCBlbmRJZHgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZm9ybWF0LnN1YnN0cihsaXRlcmFsSWR4ICsgMSwgZW5kSWR4IC0gbGl0ZXJhbElkeCAtIDEpO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBjb25zdHJ1Y3RGb3JtYXR0ZXJGcm9tSWR4KGZvcm1hdCwgaSkge1xuICAgIHZhciBjdXJyZW50UG9zU3RyID0gZm9ybWF0LnN1YnN0cihpKTtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGZvcm1hdENvZGVUb1JlZ2V4Lmxlbmd0aDsgaisrKSB7XG4gICAgICBpZiAobmV3IFJlZ0V4cCgnXicgKyBmb3JtYXRDb2RlVG9SZWdleFtqXS5rZXkpLnRlc3QoY3VycmVudFBvc1N0cikpIHtcbiAgICAgICAgdmFyIGRhdGEgPSBmb3JtYXRDb2RlVG9SZWdleFtqXTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBlbmRJZHg6IGkgKyBkYXRhLmtleS5sZW5ndGgsXG4gICAgICAgICAgcGFyc2VyOiBkYXRhLmZvcm1hdHRlclxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBlbmRJZHg6IGkgKyAxLFxuICAgICAgcGFyc2VyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRQb3NTdHIuY2hhckF0KDApO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICB0aGlzLmZpbHRlciA9IGZ1bmN0aW9uKGRhdGUsIGZvcm1hdCkge1xuICAgIGlmICghYW5ndWxhci5pc0RhdGUoZGF0ZSkgfHwgaXNOYU4oZGF0ZSkgfHwgIWZvcm1hdCkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIGZvcm1hdCA9ICRsb2NhbGUuREFURVRJTUVfRk9STUFUU1tmb3JtYXRdIHx8IGZvcm1hdDtcblxuICAgIGlmICgkbG9jYWxlLmlkICE9PSBsb2NhbGVJZCkge1xuICAgICAgdGhpcy5pbml0KCk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmZvcm1hdHRlcnNbZm9ybWF0XSkge1xuICAgICAgdGhpcy5mb3JtYXR0ZXJzW2Zvcm1hdF0gPSBjcmVhdGVGb3JtYXR0ZXIoZm9ybWF0KTtcbiAgICB9XG5cbiAgICB2YXIgZm9ybWF0dGVycyA9IHRoaXMuZm9ybWF0dGVyc1tmb3JtYXRdO1xuXG4gICAgcmV0dXJuIGZvcm1hdHRlcnMucmVkdWNlKGZ1bmN0aW9uKHN0ciwgZm9ybWF0dGVyKSB7XG4gICAgICByZXR1cm4gc3RyICsgZm9ybWF0dGVyKGRhdGUpO1xuICAgIH0sICcnKTtcbiAgfTtcblxuICB0aGlzLnBhcnNlID0gZnVuY3Rpb24oaW5wdXQsIGZvcm1hdCwgYmFzZURhdGUpIHtcbiAgICBpZiAoIWFuZ3VsYXIuaXNTdHJpbmcoaW5wdXQpIHx8ICFmb3JtYXQpIHtcbiAgICAgIHJldHVybiBpbnB1dDtcbiAgICB9XG5cbiAgICBmb3JtYXQgPSAkbG9jYWxlLkRBVEVUSU1FX0ZPUk1BVFNbZm9ybWF0XSB8fCBmb3JtYXQ7XG4gICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoU1BFQ0lBTF9DSEFSQUNURVJTX1JFR0VYUCwgJ1xcXFwkJicpO1xuXG4gICAgaWYgKCRsb2NhbGUuaWQgIT09IGxvY2FsZUlkKSB7XG4gICAgICB0aGlzLmluaXQoKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMucGFyc2Vyc1tmb3JtYXRdKSB7XG4gICAgICB0aGlzLnBhcnNlcnNbZm9ybWF0XSA9IGNyZWF0ZVBhcnNlcihmb3JtYXQsICdhcHBseScpO1xuICAgIH1cblxuICAgIHZhciBwYXJzZXIgPSB0aGlzLnBhcnNlcnNbZm9ybWF0XSxcbiAgICAgICAgcmVnZXggPSBwYXJzZXIucmVnZXgsXG4gICAgICAgIG1hcCA9IHBhcnNlci5tYXAsXG4gICAgICAgIHJlc3VsdHMgPSBpbnB1dC5tYXRjaChyZWdleCksXG4gICAgICAgIHR6T2Zmc2V0ID0gZmFsc2U7XG4gICAgaWYgKHJlc3VsdHMgJiYgcmVzdWx0cy5sZW5ndGgpIHtcbiAgICAgIHZhciBmaWVsZHMsIGR0O1xuICAgICAgaWYgKGFuZ3VsYXIuaXNEYXRlKGJhc2VEYXRlKSAmJiAhaXNOYU4oYmFzZURhdGUuZ2V0VGltZSgpKSkge1xuICAgICAgICBmaWVsZHMgPSB7XG4gICAgICAgICAgeWVhcjogYmFzZURhdGUuZ2V0RnVsbFllYXIoKSxcbiAgICAgICAgICBtb250aDogYmFzZURhdGUuZ2V0TW9udGgoKSxcbiAgICAgICAgICBkYXRlOiBiYXNlRGF0ZS5nZXREYXRlKCksXG4gICAgICAgICAgaG91cnM6IGJhc2VEYXRlLmdldEhvdXJzKCksXG4gICAgICAgICAgbWludXRlczogYmFzZURhdGUuZ2V0TWludXRlcygpLFxuICAgICAgICAgIHNlY29uZHM6IGJhc2VEYXRlLmdldFNlY29uZHMoKSxcbiAgICAgICAgICBtaWxsaXNlY29uZHM6IGJhc2VEYXRlLmdldE1pbGxpc2Vjb25kcygpXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoYmFzZURhdGUpIHtcbiAgICAgICAgICAkbG9nLndhcm4oJ2RhdGVwYXJzZXI6JywgJ2Jhc2VEYXRlIGlzIG5vdCBhIHZhbGlkIGRhdGUnKTtcbiAgICAgICAgfVxuICAgICAgICBmaWVsZHMgPSB7IHllYXI6IDE5MDAsIG1vbnRoOiAwLCBkYXRlOiAxLCBob3VyczogMCwgbWludXRlczogMCwgc2Vjb25kczogMCwgbWlsbGlzZWNvbmRzOiAwIH07XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSAxLCBuID0gcmVzdWx0cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgdmFyIG1hcHBlciA9IG1hcFtpIC0gMV07XG4gICAgICAgIGlmIChtYXBwZXIubWF0Y2hlciA9PT0gJ1onKSB7XG4gICAgICAgICAgdHpPZmZzZXQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1hcHBlci5hcHBseSkge1xuICAgICAgICAgIG1hcHBlci5hcHBseS5jYWxsKGZpZWxkcywgcmVzdWx0c1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGRhdGVzZXR0ZXIgPSB0ek9mZnNldCA/IERhdGUucHJvdG90eXBlLnNldFVUQ0Z1bGxZZWFyIDpcbiAgICAgICAgRGF0ZS5wcm90b3R5cGUuc2V0RnVsbFllYXI7XG4gICAgICB2YXIgdGltZXNldHRlciA9IHR6T2Zmc2V0ID8gRGF0ZS5wcm90b3R5cGUuc2V0VVRDSG91cnMgOlxuICAgICAgICBEYXRlLnByb3RvdHlwZS5zZXRIb3VycztcblxuICAgICAgaWYgKGlzVmFsaWQoZmllbGRzLnllYXIsIGZpZWxkcy5tb250aCwgZmllbGRzLmRhdGUpKSB7XG4gICAgICAgIGlmIChhbmd1bGFyLmlzRGF0ZShiYXNlRGF0ZSkgJiYgIWlzTmFOKGJhc2VEYXRlLmdldFRpbWUoKSkgJiYgIXR6T2Zmc2V0KSB7XG4gICAgICAgICAgZHQgPSBuZXcgRGF0ZShiYXNlRGF0ZSk7XG4gICAgICAgICAgZGF0ZXNldHRlci5jYWxsKGR0LCBmaWVsZHMueWVhciwgZmllbGRzLm1vbnRoLCBmaWVsZHMuZGF0ZSk7XG4gICAgICAgICAgdGltZXNldHRlci5jYWxsKGR0LCBmaWVsZHMuaG91cnMsIGZpZWxkcy5taW51dGVzLFxuICAgICAgICAgICAgZmllbGRzLnNlY29uZHMsIGZpZWxkcy5taWxsaXNlY29uZHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGR0ID0gbmV3IERhdGUoMCk7XG4gICAgICAgICAgZGF0ZXNldHRlci5jYWxsKGR0LCBmaWVsZHMueWVhciwgZmllbGRzLm1vbnRoLCBmaWVsZHMuZGF0ZSk7XG4gICAgICAgICAgdGltZXNldHRlci5jYWxsKGR0LCBmaWVsZHMuaG91cnMgfHwgMCwgZmllbGRzLm1pbnV0ZXMgfHwgMCxcbiAgICAgICAgICAgIGZpZWxkcy5zZWNvbmRzIHx8IDAsIGZpZWxkcy5taWxsaXNlY29uZHMgfHwgMCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGR0O1xuICAgIH1cbiAgfTtcblxuICAvLyBDaGVjayBpZiBkYXRlIGlzIHZhbGlkIGZvciBzcGVjaWZpYyBtb250aCAoYW5kIHllYXIgZm9yIEZlYnJ1YXJ5KS5cbiAgLy8gTW9udGg6IDAgPSBKYW4sIDEgPSBGZWIsIGV0Y1xuICBmdW5jdGlvbiBpc1ZhbGlkKHllYXIsIG1vbnRoLCBkYXRlKSB7XG4gICAgaWYgKGRhdGUgPCAxKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKG1vbnRoID09PSAxICYmIGRhdGUgPiAyOCkge1xuICAgICAgcmV0dXJuIGRhdGUgPT09IDI5ICYmICh5ZWFyICUgNCA9PT0gMCAmJiB5ZWFyICUgMTAwICE9PSAwIHx8IHllYXIgJSA0MDAgPT09IDApO1xuICAgIH1cblxuICAgIGlmIChtb250aCA9PT0gMyB8fCBtb250aCA9PT0gNSB8fCBtb250aCA9PT0gOCB8fCBtb250aCA9PT0gMTApIHtcbiAgICAgIHJldHVybiBkYXRlIDwgMzE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiB0b0ludChzdHIpIHtcbiAgICByZXR1cm4gcGFyc2VJbnQoc3RyLCAxMCk7XG4gIH1cblxuICB0aGlzLnRvVGltZXpvbmUgPSB0b1RpbWV6b25lO1xuICB0aGlzLmZyb21UaW1lem9uZSA9IGZyb21UaW1lem9uZTtcbiAgdGhpcy50aW1lem9uZVRvT2Zmc2V0ID0gdGltZXpvbmVUb09mZnNldDtcbiAgdGhpcy5hZGREYXRlTWludXRlcyA9IGFkZERhdGVNaW51dGVzO1xuICB0aGlzLmNvbnZlcnRUaW1lem9uZVRvTG9jYWwgPSBjb252ZXJ0VGltZXpvbmVUb0xvY2FsO1xuXG4gIGZ1bmN0aW9uIHRvVGltZXpvbmUoZGF0ZSwgdGltZXpvbmUpIHtcbiAgICByZXR1cm4gZGF0ZSAmJiB0aW1lem9uZSA/IGNvbnZlcnRUaW1lem9uZVRvTG9jYWwoZGF0ZSwgdGltZXpvbmUpIDogZGF0ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZyb21UaW1lem9uZShkYXRlLCB0aW1lem9uZSkge1xuICAgIHJldHVybiBkYXRlICYmIHRpbWV6b25lID8gY29udmVydFRpbWV6b25lVG9Mb2NhbChkYXRlLCB0aW1lem9uZSwgdHJ1ZSkgOiBkYXRlO1xuICB9XG5cbiAgLy9odHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyLmpzL2Jsb2IvNjIyYzQyMTY5Njk5ZWMwN2ZjNmRhYWExOWZlNmQyMjRlNWQyZjcwZS9zcmMvQW5ndWxhci5qcyNMMTIwN1xuICBmdW5jdGlvbiB0aW1lem9uZVRvT2Zmc2V0KHRpbWV6b25lLCBmYWxsYmFjaykge1xuICAgIHRpbWV6b25lID0gdGltZXpvbmUucmVwbGFjZSgvOi9nLCAnJyk7XG4gICAgdmFyIHJlcXVlc3RlZFRpbWV6b25lT2Zmc2V0ID0gRGF0ZS5wYXJzZSgnSmFuIDAxLCAxOTcwIDAwOjAwOjAwICcgKyB0aW1lem9uZSkgLyA2MDAwMDtcbiAgICByZXR1cm4gaXNOYU4ocmVxdWVzdGVkVGltZXpvbmVPZmZzZXQpID8gZmFsbGJhY2sgOiByZXF1ZXN0ZWRUaW1lem9uZU9mZnNldDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZERhdGVNaW51dGVzKGRhdGUsIG1pbnV0ZXMpIHtcbiAgICBkYXRlID0gbmV3IERhdGUoZGF0ZS5nZXRUaW1lKCkpO1xuICAgIGRhdGUuc2V0TWludXRlcyhkYXRlLmdldE1pbnV0ZXMoKSArIG1pbnV0ZXMpO1xuICAgIHJldHVybiBkYXRlO1xuICB9XG5cbiAgZnVuY3Rpb24gY29udmVydFRpbWV6b25lVG9Mb2NhbChkYXRlLCB0aW1lem9uZSwgcmV2ZXJzZSkge1xuICAgIHJldmVyc2UgPSByZXZlcnNlID8gLTEgOiAxO1xuICAgIHZhciBkYXRlVGltZXpvbmVPZmZzZXQgPSBkYXRlLmdldFRpbWV6b25lT2Zmc2V0KCk7XG4gICAgdmFyIHRpbWV6b25lT2Zmc2V0ID0gdGltZXpvbmVUb09mZnNldCh0aW1lem9uZSwgZGF0ZVRpbWV6b25lT2Zmc2V0KTtcbiAgICByZXR1cm4gYWRkRGF0ZU1pbnV0ZXMoZGF0ZSwgcmV2ZXJzZSAqICh0aW1lem9uZU9mZnNldCAtIGRhdGVUaW1lem9uZU9mZnNldCkpO1xuICB9XG59XSk7XG5cbi8vIEF2b2lkaW5nIHVzZSBvZiBuZy1jbGFzcyBhcyBpdCBjcmVhdGVzIGEgbG90IG9mIHdhdGNoZXJzIHdoZW4gYSBjbGFzcyBpcyB0byBiZSBhcHBsaWVkIHRvXG4vLyBhdCBtb3N0IG9uZSBlbGVtZW50LlxuYW5ndWxhci5tb2R1bGUoJ3VpLmJvb3RzdHJhcC5pc0NsYXNzJywgW10pXG4uZGlyZWN0aXZlKCd1aWJJc0NsYXNzJywgW1xuICAgICAgICAgJyRhbmltYXRlJyxcbmZ1bmN0aW9uICgkYW5pbWF0ZSkge1xuICAvLyAgICAgICAgICAgICAgICAgICAgMTExMTExMTEgICAgICAgICAgMjIyMjIyMjJcbiAgdmFyIE9OX1JFR0VYUCA9IC9eXFxzKihbXFxzXFxTXSs/KVxccytvblxccysoW1xcc1xcU10rPylcXHMqJC87XG4gIC8vICAgICAgICAgICAgICAgICAgICAxMTExMTExMSAgICAgICAgICAgMjIyMjIyMjJcbiAgdmFyIElTX1JFR0VYUCA9IC9eXFxzKihbXFxzXFxTXSs/KVxccytmb3JcXHMrKFtcXHNcXFNdKz8pXFxzKiQvO1xuXG4gIHZhciBkYXRhUGVyVHJhY2tlZCA9IHt9O1xuXG4gIHJldHVybiB7XG4gICAgcmVzdHJpY3Q6ICdBJyxcbiAgICBjb21waWxlOiBmdW5jdGlvbih0RWxlbWVudCwgdEF0dHJzKSB7XG4gICAgICB2YXIgbGlua2VkU2NvcGVzID0gW107XG4gICAgICB2YXIgaW5zdGFuY2VzID0gW107XG4gICAgICB2YXIgZXhwVG9EYXRhID0ge307XG4gICAgICB2YXIgbGFzdEFjdGl2YXRlZCA9IG51bGw7XG4gICAgICB2YXIgb25FeHBNYXRjaGVzID0gdEF0dHJzLnVpYklzQ2xhc3MubWF0Y2goT05fUkVHRVhQKTtcbiAgICAgIHZhciBvbkV4cCA9IG9uRXhwTWF0Y2hlc1syXTtcbiAgICAgIHZhciBleHBzU3RyID0gb25FeHBNYXRjaGVzWzFdO1xuICAgICAgdmFyIGV4cHMgPSBleHBzU3RyLnNwbGl0KCcsJyk7XG5cbiAgICAgIHJldHVybiBsaW5rRm47XG5cbiAgICAgIGZ1bmN0aW9uIGxpbmtGbihzY29wZSwgZWxlbWVudCwgYXR0cnMpIHtcbiAgICAgICAgbGlua2VkU2NvcGVzLnB1c2goc2NvcGUpO1xuICAgICAgICBpbnN0YW5jZXMucHVzaCh7XG4gICAgICAgICAgc2NvcGU6IHNjb3BlLFxuICAgICAgICAgIGVsZW1lbnQ6IGVsZW1lbnRcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZXhwcy5mb3JFYWNoKGZ1bmN0aW9uKGV4cCwgaykge1xuICAgICAgICAgIGFkZEZvckV4cChleHAsIHNjb3BlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgc2NvcGUuJG9uKCckZGVzdHJveScsIHJlbW92ZVNjb3BlKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gYWRkRm9yRXhwKGV4cCwgc2NvcGUpIHtcbiAgICAgICAgdmFyIG1hdGNoZXMgPSBleHAubWF0Y2goSVNfUkVHRVhQKTtcbiAgICAgICAgdmFyIGNsYXp6ID0gc2NvcGUuJGV2YWwobWF0Y2hlc1sxXSk7XG4gICAgICAgIHZhciBjb21wYXJlV2l0aEV4cCA9IG1hdGNoZXNbMl07XG4gICAgICAgIHZhciBkYXRhID0gZXhwVG9EYXRhW2V4cF07XG4gICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgIHZhciB3YXRjaEZuID0gZnVuY3Rpb24oY29tcGFyZVdpdGhWYWwpIHtcbiAgICAgICAgICAgIHZhciBuZXdBY3RpdmF0ZWQgPSBudWxsO1xuICAgICAgICAgICAgaW5zdGFuY2VzLnNvbWUoZnVuY3Rpb24oaW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgdmFyIHRoaXNWYWwgPSBpbnN0YW5jZS5zY29wZS4kZXZhbChvbkV4cCk7XG4gICAgICAgICAgICAgIGlmICh0aGlzVmFsID09PSBjb21wYXJlV2l0aFZhbCkge1xuICAgICAgICAgICAgICAgIG5ld0FjdGl2YXRlZCA9IGluc3RhbmNlO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChkYXRhLmxhc3RBY3RpdmF0ZWQgIT09IG5ld0FjdGl2YXRlZCkge1xuICAgICAgICAgICAgICBpZiAoZGF0YS5sYXN0QWN0aXZhdGVkKSB7XG4gICAgICAgICAgICAgICAgJGFuaW1hdGUucmVtb3ZlQ2xhc3MoZGF0YS5sYXN0QWN0aXZhdGVkLmVsZW1lbnQsIGNsYXp6KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAobmV3QWN0aXZhdGVkKSB7XG4gICAgICAgICAgICAgICAgJGFuaW1hdGUuYWRkQ2xhc3MobmV3QWN0aXZhdGVkLmVsZW1lbnQsIGNsYXp6KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBkYXRhLmxhc3RBY3RpdmF0ZWQgPSBuZXdBY3RpdmF0ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICBleHBUb0RhdGFbZXhwXSA9IGRhdGEgPSB7XG4gICAgICAgICAgICBsYXN0QWN0aXZhdGVkOiBudWxsLFxuICAgICAgICAgICAgc2NvcGU6IHNjb3BlLFxuICAgICAgICAgICAgd2F0Y2hGbjogd2F0Y2hGbixcbiAgICAgICAgICAgIGNvbXBhcmVXaXRoRXhwOiBjb21wYXJlV2l0aEV4cCxcbiAgICAgICAgICAgIHdhdGNoZXI6IHNjb3BlLiR3YXRjaChjb21wYXJlV2l0aEV4cCwgd2F0Y2hGbilcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGRhdGEud2F0Y2hGbihzY29wZS4kZXZhbChjb21wYXJlV2l0aEV4cCkpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiByZW1vdmVTY29wZShlKSB7XG4gICAgICAgIHZhciByZW1vdmVkU2NvcGUgPSBlLnRhcmdldFNjb3BlO1xuICAgICAgICB2YXIgaW5kZXggPSBsaW5rZWRTY29wZXMuaW5kZXhPZihyZW1vdmVkU2NvcGUpO1xuICAgICAgICBsaW5rZWRTY29wZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgaW5zdGFuY2VzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIGlmIChsaW5rZWRTY29wZXMubGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIG5ld1dhdGNoU2NvcGUgPSBsaW5rZWRTY29wZXNbMF07XG4gICAgICAgICAgYW5ndWxhci5mb3JFYWNoKGV4cFRvRGF0YSwgZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgaWYgKGRhdGEuc2NvcGUgPT09IHJlbW92ZWRTY29wZSkge1xuICAgICAgICAgICAgICBkYXRhLndhdGNoZXIgPSBuZXdXYXRjaFNjb3BlLiR3YXRjaChkYXRhLmNvbXBhcmVXaXRoRXhwLCBkYXRhLndhdGNoRm4pO1xuICAgICAgICAgICAgICBkYXRhLnNjb3BlID0gbmV3V2F0Y2hTY29wZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBleHBUb0RhdGEgPSB7fTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbn1dKTtcbmFuZ3VsYXIubW9kdWxlKCd1aS5ib290c3RyYXAuZGF0ZXBpY2tlcicsIFsndWkuYm9vdHN0cmFwLmRhdGVwYXJzZXInLCAndWkuYm9vdHN0cmFwLmlzQ2xhc3MnXSlcblxuLnZhbHVlKCckZGF0ZXBpY2tlclN1cHByZXNzRXJyb3InLCBmYWxzZSlcblxuLnZhbHVlKCckZGF0ZXBpY2tlckxpdGVyYWxXYXJuaW5nJywgdHJ1ZSlcblxuLmNvbnN0YW50KCd1aWJEYXRlcGlja2VyQ29uZmlnJywge1xuICBkYXRlcGlja2VyTW9kZTogJ2RheScsXG4gIGZvcm1hdERheTogJ2RkJyxcbiAgZm9ybWF0TW9udGg6ICdNTU1NJyxcbiAgZm9ybWF0WWVhcjogJ3l5eXknLFxuICBmb3JtYXREYXlIZWFkZXI6ICdFRUUnLFxuICBmb3JtYXREYXlUaXRsZTogJ01NTU0geXl5eScsXG4gIGZvcm1hdE1vbnRoVGl0bGU6ICd5eXl5JyxcbiAgbWF4RGF0ZTogbnVsbCxcbiAgbWF4TW9kZTogJ3llYXInLFxuICBtaW5EYXRlOiBudWxsLFxuICBtaW5Nb2RlOiAnZGF5JyxcbiAgbW9udGhDb2x1bW5zOiAzLFxuICBuZ01vZGVsT3B0aW9uczoge30sXG4gIHNob3J0Y3V0UHJvcGFnYXRpb246IGZhbHNlLFxuICBzaG93V2Vla3M6IHRydWUsXG4gIHllYXJDb2x1bW5zOiA1LFxuICB5ZWFyUm93czogNFxufSlcblxuLmNvbnRyb2xsZXIoJ1VpYkRhdGVwaWNrZXJDb250cm9sbGVyJywgWyckc2NvcGUnLCAnJGVsZW1lbnQnLCAnJGF0dHJzJywgJyRwYXJzZScsICckaW50ZXJwb2xhdGUnLCAnJGxvY2FsZScsICckbG9nJywgJ2RhdGVGaWx0ZXInLCAndWliRGF0ZXBpY2tlckNvbmZpZycsICckZGF0ZXBpY2tlckxpdGVyYWxXYXJuaW5nJywgJyRkYXRlcGlja2VyU3VwcHJlc3NFcnJvcicsICd1aWJEYXRlUGFyc2VyJyxcbiAgZnVuY3Rpb24oJHNjb3BlLCAkZWxlbWVudCwgJGF0dHJzLCAkcGFyc2UsICRpbnRlcnBvbGF0ZSwgJGxvY2FsZSwgJGxvZywgZGF0ZUZpbHRlciwgZGF0ZXBpY2tlckNvbmZpZywgJGRhdGVwaWNrZXJMaXRlcmFsV2FybmluZywgJGRhdGVwaWNrZXJTdXBwcmVzc0Vycm9yLCBkYXRlUGFyc2VyKSB7XG4gIHZhciBzZWxmID0gdGhpcyxcbiAgICAgIG5nTW9kZWxDdHJsID0geyAkc2V0Vmlld1ZhbHVlOiBhbmd1bGFyLm5vb3AgfSwgLy8gbnVsbE1vZGVsQ3RybDtcbiAgICAgIG5nTW9kZWxPcHRpb25zID0ge30sXG4gICAgICB3YXRjaExpc3RlbmVycyA9IFtdO1xuXG4gICRlbGVtZW50LmFkZENsYXNzKCd1aWItZGF0ZXBpY2tlcicpO1xuICAkYXR0cnMuJHNldCgncm9sZScsICdhcHBsaWNhdGlvbicpO1xuXG4gIGlmICghJHNjb3BlLmRhdGVwaWNrZXJPcHRpb25zKSB7XG4gICAgJHNjb3BlLmRhdGVwaWNrZXJPcHRpb25zID0ge307XG4gIH1cblxuICAvLyBNb2RlcyBjaGFpblxuICB0aGlzLm1vZGVzID0gWydkYXknLCAnbW9udGgnLCAneWVhciddO1xuXG4gIFtcbiAgICAnY3VzdG9tQ2xhc3MnLFxuICAgICdkYXRlRGlzYWJsZWQnLFxuICAgICdkYXRlcGlja2VyTW9kZScsXG4gICAgJ2Zvcm1hdERheScsXG4gICAgJ2Zvcm1hdERheUhlYWRlcicsXG4gICAgJ2Zvcm1hdERheVRpdGxlJyxcbiAgICAnZm9ybWF0TW9udGgnLFxuICAgICdmb3JtYXRNb250aFRpdGxlJyxcbiAgICAnZm9ybWF0WWVhcicsXG4gICAgJ21heERhdGUnLFxuICAgICdtYXhNb2RlJyxcbiAgICAnbWluRGF0ZScsXG4gICAgJ21pbk1vZGUnLFxuICAgICdtb250aENvbHVtbnMnLFxuICAgICdzaG93V2Vla3MnLFxuICAgICdzaG9ydGN1dFByb3BhZ2F0aW9uJyxcbiAgICAnc3RhcnRpbmdEYXknLFxuICAgICd5ZWFyQ29sdW1ucycsXG4gICAgJ3llYXJSb3dzJ1xuICBdLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgc3dpdGNoIChrZXkpIHtcbiAgICAgIGNhc2UgJ2N1c3RvbUNsYXNzJzpcbiAgICAgIGNhc2UgJ2RhdGVEaXNhYmxlZCc6XG4gICAgICAgICRzY29wZVtrZXldID0gJHNjb3BlLmRhdGVwaWNrZXJPcHRpb25zW2tleV0gfHwgYW5ndWxhci5ub29wO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2RhdGVwaWNrZXJNb2RlJzpcbiAgICAgICAgJHNjb3BlLmRhdGVwaWNrZXJNb2RlID0gYW5ndWxhci5pc0RlZmluZWQoJHNjb3BlLmRhdGVwaWNrZXJPcHRpb25zLmRhdGVwaWNrZXJNb2RlKSA/XG4gICAgICAgICAgJHNjb3BlLmRhdGVwaWNrZXJPcHRpb25zLmRhdGVwaWNrZXJNb2RlIDogZGF0ZXBpY2tlckNvbmZpZy5kYXRlcGlja2VyTW9kZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdmb3JtYXREYXknOlxuICAgICAgY2FzZSAnZm9ybWF0RGF5SGVhZGVyJzpcbiAgICAgIGNhc2UgJ2Zvcm1hdERheVRpdGxlJzpcbiAgICAgIGNhc2UgJ2Zvcm1hdE1vbnRoJzpcbiAgICAgIGNhc2UgJ2Zvcm1hdE1vbnRoVGl0bGUnOlxuICAgICAgY2FzZSAnZm9ybWF0WWVhcic6XG4gICAgICAgIHNlbGZba2V5XSA9IGFuZ3VsYXIuaXNEZWZpbmVkKCRzY29wZS5kYXRlcGlja2VyT3B0aW9uc1trZXldKSA/XG4gICAgICAgICAgJGludGVycG9sYXRlKCRzY29wZS5kYXRlcGlja2VyT3B0aW9uc1trZXldKSgkc2NvcGUuJHBhcmVudCkgOlxuICAgICAgICAgIGRhdGVwaWNrZXJDb25maWdba2V5XTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtb250aENvbHVtbnMnOlxuICAgICAgY2FzZSAnc2hvd1dlZWtzJzpcbiAgICAgIGNhc2UgJ3Nob3J0Y3V0UHJvcGFnYXRpb24nOlxuICAgICAgY2FzZSAneWVhckNvbHVtbnMnOlxuICAgICAgY2FzZSAneWVhclJvd3MnOlxuICAgICAgICBzZWxmW2tleV0gPSBhbmd1bGFyLmlzRGVmaW5lZCgkc2NvcGUuZGF0ZXBpY2tlck9wdGlvbnNba2V5XSkgP1xuICAgICAgICAgICRzY29wZS5kYXRlcGlja2VyT3B0aW9uc1trZXldIDogZGF0ZXBpY2tlckNvbmZpZ1trZXldO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3N0YXJ0aW5nRGF5JzpcbiAgICAgICAgaWYgKGFuZ3VsYXIuaXNEZWZpbmVkKCRzY29wZS5kYXRlcGlja2VyT3B0aW9ucy5zdGFydGluZ0RheSkpIHtcbiAgICAgICAgICBzZWxmLnN0YXJ0aW5nRGF5ID0gJHNjb3BlLmRhdGVwaWNrZXJPcHRpb25zLnN0YXJ0aW5nRGF5O1xuICAgICAgICB9IGVsc2UgaWYgKGFuZ3VsYXIuaXNOdW1iZXIoZGF0ZXBpY2tlckNvbmZpZy5zdGFydGluZ0RheSkpIHtcbiAgICAgICAgICBzZWxmLnN0YXJ0aW5nRGF5ID0gZGF0ZXBpY2tlckNvbmZpZy5zdGFydGluZ0RheTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZWxmLnN0YXJ0aW5nRGF5ID0gKCRsb2NhbGUuREFURVRJTUVfRk9STUFUUy5GSVJTVERBWU9GV0VFSyArIDgpICUgNztcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbWF4RGF0ZSc6XG4gICAgICBjYXNlICdtaW5EYXRlJzpcbiAgICAgICAgJHNjb3BlLiR3YXRjaCgnZGF0ZXBpY2tlck9wdGlvbnMuJyArIGtleSwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChhbmd1bGFyLmlzRGF0ZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgc2VsZltrZXldID0gZGF0ZVBhcnNlci5mcm9tVGltZXpvbmUobmV3IERhdGUodmFsdWUpLCBuZ01vZGVsT3B0aW9ucy5nZXRPcHRpb24oJ3RpbWV6b25lJykpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKCRkYXRlcGlja2VyTGl0ZXJhbFdhcm5pbmcpIHtcbiAgICAgICAgICAgICAgICAkbG9nLndhcm4oJ0xpdGVyYWwgZGF0ZSBzdXBwb3J0IGhhcyBiZWVuIGRlcHJlY2F0ZWQsIHBsZWFzZSBzd2l0Y2ggdG8gZGF0ZSBvYmplY3QgdXNhZ2UnKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHNlbGZba2V5XSA9IG5ldyBEYXRlKGRhdGVGaWx0ZXIodmFsdWUsICdtZWRpdW0nKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlbGZba2V5XSA9IGRhdGVwaWNrZXJDb25maWdba2V5XSA/XG4gICAgICAgICAgICAgIGRhdGVQYXJzZXIuZnJvbVRpbWV6b25lKG5ldyBEYXRlKGRhdGVwaWNrZXJDb25maWdba2V5XSksIG5nTW9kZWxPcHRpb25zLmdldE9wdGlvbigndGltZXpvbmUnKSkgOlxuICAgICAgICAgICAgICBudWxsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNlbGYucmVmcmVzaFZpZXcoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtYXhNb2RlJzpcbiAgICAgIGNhc2UgJ21pbk1vZGUnOlxuICAgICAgICBpZiAoJHNjb3BlLmRhdGVwaWNrZXJPcHRpb25zW2tleV0pIHtcbiAgICAgICAgICAkc2NvcGUuJHdhdGNoKGZ1bmN0aW9uKCkgeyByZXR1cm4gJHNjb3BlLmRhdGVwaWNrZXJPcHRpb25zW2tleV07IH0sIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICBzZWxmW2tleV0gPSAkc2NvcGVba2V5XSA9IGFuZ3VsYXIuaXNEZWZpbmVkKHZhbHVlKSA/IHZhbHVlIDogJHNjb3BlLmRhdGVwaWNrZXJPcHRpb25zW2tleV07XG4gICAgICAgICAgICBpZiAoa2V5ID09PSAnbWluTW9kZScgJiYgc2VsZi5tb2Rlcy5pbmRleE9mKCRzY29wZS5kYXRlcGlja2VyT3B0aW9ucy5kYXRlcGlja2VyTW9kZSkgPCBzZWxmLm1vZGVzLmluZGV4T2Yoc2VsZltrZXldKSB8fFxuICAgICAgICAgICAgICBrZXkgPT09ICdtYXhNb2RlJyAmJiBzZWxmLm1vZGVzLmluZGV4T2YoJHNjb3BlLmRhdGVwaWNrZXJPcHRpb25zLmRhdGVwaWNrZXJNb2RlKSA+IHNlbGYubW9kZXMuaW5kZXhPZihzZWxmW2tleV0pKSB7XG4gICAgICAgICAgICAgICRzY29wZS5kYXRlcGlja2VyTW9kZSA9IHNlbGZba2V5XTtcbiAgICAgICAgICAgICAgJHNjb3BlLmRhdGVwaWNrZXJPcHRpb25zLmRhdGVwaWNrZXJNb2RlID0gc2VsZltrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlbGZba2V5XSA9ICRzY29wZVtrZXldID0gZGF0ZXBpY2tlckNvbmZpZ1trZXldIHx8IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH0pO1xuXG4gICRzY29wZS51bmlxdWVJZCA9ICdkYXRlcGlja2VyLScgKyAkc2NvcGUuJGlkICsgJy0nICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMDApO1xuXG4gICRzY29wZS5kaXNhYmxlZCA9IGFuZ3VsYXIuaXNEZWZpbmVkKCRhdHRycy5kaXNhYmxlZCkgfHwgZmFsc2U7XG4gIGlmIChhbmd1bGFyLmlzRGVmaW5lZCgkYXR0cnMubmdEaXNhYmxlZCkpIHtcbiAgICB3YXRjaExpc3RlbmVycy5wdXNoKCRzY29wZS4kcGFyZW50LiR3YXRjaCgkYXR0cnMubmdEaXNhYmxlZCwgZnVuY3Rpb24oZGlzYWJsZWQpIHtcbiAgICAgICRzY29wZS5kaXNhYmxlZCA9IGRpc2FibGVkO1xuICAgICAgc2VsZi5yZWZyZXNoVmlldygpO1xuICAgIH0pKTtcbiAgfVxuXG4gICRzY29wZS5pc0FjdGl2ZSA9IGZ1bmN0aW9uKGRhdGVPYmplY3QpIHtcbiAgICBpZiAoc2VsZi5jb21wYXJlKGRhdGVPYmplY3QuZGF0ZSwgc2VsZi5hY3RpdmVEYXRlKSA9PT0gMCkge1xuICAgICAgJHNjb3BlLmFjdGl2ZURhdGVJZCA9IGRhdGVPYmplY3QudWlkO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICB0aGlzLmluaXQgPSBmdW5jdGlvbihuZ01vZGVsQ3RybF8pIHtcbiAgICBuZ01vZGVsQ3RybCA9IG5nTW9kZWxDdHJsXztcbiAgICBuZ01vZGVsT3B0aW9ucyA9IGV4dHJhY3RPcHRpb25zKG5nTW9kZWxDdHJsKTtcblxuICAgIGlmICgkc2NvcGUuZGF0ZXBpY2tlck9wdGlvbnMuaW5pdERhdGUpIHtcbiAgICAgIHNlbGYuYWN0aXZlRGF0ZSA9IGRhdGVQYXJzZXIuZnJvbVRpbWV6b25lKCRzY29wZS5kYXRlcGlja2VyT3B0aW9ucy5pbml0RGF0ZSwgbmdNb2RlbE9wdGlvbnMuZ2V0T3B0aW9uKCd0aW1lem9uZScpKSB8fCBuZXcgRGF0ZSgpO1xuICAgICAgJHNjb3BlLiR3YXRjaCgnZGF0ZXBpY2tlck9wdGlvbnMuaW5pdERhdGUnLCBmdW5jdGlvbihpbml0RGF0ZSkge1xuICAgICAgICBpZiAoaW5pdERhdGUgJiYgKG5nTW9kZWxDdHJsLiRpc0VtcHR5KG5nTW9kZWxDdHJsLiRtb2RlbFZhbHVlKSB8fCBuZ01vZGVsQ3RybC4kaW52YWxpZCkpIHtcbiAgICAgICAgICBzZWxmLmFjdGl2ZURhdGUgPSBkYXRlUGFyc2VyLmZyb21UaW1lem9uZShpbml0RGF0ZSwgbmdNb2RlbE9wdGlvbnMuZ2V0T3B0aW9uKCd0aW1lem9uZScpKTtcbiAgICAgICAgICBzZWxmLnJlZnJlc2hWaWV3KCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZWxmLmFjdGl2ZURhdGUgPSBuZXcgRGF0ZSgpO1xuICAgIH1cblxuICAgIHZhciBkYXRlID0gbmdNb2RlbEN0cmwuJG1vZGVsVmFsdWUgPyBuZXcgRGF0ZShuZ01vZGVsQ3RybC4kbW9kZWxWYWx1ZSkgOiBuZXcgRGF0ZSgpO1xuICAgIHRoaXMuYWN0aXZlRGF0ZSA9ICFpc05hTihkYXRlKSA/XG4gICAgICBkYXRlUGFyc2VyLmZyb21UaW1lem9uZShkYXRlLCBuZ01vZGVsT3B0aW9ucy5nZXRPcHRpb24oJ3RpbWV6b25lJykpIDpcbiAgICAgIGRhdGVQYXJzZXIuZnJvbVRpbWV6b25lKG5ldyBEYXRlKCksIG5nTW9kZWxPcHRpb25zLmdldE9wdGlvbigndGltZXpvbmUnKSk7XG5cbiAgICBuZ01vZGVsQ3RybC4kcmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICBzZWxmLnJlbmRlcigpO1xuICAgIH07XG4gIH07XG5cbiAgdGhpcy5yZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAobmdNb2RlbEN0cmwuJHZpZXdWYWx1ZSkge1xuICAgICAgdmFyIGRhdGUgPSBuZXcgRGF0ZShuZ01vZGVsQ3RybC4kdmlld1ZhbHVlKSxcbiAgICAgICAgICBpc1ZhbGlkID0gIWlzTmFOKGRhdGUpO1xuXG4gICAgICBpZiAoaXNWYWxpZCkge1xuICAgICAgICB0aGlzLmFjdGl2ZURhdGUgPSBkYXRlUGFyc2VyLmZyb21UaW1lem9uZShkYXRlLCBuZ01vZGVsT3B0aW9ucy5nZXRPcHRpb24oJ3RpbWV6b25lJykpO1xuICAgICAgfSBlbHNlIGlmICghJGRhdGVwaWNrZXJTdXBwcmVzc0Vycm9yKSB7XG4gICAgICAgICRsb2cuZXJyb3IoJ0RhdGVwaWNrZXIgZGlyZWN0aXZlOiBcIm5nLW1vZGVsXCIgdmFsdWUgbXVzdCBiZSBhIERhdGUgb2JqZWN0Jyk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMucmVmcmVzaFZpZXcoKTtcbiAgfTtcblxuICB0aGlzLnJlZnJlc2hWaWV3ID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuZWxlbWVudCkge1xuICAgICAgJHNjb3BlLnNlbGVjdGVkRHQgPSBudWxsO1xuICAgICAgdGhpcy5fcmVmcmVzaFZpZXcoKTtcbiAgICAgIGlmICgkc2NvcGUuYWN0aXZlRHQpIHtcbiAgICAgICAgJHNjb3BlLmFjdGl2ZURhdGVJZCA9ICRzY29wZS5hY3RpdmVEdC51aWQ7XG4gICAgICB9XG5cbiAgICAgIHZhciBkYXRlID0gbmdNb2RlbEN0cmwuJHZpZXdWYWx1ZSA/IG5ldyBEYXRlKG5nTW9kZWxDdHJsLiR2aWV3VmFsdWUpIDogbnVsbDtcbiAgICAgIGRhdGUgPSBkYXRlUGFyc2VyLmZyb21UaW1lem9uZShkYXRlLCBuZ01vZGVsT3B0aW9ucy5nZXRPcHRpb24oJ3RpbWV6b25lJykpO1xuICAgICAgbmdNb2RlbEN0cmwuJHNldFZhbGlkaXR5KCdkYXRlRGlzYWJsZWQnLCAhZGF0ZSB8fFxuICAgICAgICB0aGlzLmVsZW1lbnQgJiYgIXRoaXMuaXNEaXNhYmxlZChkYXRlKSk7XG4gICAgfVxuICB9O1xuXG4gIHRoaXMuY3JlYXRlRGF0ZU9iamVjdCA9IGZ1bmN0aW9uKGRhdGUsIGZvcm1hdCkge1xuICAgIHZhciBtb2RlbCA9IG5nTW9kZWxDdHJsLiR2aWV3VmFsdWUgPyBuZXcgRGF0ZShuZ01vZGVsQ3RybC4kdmlld1ZhbHVlKSA6IG51bGw7XG4gICAgbW9kZWwgPSBkYXRlUGFyc2VyLmZyb21UaW1lem9uZShtb2RlbCwgbmdNb2RlbE9wdGlvbnMuZ2V0T3B0aW9uKCd0aW1lem9uZScpKTtcbiAgICB2YXIgdG9kYXkgPSBuZXcgRGF0ZSgpO1xuICAgIHRvZGF5ID0gZGF0ZVBhcnNlci5mcm9tVGltZXpvbmUodG9kYXksIG5nTW9kZWxPcHRpb25zLmdldE9wdGlvbigndGltZXpvbmUnKSk7XG4gICAgdmFyIHRpbWUgPSB0aGlzLmNvbXBhcmUoZGF0ZSwgdG9kYXkpO1xuICAgIHZhciBkdCA9IHtcbiAgICAgIGRhdGU6IGRhdGUsXG4gICAgICBsYWJlbDogZGF0ZVBhcnNlci5maWx0ZXIoZGF0ZSwgZm9ybWF0KSxcbiAgICAgIHNlbGVjdGVkOiBtb2RlbCAmJiB0aGlzLmNvbXBhcmUoZGF0ZSwgbW9kZWwpID09PSAwLFxuICAgICAgZGlzYWJsZWQ6IHRoaXMuaXNEaXNhYmxlZChkYXRlKSxcbiAgICAgIHBhc3Q6IHRpbWUgPCAwLFxuICAgICAgY3VycmVudDogdGltZSA9PT0gMCxcbiAgICAgIGZ1dHVyZTogdGltZSA+IDAsXG4gICAgICBjdXN0b21DbGFzczogdGhpcy5jdXN0b21DbGFzcyhkYXRlKSB8fCBudWxsXG4gICAgfTtcblxuICAgIGlmIChtb2RlbCAmJiB0aGlzLmNvbXBhcmUoZGF0ZSwgbW9kZWwpID09PSAwKSB7XG4gICAgICAkc2NvcGUuc2VsZWN0ZWREdCA9IGR0O1xuICAgIH1cblxuICAgIGlmIChzZWxmLmFjdGl2ZURhdGUgJiYgdGhpcy5jb21wYXJlKGR0LmRhdGUsIHNlbGYuYWN0aXZlRGF0ZSkgPT09IDApIHtcbiAgICAgICRzY29wZS5hY3RpdmVEdCA9IGR0O1xuICAgIH1cblxuICAgIHJldHVybiBkdDtcbiAgfTtcblxuICB0aGlzLmlzRGlzYWJsZWQgPSBmdW5jdGlvbihkYXRlKSB7XG4gICAgcmV0dXJuICRzY29wZS5kaXNhYmxlZCB8fFxuICAgICAgdGhpcy5taW5EYXRlICYmIHRoaXMuY29tcGFyZShkYXRlLCB0aGlzLm1pbkRhdGUpIDwgMCB8fFxuICAgICAgdGhpcy5tYXhEYXRlICYmIHRoaXMuY29tcGFyZShkYXRlLCB0aGlzLm1heERhdGUpID4gMCB8fFxuICAgICAgJHNjb3BlLmRhdGVEaXNhYmxlZCAmJiAkc2NvcGUuZGF0ZURpc2FibGVkKHtkYXRlOiBkYXRlLCBtb2RlOiAkc2NvcGUuZGF0ZXBpY2tlck1vZGV9KTtcbiAgfTtcblxuICB0aGlzLmN1c3RvbUNsYXNzID0gZnVuY3Rpb24oZGF0ZSkge1xuICAgIHJldHVybiAkc2NvcGUuY3VzdG9tQ2xhc3Moe2RhdGU6IGRhdGUsIG1vZGU6ICRzY29wZS5kYXRlcGlja2VyTW9kZX0pO1xuICB9O1xuXG4gIC8vIFNwbGl0IGFycmF5IGludG8gc21hbGxlciBhcnJheXNcbiAgdGhpcy5zcGxpdCA9IGZ1bmN0aW9uKGFyciwgc2l6ZSkge1xuICAgIHZhciBhcnJheXMgPSBbXTtcbiAgICB3aGlsZSAoYXJyLmxlbmd0aCA+IDApIHtcbiAgICAgIGFycmF5cy5wdXNoKGFyci5zcGxpY2UoMCwgc2l6ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXlzO1xuICB9O1xuXG4gICRzY29wZS5zZWxlY3QgPSBmdW5jdGlvbihkYXRlKSB7XG4gICAgaWYgKCRzY29wZS5kYXRlcGlja2VyTW9kZSA9PT0gc2VsZi5taW5Nb2RlKSB7XG4gICAgICB2YXIgZHQgPSBuZ01vZGVsQ3RybC4kdmlld1ZhbHVlID8gZGF0ZVBhcnNlci5mcm9tVGltZXpvbmUobmV3IERhdGUobmdNb2RlbEN0cmwuJHZpZXdWYWx1ZSksIG5nTW9kZWxPcHRpb25zLmdldE9wdGlvbigndGltZXpvbmUnKSkgOiBuZXcgRGF0ZSgwLCAwLCAwLCAwLCAwLCAwLCAwKTtcbiAgICAgIGR0LnNldEZ1bGxZZWFyKGRhdGUuZ2V0RnVsbFllYXIoKSwgZGF0ZS5nZXRNb250aCgpLCBkYXRlLmdldERhdGUoKSk7XG4gICAgICBkdCA9IGRhdGVQYXJzZXIudG9UaW1lem9uZShkdCwgbmdNb2RlbE9wdGlvbnMuZ2V0T3B0aW9uKCd0aW1lem9uZScpKTtcbiAgICAgIG5nTW9kZWxDdHJsLiRzZXRWaWV3VmFsdWUoZHQpO1xuICAgICAgbmdNb2RlbEN0cmwuJHJlbmRlcigpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZWxmLmFjdGl2ZURhdGUgPSBkYXRlO1xuICAgICAgc2V0TW9kZShzZWxmLm1vZGVzW3NlbGYubW9kZXMuaW5kZXhPZigkc2NvcGUuZGF0ZXBpY2tlck1vZGUpIC0gMV0pO1xuXG4gICAgICAkc2NvcGUuJGVtaXQoJ3VpYjpkYXRlcGlja2VyLm1vZGUnKTtcbiAgICB9XG5cbiAgICAkc2NvcGUuJGJyb2FkY2FzdCgndWliOmRhdGVwaWNrZXIuZm9jdXMnKTtcbiAgfTtcblxuICAkc2NvcGUubW92ZSA9IGZ1bmN0aW9uKGRpcmVjdGlvbikge1xuICAgIHZhciB5ZWFyID0gc2VsZi5hY3RpdmVEYXRlLmdldEZ1bGxZZWFyKCkgKyBkaXJlY3Rpb24gKiAoc2VsZi5zdGVwLnllYXJzIHx8IDApLFxuICAgICAgICBtb250aCA9IHNlbGYuYWN0aXZlRGF0ZS5nZXRNb250aCgpICsgZGlyZWN0aW9uICogKHNlbGYuc3RlcC5tb250aHMgfHwgMCk7XG4gICAgc2VsZi5hY3RpdmVEYXRlLnNldEZ1bGxZZWFyKHllYXIsIG1vbnRoLCAxKTtcbiAgICBzZWxmLnJlZnJlc2hWaWV3KCk7XG4gIH07XG5cbiAgJHNjb3BlLnRvZ2dsZU1vZGUgPSBmdW5jdGlvbihkaXJlY3Rpb24pIHtcbiAgICBkaXJlY3Rpb24gPSBkaXJlY3Rpb24gfHwgMTtcblxuICAgIGlmICgkc2NvcGUuZGF0ZXBpY2tlck1vZGUgPT09IHNlbGYubWF4TW9kZSAmJiBkaXJlY3Rpb24gPT09IDEgfHxcbiAgICAgICRzY29wZS5kYXRlcGlja2VyTW9kZSA9PT0gc2VsZi5taW5Nb2RlICYmIGRpcmVjdGlvbiA9PT0gLTEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzZXRNb2RlKHNlbGYubW9kZXNbc2VsZi5tb2Rlcy5pbmRleE9mKCRzY29wZS5kYXRlcGlja2VyTW9kZSkgKyBkaXJlY3Rpb25dKTtcblxuICAgICRzY29wZS4kZW1pdCgndWliOmRhdGVwaWNrZXIubW9kZScpO1xuICB9O1xuXG4gIC8vIEtleSBldmVudCBtYXBwZXJcbiAgJHNjb3BlLmtleXMgPSB7IDEzOiAnZW50ZXInLCAzMjogJ3NwYWNlJywgMzM6ICdwYWdldXAnLCAzNDogJ3BhZ2Vkb3duJywgMzU6ICdlbmQnLCAzNjogJ2hvbWUnLCAzNzogJ2xlZnQnLCAzODogJ3VwJywgMzk6ICdyaWdodCcsIDQwOiAnZG93bicgfTtcblxuICB2YXIgZm9jdXNFbGVtZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgc2VsZi5lbGVtZW50WzBdLmZvY3VzKCk7XG4gIH07XG5cbiAgLy8gTGlzdGVuIGZvciBmb2N1cyByZXF1ZXN0cyBmcm9tIHBvcHVwIGRpcmVjdGl2ZVxuICAkc2NvcGUuJG9uKCd1aWI6ZGF0ZXBpY2tlci5mb2N1cycsIGZvY3VzRWxlbWVudCk7XG5cbiAgJHNjb3BlLmtleWRvd24gPSBmdW5jdGlvbihldnQpIHtcbiAgICB2YXIga2V5ID0gJHNjb3BlLmtleXNbZXZ0LndoaWNoXTtcblxuICAgIGlmICgha2V5IHx8IGV2dC5zaGlmdEtleSB8fCBldnQuYWx0S2V5IHx8ICRzY29wZS5kaXNhYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGlmICghc2VsZi5zaG9ydGN1dFByb3BhZ2F0aW9uKSB7XG4gICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfVxuXG4gICAgaWYgKGtleSA9PT0gJ2VudGVyJyB8fCBrZXkgPT09ICdzcGFjZScpIHtcbiAgICAgIGlmIChzZWxmLmlzRGlzYWJsZWQoc2VsZi5hY3RpdmVEYXRlKSkge1xuICAgICAgICByZXR1cm47IC8vIGRvIG5vdGhpbmdcbiAgICAgIH1cbiAgICAgICRzY29wZS5zZWxlY3Qoc2VsZi5hY3RpdmVEYXRlKTtcbiAgICB9IGVsc2UgaWYgKGV2dC5jdHJsS2V5ICYmIChrZXkgPT09ICd1cCcgfHwga2V5ID09PSAnZG93bicpKSB7XG4gICAgICAkc2NvcGUudG9nZ2xlTW9kZShrZXkgPT09ICd1cCcgPyAxIDogLTEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZWxmLmhhbmRsZUtleURvd24oa2V5LCBldnQpO1xuICAgICAgc2VsZi5yZWZyZXNoVmlldygpO1xuICAgIH1cbiAgfTtcblxuICAkZWxlbWVudC5vbigna2V5ZG93bicsIGZ1bmN0aW9uKGV2dCkge1xuICAgICRzY29wZS4kYXBwbHkoZnVuY3Rpb24oKSB7XG4gICAgICAkc2NvcGUua2V5ZG93bihldnQpO1xuICAgIH0pO1xuICB9KTtcblxuICAkc2NvcGUuJG9uKCckZGVzdHJveScsIGZ1bmN0aW9uKCkge1xuICAgIC8vQ2xlYXIgYWxsIHdhdGNoIGxpc3RlbmVycyBvbiBkZXN0cm95XG4gICAgd2hpbGUgKHdhdGNoTGlzdGVuZXJzLmxlbmd0aCkge1xuICAgICAgd2F0Y2hMaXN0ZW5lcnMuc2hpZnQoKSgpO1xuICAgIH1cbiAgfSk7XG5cbiAgZnVuY3Rpb24gc2V0TW9kZShtb2RlKSB7XG4gICAgJHNjb3BlLmRhdGVwaWNrZXJNb2RlID0gbW9kZTtcbiAgICAkc2NvcGUuZGF0ZXBpY2tlck9wdGlvbnMuZGF0ZXBpY2tlck1vZGUgPSBtb2RlO1xuICB9XG5cbiAgZnVuY3Rpb24gZXh0cmFjdE9wdGlvbnMobmdNb2RlbEN0cmwpIHtcbiAgICB2YXIgbmdNb2RlbE9wdGlvbnM7XG5cbiAgICBpZiAoYW5ndWxhci52ZXJzaW9uLm1pbm9yIDwgNikgeyAvLyBpbiBhbmd1bGFyIDwgMS42ICRvcHRpb25zIGNvdWxkIGJlIG1pc3NpbmdcbiAgICAgIC8vIGd1YXJhbnRlZSBhIHZhbHVlXG4gICAgICBuZ01vZGVsT3B0aW9ucyA9IG5nTW9kZWxDdHJsLiRvcHRpb25zIHx8XG4gICAgICAgICRzY29wZS5kYXRlcGlja2VyT3B0aW9ucy5uZ01vZGVsT3B0aW9ucyB8fFxuICAgICAgICBkYXRlcGlja2VyQ29uZmlnLm5nTW9kZWxPcHRpb25zIHx8XG4gICAgICAgIHt9O1xuXG4gICAgICAvLyBtaW1pYyAxLjYrIGFwaVxuICAgICAgbmdNb2RlbE9wdGlvbnMuZ2V0T3B0aW9uID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICByZXR1cm4gbmdNb2RlbE9wdGlvbnNba2V5XTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHsgLy8gaW4gYW5ndWxhciA+PTEuNiAkb3B0aW9ucyBpcyBhbHdheXMgcHJlc2VudFxuICAgICAgLy8gbmctbW9kZWwtb3B0aW9ucyBkZWZhdWx0cyB0aW1lem9uZSB0byBudWxsOyBkb24ndCBsZXQgaXRzIHByZWNlZGVuY2Ugc3F1YXNoIGEgbm9uLW51bGwgdmFsdWVcbiAgICAgIHZhciB0aW1lem9uZSA9IG5nTW9kZWxDdHJsLiRvcHRpb25zLmdldE9wdGlvbigndGltZXpvbmUnKSB8fFxuICAgICAgICAoJHNjb3BlLmRhdGVwaWNrZXJPcHRpb25zLm5nTW9kZWxPcHRpb25zID8gJHNjb3BlLmRhdGVwaWNrZXJPcHRpb25zLm5nTW9kZWxPcHRpb25zLnRpbWV6b25lIDogbnVsbCkgfHxcbiAgICAgICAgKGRhdGVwaWNrZXJDb25maWcubmdNb2RlbE9wdGlvbnMgPyBkYXRlcGlja2VyQ29uZmlnLm5nTW9kZWxPcHRpb25zLnRpbWV6b25lIDogbnVsbCk7XG5cbiAgICAgIC8vIHZhbHVlcyBwYXNzZWQgdG8gY3JlYXRlQ2hpbGQgb3ZlcnJpZGUgZXhpc3RpbmcgdmFsdWVzXG4gICAgICBuZ01vZGVsT3B0aW9ucyA9IG5nTW9kZWxDdHJsLiRvcHRpb25zIC8vIHN0YXJ0IHdpdGggYSBNb2RlbE9wdGlvbnMgaW5zdGFuY2VcbiAgICAgICAgLmNyZWF0ZUNoaWxkKGRhdGVwaWNrZXJDb25maWcubmdNb2RlbE9wdGlvbnMpIC8vIGxvd2VzdCBwcmVjZWRlbmNlXG4gICAgICAgIC5jcmVhdGVDaGlsZCgkc2NvcGUuZGF0ZXBpY2tlck9wdGlvbnMubmdNb2RlbE9wdGlvbnMpXG4gICAgICAgIC5jcmVhdGVDaGlsZChuZ01vZGVsQ3RybC4kb3B0aW9ucykgLy8gaGlnaGVzdCBwcmVjZWRlbmNlXG4gICAgICAgIC5jcmVhdGVDaGlsZCh7dGltZXpvbmU6IHRpbWV6b25lfSk7IC8vIHRvIGtlZXAgZnJvbSBzcXVhc2hpbmcgYSBub24tbnVsbCB2YWx1ZVxuICAgIH1cblxuICAgIHJldHVybiBuZ01vZGVsT3B0aW9ucztcbiAgfVxufV0pXG5cbi5jb250cm9sbGVyKCdVaWJEYXlwaWNrZXJDb250cm9sbGVyJywgWyckc2NvcGUnLCAnJGVsZW1lbnQnLCAnZGF0ZUZpbHRlcicsIGZ1bmN0aW9uKHNjb3BlLCAkZWxlbWVudCwgZGF0ZUZpbHRlcikge1xuICB2YXIgREFZU19JTl9NT05USCA9IFszMSwgMjgsIDMxLCAzMCwgMzEsIDMwLCAzMSwgMzEsIDMwLCAzMSwgMzAsIDMxXTtcblxuICB0aGlzLnN0ZXAgPSB7IG1vbnRoczogMSB9O1xuICB0aGlzLmVsZW1lbnQgPSAkZWxlbWVudDtcbiAgZnVuY3Rpb24gZ2V0RGF5c0luTW9udGgoeWVhciwgbW9udGgpIHtcbiAgICByZXR1cm4gbW9udGggPT09IDEgJiYgeWVhciAlIDQgPT09IDAgJiZcbiAgICAgICh5ZWFyICUgMTAwICE9PSAwIHx8IHllYXIgJSA0MDAgPT09IDApID8gMjkgOiBEQVlTX0lOX01PTlRIW21vbnRoXTtcbiAgfVxuXG4gIHRoaXMuaW5pdCA9IGZ1bmN0aW9uKGN0cmwpIHtcbiAgICBhbmd1bGFyLmV4dGVuZChjdHJsLCB0aGlzKTtcbiAgICBzY29wZS5zaG93V2Vla3MgPSBjdHJsLnNob3dXZWVrcztcbiAgICBjdHJsLnJlZnJlc2hWaWV3KCk7XG4gIH07XG5cbiAgdGhpcy5nZXREYXRlcyA9IGZ1bmN0aW9uKHN0YXJ0RGF0ZSwgbikge1xuICAgIHZhciBkYXRlcyA9IG5ldyBBcnJheShuKSwgY3VycmVudCA9IG5ldyBEYXRlKHN0YXJ0RGF0ZSksIGkgPSAwLCBkYXRlO1xuICAgIHdoaWxlIChpIDwgbikge1xuICAgICAgZGF0ZSA9IG5ldyBEYXRlKGN1cnJlbnQpO1xuICAgICAgZGF0ZXNbaSsrXSA9IGRhdGU7XG4gICAgICBjdXJyZW50LnNldERhdGUoY3VycmVudC5nZXREYXRlKCkgKyAxKTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGVzO1xuICB9O1xuXG4gIHRoaXMuX3JlZnJlc2hWaWV3ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHllYXIgPSB0aGlzLmFjdGl2ZURhdGUuZ2V0RnVsbFllYXIoKSxcbiAgICAgIG1vbnRoID0gdGhpcy5hY3RpdmVEYXRlLmdldE1vbnRoKCksXG4gICAgICBmaXJzdERheU9mTW9udGggPSBuZXcgRGF0ZSh0aGlzLmFjdGl2ZURhdGUpO1xuXG4gICAgZmlyc3REYXlPZk1vbnRoLnNldEZ1bGxZZWFyKHllYXIsIG1vbnRoLCAxKTtcblxuICAgIHZhciBkaWZmZXJlbmNlID0gdGhpcy5zdGFydGluZ0RheSAtIGZpcnN0RGF5T2ZNb250aC5nZXREYXkoKSxcbiAgICAgIG51bURpc3BsYXllZEZyb21QcmV2aW91c01vbnRoID0gZGlmZmVyZW5jZSA+IDAgP1xuICAgICAgICA3IC0gZGlmZmVyZW5jZSA6IC0gZGlmZmVyZW5jZSxcbiAgICAgIGZpcnN0RGF0ZSA9IG5ldyBEYXRlKGZpcnN0RGF5T2ZNb250aCk7XG5cbiAgICBpZiAobnVtRGlzcGxheWVkRnJvbVByZXZpb3VzTW9udGggPiAwKSB7XG4gICAgICBmaXJzdERhdGUuc2V0RGF0ZSgtbnVtRGlzcGxheWVkRnJvbVByZXZpb3VzTW9udGggKyAxKTtcbiAgICB9XG5cbiAgICAvLyA0MiBpcyB0aGUgbnVtYmVyIG9mIGRheXMgb24gYSBzaXgtd2VlayBjYWxlbmRhclxuICAgIHZhciBkYXlzID0gdGhpcy5nZXREYXRlcyhmaXJzdERhdGUsIDQyKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQyOyBpICsrKSB7XG4gICAgICBkYXlzW2ldID0gYW5ndWxhci5leHRlbmQodGhpcy5jcmVhdGVEYXRlT2JqZWN0KGRheXNbaV0sIHRoaXMuZm9ybWF0RGF5KSwge1xuICAgICAgICBzZWNvbmRhcnk6IGRheXNbaV0uZ2V0TW9udGgoKSAhPT0gbW9udGgsXG4gICAgICAgIHVpZDogc2NvcGUudW5pcXVlSWQgKyAnLScgKyBpXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBzY29wZS5sYWJlbHMgPSBuZXcgQXJyYXkoNyk7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCA3OyBqKyspIHtcbiAgICAgIHNjb3BlLmxhYmVsc1tqXSA9IHtcbiAgICAgICAgYWJicjogZGF0ZUZpbHRlcihkYXlzW2pdLmRhdGUsIHRoaXMuZm9ybWF0RGF5SGVhZGVyKSxcbiAgICAgICAgZnVsbDogZGF0ZUZpbHRlcihkYXlzW2pdLmRhdGUsICdFRUVFJylcbiAgICAgIH07XG4gICAgfVxuXG4gICAgc2NvcGUudGl0bGUgPSBkYXRlRmlsdGVyKHRoaXMuYWN0aXZlRGF0ZSwgdGhpcy5mb3JtYXREYXlUaXRsZSk7XG4gICAgc2NvcGUucm93cyA9IHRoaXMuc3BsaXQoZGF5cywgNyk7XG5cbiAgICBpZiAoc2NvcGUuc2hvd1dlZWtzKSB7XG4gICAgICBzY29wZS53ZWVrTnVtYmVycyA9IFtdO1xuICAgICAgdmFyIHRodXJzZGF5SW5kZXggPSAoNCArIDcgLSB0aGlzLnN0YXJ0aW5nRGF5KSAlIDcsXG4gICAgICAgICAgbnVtV2Vla3MgPSBzY29wZS5yb3dzLmxlbmd0aDtcbiAgICAgIGZvciAodmFyIGN1cldlZWsgPSAwOyBjdXJXZWVrIDwgbnVtV2Vla3M7IGN1cldlZWsrKykge1xuICAgICAgICBzY29wZS53ZWVrTnVtYmVycy5wdXNoKFxuICAgICAgICAgIGdldElTTzg2MDFXZWVrTnVtYmVyKHNjb3BlLnJvd3NbY3VyV2Vla11bdGh1cnNkYXlJbmRleF0uZGF0ZSkpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB0aGlzLmNvbXBhcmUgPSBmdW5jdGlvbihkYXRlMSwgZGF0ZTIpIHtcbiAgICB2YXIgX2RhdGUxID0gbmV3IERhdGUoZGF0ZTEuZ2V0RnVsbFllYXIoKSwgZGF0ZTEuZ2V0TW9udGgoKSwgZGF0ZTEuZ2V0RGF0ZSgpKTtcbiAgICB2YXIgX2RhdGUyID0gbmV3IERhdGUoZGF0ZTIuZ2V0RnVsbFllYXIoKSwgZGF0ZTIuZ2V0TW9udGgoKSwgZGF0ZTIuZ2V0RGF0ZSgpKTtcbiAgICBfZGF0ZTEuc2V0RnVsbFllYXIoZGF0ZTEuZ2V0RnVsbFllYXIoKSk7XG4gICAgX2RhdGUyLnNldEZ1bGxZZWFyKGRhdGUyLmdldEZ1bGxZZWFyKCkpO1xuICAgIHJldHVybiBfZGF0ZTEgLSBfZGF0ZTI7XG4gIH07XG5cbiAgZnVuY3Rpb24gZ2V0SVNPODYwMVdlZWtOdW1iZXIoZGF0ZSkge1xuICAgIHZhciBjaGVja0RhdGUgPSBuZXcgRGF0ZShkYXRlKTtcbiAgICBjaGVja0RhdGUuc2V0RGF0ZShjaGVja0RhdGUuZ2V0RGF0ZSgpICsgNCAtIChjaGVja0RhdGUuZ2V0RGF5KCkgfHwgNykpOyAvLyBUaHVyc2RheVxuICAgIHZhciB0aW1lID0gY2hlY2tEYXRlLmdldFRpbWUoKTtcbiAgICBjaGVja0RhdGUuc2V0TW9udGgoMCk7IC8vIENvbXBhcmUgd2l0aCBKYW4gMVxuICAgIGNoZWNrRGF0ZS5zZXREYXRlKDEpO1xuICAgIHJldHVybiBNYXRoLmZsb29yKE1hdGgucm91bmQoKHRpbWUgLSBjaGVja0RhdGUpIC8gODY0MDAwMDApIC8gNykgKyAxO1xuICB9XG5cbiAgdGhpcy5oYW5kbGVLZXlEb3duID0gZnVuY3Rpb24oa2V5LCBldnQpIHtcbiAgICB2YXIgZGF0ZSA9IHRoaXMuYWN0aXZlRGF0ZS5nZXREYXRlKCk7XG5cbiAgICBpZiAoa2V5ID09PSAnbGVmdCcpIHtcbiAgICAgIGRhdGUgPSBkYXRlIC0gMTtcbiAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ3VwJykge1xuICAgICAgZGF0ZSA9IGRhdGUgLSA3O1xuICAgIH0gZWxzZSBpZiAoa2V5ID09PSAncmlnaHQnKSB7XG4gICAgICBkYXRlID0gZGF0ZSArIDE7XG4gICAgfSBlbHNlIGlmIChrZXkgPT09ICdkb3duJykge1xuICAgICAgZGF0ZSA9IGRhdGUgKyA3O1xuICAgIH0gZWxzZSBpZiAoa2V5ID09PSAncGFnZXVwJyB8fCBrZXkgPT09ICdwYWdlZG93bicpIHtcbiAgICAgIHZhciBtb250aCA9IHRoaXMuYWN0aXZlRGF0ZS5nZXRNb250aCgpICsgKGtleSA9PT0gJ3BhZ2V1cCcgPyAtIDEgOiAxKTtcbiAgICAgIHRoaXMuYWN0aXZlRGF0ZS5zZXRNb250aChtb250aCwgMSk7XG4gICAgICBkYXRlID0gTWF0aC5taW4oZ2V0RGF5c0luTW9udGgodGhpcy5hY3RpdmVEYXRlLmdldEZ1bGxZZWFyKCksIHRoaXMuYWN0aXZlRGF0ZS5nZXRNb250aCgpKSwgZGF0ZSk7XG4gICAgfSBlbHNlIGlmIChrZXkgPT09ICdob21lJykge1xuICAgICAgZGF0ZSA9IDE7XG4gICAgfSBlbHNlIGlmIChrZXkgPT09ICdlbmQnKSB7XG4gICAgICBkYXRlID0gZ2V0RGF5c0luTW9udGgodGhpcy5hY3RpdmVEYXRlLmdldEZ1bGxZZWFyKCksIHRoaXMuYWN0aXZlRGF0ZS5nZXRNb250aCgpKTtcbiAgICB9XG4gICAgdGhpcy5hY3RpdmVEYXRlLnNldERhdGUoZGF0ZSk7XG4gIH07XG59XSlcblxuLmNvbnRyb2xsZXIoJ1VpYk1vbnRocGlja2VyQ29udHJvbGxlcicsIFsnJHNjb3BlJywgJyRlbGVtZW50JywgJ2RhdGVGaWx0ZXInLCBmdW5jdGlvbihzY29wZSwgJGVsZW1lbnQsIGRhdGVGaWx0ZXIpIHtcbiAgdGhpcy5zdGVwID0geyB5ZWFyczogMSB9O1xuICB0aGlzLmVsZW1lbnQgPSAkZWxlbWVudDtcblxuICB0aGlzLmluaXQgPSBmdW5jdGlvbihjdHJsKSB7XG4gICAgYW5ndWxhci5leHRlbmQoY3RybCwgdGhpcyk7XG4gICAgY3RybC5yZWZyZXNoVmlldygpO1xuICB9O1xuXG4gIHRoaXMuX3JlZnJlc2hWaWV3ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG1vbnRocyA9IG5ldyBBcnJheSgxMiksXG4gICAgICAgIHllYXIgPSB0aGlzLmFjdGl2ZURhdGUuZ2V0RnVsbFllYXIoKSxcbiAgICAgICAgZGF0ZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgICAgZGF0ZSA9IG5ldyBEYXRlKHRoaXMuYWN0aXZlRGF0ZSk7XG4gICAgICBkYXRlLnNldEZ1bGxZZWFyKHllYXIsIGksIDEpO1xuICAgICAgbW9udGhzW2ldID0gYW5ndWxhci5leHRlbmQodGhpcy5jcmVhdGVEYXRlT2JqZWN0KGRhdGUsIHRoaXMuZm9ybWF0TW9udGgpLCB7XG4gICAgICAgIHVpZDogc2NvcGUudW5pcXVlSWQgKyAnLScgKyBpXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBzY29wZS50aXRsZSA9IGRhdGVGaWx0ZXIodGhpcy5hY3RpdmVEYXRlLCB0aGlzLmZvcm1hdE1vbnRoVGl0bGUpO1xuICAgIHNjb3BlLnJvd3MgPSB0aGlzLnNwbGl0KG1vbnRocywgdGhpcy5tb250aENvbHVtbnMpO1xuICAgIHNjb3BlLnllYXJIZWFkZXJDb2xzcGFuID0gdGhpcy5tb250aENvbHVtbnMgPiAzID8gdGhpcy5tb250aENvbHVtbnMgLSAyIDogMTtcbiAgfTtcblxuICB0aGlzLmNvbXBhcmUgPSBmdW5jdGlvbihkYXRlMSwgZGF0ZTIpIHtcbiAgICB2YXIgX2RhdGUxID0gbmV3IERhdGUoZGF0ZTEuZ2V0RnVsbFllYXIoKSwgZGF0ZTEuZ2V0TW9udGgoKSk7XG4gICAgdmFyIF9kYXRlMiA9IG5ldyBEYXRlKGRhdGUyLmdldEZ1bGxZZWFyKCksIGRhdGUyLmdldE1vbnRoKCkpO1xuICAgIF9kYXRlMS5zZXRGdWxsWWVhcihkYXRlMS5nZXRGdWxsWWVhcigpKTtcbiAgICBfZGF0ZTIuc2V0RnVsbFllYXIoZGF0ZTIuZ2V0RnVsbFllYXIoKSk7XG4gICAgcmV0dXJuIF9kYXRlMSAtIF9kYXRlMjtcbiAgfTtcblxuICB0aGlzLmhhbmRsZUtleURvd24gPSBmdW5jdGlvbihrZXksIGV2dCkge1xuICAgIHZhciBkYXRlID0gdGhpcy5hY3RpdmVEYXRlLmdldE1vbnRoKCk7XG5cbiAgICBpZiAoa2V5ID09PSAnbGVmdCcpIHtcbiAgICAgIGRhdGUgPSBkYXRlIC0gMTtcbiAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ3VwJykge1xuICAgICAgZGF0ZSA9IGRhdGUgLSB0aGlzLm1vbnRoQ29sdW1ucztcbiAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ3JpZ2h0Jykge1xuICAgICAgZGF0ZSA9IGRhdGUgKyAxO1xuICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnZG93bicpIHtcbiAgICAgIGRhdGUgPSBkYXRlICsgdGhpcy5tb250aENvbHVtbnM7XG4gICAgfSBlbHNlIGlmIChrZXkgPT09ICdwYWdldXAnIHx8IGtleSA9PT0gJ3BhZ2Vkb3duJykge1xuICAgICAgdmFyIHllYXIgPSB0aGlzLmFjdGl2ZURhdGUuZ2V0RnVsbFllYXIoKSArIChrZXkgPT09ICdwYWdldXAnID8gLSAxIDogMSk7XG4gICAgICB0aGlzLmFjdGl2ZURhdGUuc2V0RnVsbFllYXIoeWVhcik7XG4gICAgfSBlbHNlIGlmIChrZXkgPT09ICdob21lJykge1xuICAgICAgZGF0ZSA9IDA7XG4gICAgfSBlbHNlIGlmIChrZXkgPT09ICdlbmQnKSB7XG4gICAgICBkYXRlID0gMTE7XG4gICAgfVxuICAgIHRoaXMuYWN0aXZlRGF0ZS5zZXRNb250aChkYXRlKTtcbiAgfTtcbn1dKVxuXG4uY29udHJvbGxlcignVWliWWVhcnBpY2tlckNvbnRyb2xsZXInLCBbJyRzY29wZScsICckZWxlbWVudCcsICdkYXRlRmlsdGVyJywgZnVuY3Rpb24oc2NvcGUsICRlbGVtZW50LCBkYXRlRmlsdGVyKSB7XG4gIHZhciBjb2x1bW5zLCByYW5nZTtcbiAgdGhpcy5lbGVtZW50ID0gJGVsZW1lbnQ7XG5cbiAgZnVuY3Rpb24gZ2V0U3RhcnRpbmdZZWFyKHllYXIpIHtcbiAgICByZXR1cm4gcGFyc2VJbnQoKHllYXIgLSAxKSAvIHJhbmdlLCAxMCkgKiByYW5nZSArIDE7XG4gIH1cblxuICB0aGlzLnllYXJwaWNrZXJJbml0ID0gZnVuY3Rpb24oKSB7XG4gICAgY29sdW1ucyA9IHRoaXMueWVhckNvbHVtbnM7XG4gICAgcmFuZ2UgPSB0aGlzLnllYXJSb3dzICogY29sdW1ucztcbiAgICB0aGlzLnN0ZXAgPSB7IHllYXJzOiByYW5nZSB9O1xuICB9O1xuXG4gIHRoaXMuX3JlZnJlc2hWaWV3ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHllYXJzID0gbmV3IEFycmF5KHJhbmdlKSwgZGF0ZTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBzdGFydCA9IGdldFN0YXJ0aW5nWWVhcih0aGlzLmFjdGl2ZURhdGUuZ2V0RnVsbFllYXIoKSk7IGkgPCByYW5nZTsgaSsrKSB7XG4gICAgICBkYXRlID0gbmV3IERhdGUodGhpcy5hY3RpdmVEYXRlKTtcbiAgICAgIGRhdGUuc2V0RnVsbFllYXIoc3RhcnQgKyBpLCAwLCAxKTtcbiAgICAgIHllYXJzW2ldID0gYW5ndWxhci5leHRlbmQodGhpcy5jcmVhdGVEYXRlT2JqZWN0KGRhdGUsIHRoaXMuZm9ybWF0WWVhciksIHtcbiAgICAgICAgdWlkOiBzY29wZS51bmlxdWVJZCArICctJyArIGlcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHNjb3BlLnRpdGxlID0gW3llYXJzWzBdLmxhYmVsLCB5ZWFyc1tyYW5nZSAtIDFdLmxhYmVsXS5qb2luKCcgLSAnKTtcbiAgICBzY29wZS5yb3dzID0gdGhpcy5zcGxpdCh5ZWFycywgY29sdW1ucyk7XG4gICAgc2NvcGUuY29sdW1ucyA9IGNvbHVtbnM7XG4gIH07XG5cbiAgdGhpcy5jb21wYXJlID0gZnVuY3Rpb24oZGF0ZTEsIGRhdGUyKSB7XG4gICAgcmV0dXJuIGRhdGUxLmdldEZ1bGxZZWFyKCkgLSBkYXRlMi5nZXRGdWxsWWVhcigpO1xuICB9O1xuXG4gIHRoaXMuaGFuZGxlS2V5RG93biA9IGZ1bmN0aW9uKGtleSwgZXZ0KSB7XG4gICAgdmFyIGRhdGUgPSB0aGlzLmFjdGl2ZURhdGUuZ2V0RnVsbFllYXIoKTtcblxuICAgIGlmIChrZXkgPT09ICdsZWZ0Jykge1xuICAgICAgZGF0ZSA9IGRhdGUgLSAxO1xuICAgIH0gZWxzZSBpZiAoa2V5ID09PSAndXAnKSB7XG4gICAgICBkYXRlID0gZGF0ZSAtIGNvbHVtbnM7XG4gICAgfSBlbHNlIGlmIChrZXkgPT09ICdyaWdodCcpIHtcbiAgICAgIGRhdGUgPSBkYXRlICsgMTtcbiAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ2Rvd24nKSB7XG4gICAgICBkYXRlID0gZGF0ZSArIGNvbHVtbnM7XG4gICAgfSBlbHNlIGlmIChrZXkgPT09ICdwYWdldXAnIHx8IGtleSA9PT0gJ3BhZ2Vkb3duJykge1xuICAgICAgZGF0ZSArPSAoa2V5ID09PSAncGFnZXVwJyA/IC0gMSA6IDEpICogcmFuZ2U7XG4gICAgfSBlbHNlIGlmIChrZXkgPT09ICdob21lJykge1xuICAgICAgZGF0ZSA9IGdldFN0YXJ0aW5nWWVhcih0aGlzLmFjdGl2ZURhdGUuZ2V0RnVsbFllYXIoKSk7XG4gICAgfSBlbHNlIGlmIChrZXkgPT09ICdlbmQnKSB7XG4gICAgICBkYXRlID0gZ2V0U3RhcnRpbmdZZWFyKHRoaXMuYWN0aXZlRGF0ZS5nZXRGdWxsWWVhcigpKSArIHJhbmdlIC0gMTtcbiAgICB9XG4gICAgdGhpcy5hY3RpdmVEYXRlLnNldEZ1bGxZZWFyKGRhdGUpO1xuICB9O1xufV0pXG5cbi5kaXJlY3RpdmUoJ3VpYkRhdGVwaWNrZXInLCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHtcbiAgICB0ZW1wbGF0ZVVybDogZnVuY3Rpb24oZWxlbWVudCwgYXR0cnMpIHtcbiAgICAgIHJldHVybiBhdHRycy50ZW1wbGF0ZVVybCB8fCAndWliL3RlbXBsYXRlL2RhdGVwaWNrZXIvZGF0ZXBpY2tlci5odG1sJztcbiAgICB9LFxuICAgIHNjb3BlOiB7XG4gICAgICBkYXRlcGlja2VyT3B0aW9uczogJz0/J1xuICAgIH0sXG4gICAgcmVxdWlyZTogWyd1aWJEYXRlcGlja2VyJywgJ15uZ01vZGVsJ10sXG4gICAgcmVzdHJpY3Q6ICdBJyxcbiAgICBjb250cm9sbGVyOiAnVWliRGF0ZXBpY2tlckNvbnRyb2xsZXInLFxuICAgIGNvbnRyb2xsZXJBczogJ2RhdGVwaWNrZXInLFxuICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRycywgY3RybHMpIHtcbiAgICAgIHZhciBkYXRlcGlja2VyQ3RybCA9IGN0cmxzWzBdLCBuZ01vZGVsQ3RybCA9IGN0cmxzWzFdO1xuXG4gICAgICBkYXRlcGlja2VyQ3RybC5pbml0KG5nTW9kZWxDdHJsKTtcbiAgICB9XG4gIH07XG59KVxuXG4uZGlyZWN0aXZlKCd1aWJEYXlwaWNrZXInLCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHtcbiAgICB0ZW1wbGF0ZVVybDogZnVuY3Rpb24oZWxlbWVudCwgYXR0cnMpIHtcbiAgICAgIHJldHVybiBhdHRycy50ZW1wbGF0ZVVybCB8fCAndWliL3RlbXBsYXRlL2RhdGVwaWNrZXIvZGF5Lmh0bWwnO1xuICAgIH0sXG4gICAgcmVxdWlyZTogWydedWliRGF0ZXBpY2tlcicsICd1aWJEYXlwaWNrZXInXSxcbiAgICByZXN0cmljdDogJ0EnLFxuICAgIGNvbnRyb2xsZXI6ICdVaWJEYXlwaWNrZXJDb250cm9sbGVyJyxcbiAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cnMsIGN0cmxzKSB7XG4gICAgICB2YXIgZGF0ZXBpY2tlckN0cmwgPSBjdHJsc1swXSxcbiAgICAgICAgZGF5cGlja2VyQ3RybCA9IGN0cmxzWzFdO1xuXG4gICAgICBkYXlwaWNrZXJDdHJsLmluaXQoZGF0ZXBpY2tlckN0cmwpO1xuICAgIH1cbiAgfTtcbn0pXG5cbi5kaXJlY3RpdmUoJ3VpYk1vbnRocGlja2VyJywgZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7XG4gICAgdGVtcGxhdGVVcmw6IGZ1bmN0aW9uKGVsZW1lbnQsIGF0dHJzKSB7XG4gICAgICByZXR1cm4gYXR0cnMudGVtcGxhdGVVcmwgfHwgJ3VpYi90ZW1wbGF0ZS9kYXRlcGlja2VyL21vbnRoLmh0bWwnO1xuICAgIH0sXG4gICAgcmVxdWlyZTogWydedWliRGF0ZXBpY2tlcicsICd1aWJNb250aHBpY2tlciddLFxuICAgIHJlc3RyaWN0OiAnQScsXG4gICAgY29udHJvbGxlcjogJ1VpYk1vbnRocGlja2VyQ29udHJvbGxlcicsXG4gICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHJzLCBjdHJscykge1xuICAgICAgdmFyIGRhdGVwaWNrZXJDdHJsID0gY3RybHNbMF0sXG4gICAgICAgIG1vbnRocGlja2VyQ3RybCA9IGN0cmxzWzFdO1xuXG4gICAgICBtb250aHBpY2tlckN0cmwuaW5pdChkYXRlcGlja2VyQ3RybCk7XG4gICAgfVxuICB9O1xufSlcblxuLmRpcmVjdGl2ZSgndWliWWVhcnBpY2tlcicsIGZ1bmN0aW9uKCkge1xuICByZXR1cm4ge1xuICAgIHRlbXBsYXRlVXJsOiBmdW5jdGlvbihlbGVtZW50LCBhdHRycykge1xuICAgICAgcmV0dXJuIGF0dHJzLnRlbXBsYXRlVXJsIHx8ICd1aWIvdGVtcGxhdGUvZGF0ZXBpY2tlci95ZWFyLmh0bWwnO1xuICAgIH0sXG4gICAgcmVxdWlyZTogWydedWliRGF0ZXBpY2tlcicsICd1aWJZZWFycGlja2VyJ10sXG4gICAgcmVzdHJpY3Q6ICdBJyxcbiAgICBjb250cm9sbGVyOiAnVWliWWVhcnBpY2tlckNvbnRyb2xsZXInLFxuICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRycywgY3RybHMpIHtcbiAgICAgIHZhciBjdHJsID0gY3RybHNbMF07XG4gICAgICBhbmd1bGFyLmV4dGVuZChjdHJsLCBjdHJsc1sxXSk7XG4gICAgICBjdHJsLnllYXJwaWNrZXJJbml0KCk7XG5cbiAgICAgIGN0cmwucmVmcmVzaFZpZXcoKTtcbiAgICB9XG4gIH07XG59KTtcblxuYW5ndWxhci5tb2R1bGUoJ3VpLmJvb3RzdHJhcC5wb3NpdGlvbicsIFtdKVxuXG4vKipcbiAqIEEgc2V0IG9mIHV0aWxpdHkgbWV0aG9kcyBmb3Igd29ya2luZyB3aXRoIHRoZSBET00uXG4gKiBJdCBpcyBtZWFudCB0byBiZSB1c2VkIHdoZXJlIHdlIG5lZWQgdG8gYWJzb2x1dGUtcG9zaXRpb24gZWxlbWVudHMgaW5cbiAqIHJlbGF0aW9uIHRvIGFub3RoZXIgZWxlbWVudCAodGhpcyBpcyB0aGUgY2FzZSBmb3IgdG9vbHRpcHMsIHBvcG92ZXJzLFxuICogdHlwZWFoZWFkIHN1Z2dlc3Rpb25zIGV0Yy4pLlxuICovXG4gIC5mYWN0b3J5KCckdWliUG9zaXRpb24nLCBbJyRkb2N1bWVudCcsICckd2luZG93JywgZnVuY3Rpb24oJGRvY3VtZW50LCAkd2luZG93KSB7XG4gICAgLyoqXG4gICAgICogVXNlZCBieSBzY3JvbGxiYXJXaWR0aCgpIGZ1bmN0aW9uIHRvIGNhY2hlIHNjcm9sbGJhcidzIHdpZHRoLlxuICAgICAqIERvIG5vdCBhY2Nlc3MgdGhpcyB2YXJpYWJsZSBkaXJlY3RseSwgdXNlIHNjcm9sbGJhcldpZHRoKCkgaW5zdGVhZC5cbiAgICAgKi9cbiAgICB2YXIgU0NST0xMQkFSX1dJRFRIO1xuICAgIC8qKlxuICAgICAqIHNjcm9sbGJhciBvbiBib2R5IGFuZCBodG1sIGVsZW1lbnQgaW4gSUUgYW5kIEVkZ2Ugb3ZlcmxheVxuICAgICAqIGNvbnRlbnQgYW5kIHNob3VsZCBiZSBjb25zaWRlcmVkIDAgd2lkdGguXG4gICAgICovXG4gICAgdmFyIEJPRFlfU0NST0xMQkFSX1dJRFRIO1xuICAgIHZhciBPVkVSRkxPV19SRUdFWCA9IHtcbiAgICAgIG5vcm1hbDogLyhhdXRvfHNjcm9sbCkvLFxuICAgICAgaGlkZGVuOiAvKGF1dG98c2Nyb2xsfGhpZGRlbikvXG4gICAgfTtcbiAgICB2YXIgUExBQ0VNRU5UX1JFR0VYID0ge1xuICAgICAgYXV0bzogL1xccz9hdXRvP1xccz8vaSxcbiAgICAgIHByaW1hcnk6IC9eKHRvcHxib3R0b218bGVmdHxyaWdodCkkLyxcbiAgICAgIHNlY29uZGFyeTogL14odG9wfGJvdHRvbXxsZWZ0fHJpZ2h0fGNlbnRlcikkLyxcbiAgICAgIHZlcnRpY2FsOiAvXih0b3B8Ym90dG9tKSQvXG4gICAgfTtcbiAgICB2YXIgQk9EWV9SRUdFWCA9IC8oSFRNTHxCT0RZKS87XG5cbiAgICByZXR1cm4ge1xuXG4gICAgICAvKipcbiAgICAgICAqIFByb3ZpZGVzIGEgcmF3IERPTSBlbGVtZW50IGZyb20gYSBqUXVlcnkvalFMaXRlIGVsZW1lbnQuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtlbGVtZW50fSBlbGVtIC0gVGhlIGVsZW1lbnQgdG8gY29udmVydC5cbiAgICAgICAqXG4gICAgICAgKiBAcmV0dXJucyB7ZWxlbWVudH0gQSBIVE1MIGVsZW1lbnQuXG4gICAgICAgKi9cbiAgICAgIGdldFJhd05vZGU6IGZ1bmN0aW9uKGVsZW0pIHtcbiAgICAgICAgcmV0dXJuIGVsZW0ubm9kZU5hbWUgPyBlbGVtIDogZWxlbVswXSB8fCBlbGVtO1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBQcm92aWRlcyBhIHBhcnNlZCBudW1iZXIgZm9yIGEgc3R5bGUgcHJvcGVydHkuICBTdHJpcHNcbiAgICAgICAqIHVuaXRzIGFuZCBjYXN0cyBpbnZhbGlkIG51bWJlcnMgdG8gMC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgLSBUaGUgc3R5bGUgdmFsdWUgdG8gcGFyc2UuXG4gICAgICAgKlxuICAgICAgICogQHJldHVybnMge251bWJlcn0gQSB2YWxpZCBudW1iZXIuXG4gICAgICAgKi9cbiAgICAgIHBhcnNlU3R5bGU6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHZhbHVlID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gICAgICAgIHJldHVybiBpc0Zpbml0ZSh2YWx1ZSkgPyB2YWx1ZSA6IDA7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFByb3ZpZGVzIHRoZSBjbG9zZXN0IHBvc2l0aW9uZWQgYW5jZXN0b3IuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtlbGVtZW50fSBlbGVtZW50IC0gVGhlIGVsZW1lbnQgdG8gZ2V0IHRoZSBvZmZlc3QgcGFyZW50IGZvci5cbiAgICAgICAqXG4gICAgICAgKiBAcmV0dXJucyB7ZWxlbWVudH0gVGhlIGNsb3Nlc3QgcG9zaXRpb25lZCBhbmNlc3Rvci5cbiAgICAgICAqL1xuICAgICAgb2Zmc2V0UGFyZW50OiBmdW5jdGlvbihlbGVtKSB7XG4gICAgICAgIGVsZW0gPSB0aGlzLmdldFJhd05vZGUoZWxlbSk7XG5cbiAgICAgICAgdmFyIG9mZnNldFBhcmVudCA9IGVsZW0ub2Zmc2V0UGFyZW50IHx8ICRkb2N1bWVudFswXS5kb2N1bWVudEVsZW1lbnQ7XG5cbiAgICAgICAgZnVuY3Rpb24gaXNTdGF0aWNQb3NpdGlvbmVkKGVsKSB7XG4gICAgICAgICAgcmV0dXJuICgkd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpLnBvc2l0aW9uIHx8ICdzdGF0aWMnKSA9PT0gJ3N0YXRpYyc7XG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSAob2Zmc2V0UGFyZW50ICYmIG9mZnNldFBhcmVudCAhPT0gJGRvY3VtZW50WzBdLmRvY3VtZW50RWxlbWVudCAmJiBpc1N0YXRpY1Bvc2l0aW9uZWQob2Zmc2V0UGFyZW50KSkge1xuICAgICAgICAgIG9mZnNldFBhcmVudCA9IG9mZnNldFBhcmVudC5vZmZzZXRQYXJlbnQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb2Zmc2V0UGFyZW50IHx8ICRkb2N1bWVudFswXS5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFByb3ZpZGVzIHRoZSBzY3JvbGxiYXIgd2lkdGgsIGNvbmNlcHQgZnJvbSBUV0JTIG1lYXN1cmVTY3JvbGxiYXIoKVxuICAgICAgICogZnVuY3Rpb24gaW4gaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFzdGVyL2pzL21vZGFsLmpzXG4gICAgICAgKiBJbiBJRSBhbmQgRWRnZSwgc2NvbGxiYXIgb24gYm9keSBhbmQgaHRtbCBlbGVtZW50IG92ZXJsYXkgYW5kIHNob3VsZFxuICAgICAgICogcmV0dXJuIGEgd2lkdGggb2YgMC5cbiAgICAgICAqXG4gICAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgd2lkdGggb2YgdGhlIGJyb3dzZXIgc2NvbGxiYXIuXG4gICAgICAgKi9cbiAgICAgIHNjcm9sbGJhcldpZHRoOiBmdW5jdGlvbihpc0JvZHkpIHtcbiAgICAgICAgaWYgKGlzQm9keSkge1xuICAgICAgICAgIGlmIChhbmd1bGFyLmlzVW5kZWZpbmVkKEJPRFlfU0NST0xMQkFSX1dJRFRIKSkge1xuICAgICAgICAgICAgdmFyIGJvZHlFbGVtID0gJGRvY3VtZW50LmZpbmQoJ2JvZHknKTtcbiAgICAgICAgICAgIGJvZHlFbGVtLmFkZENsYXNzKCd1aWItcG9zaXRpb24tYm9keS1zY3JvbGxiYXItbWVhc3VyZScpO1xuICAgICAgICAgICAgQk9EWV9TQ1JPTExCQVJfV0lEVEggPSAkd2luZG93LmlubmVyV2lkdGggLSBib2R5RWxlbVswXS5jbGllbnRXaWR0aDtcbiAgICAgICAgICAgIEJPRFlfU0NST0xMQkFSX1dJRFRIID0gaXNGaW5pdGUoQk9EWV9TQ1JPTExCQVJfV0lEVEgpID8gQk9EWV9TQ1JPTExCQVJfV0lEVEggOiAwO1xuICAgICAgICAgICAgYm9keUVsZW0ucmVtb3ZlQ2xhc3MoJ3VpYi1wb3NpdGlvbi1ib2R5LXNjcm9sbGJhci1tZWFzdXJlJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBCT0RZX1NDUk9MTEJBUl9XSURUSDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhbmd1bGFyLmlzVW5kZWZpbmVkKFNDUk9MTEJBUl9XSURUSCkpIHtcbiAgICAgICAgICB2YXIgc2Nyb2xsRWxlbSA9IGFuZ3VsYXIuZWxlbWVudCgnPGRpdiBjbGFzcz1cInVpYi1wb3NpdGlvbi1zY3JvbGxiYXItbWVhc3VyZVwiPjwvZGl2PicpO1xuICAgICAgICAgICRkb2N1bWVudC5maW5kKCdib2R5JykuYXBwZW5kKHNjcm9sbEVsZW0pO1xuICAgICAgICAgIFNDUk9MTEJBUl9XSURUSCA9IHNjcm9sbEVsZW1bMF0ub2Zmc2V0V2lkdGggLSBzY3JvbGxFbGVtWzBdLmNsaWVudFdpZHRoO1xuICAgICAgICAgIFNDUk9MTEJBUl9XSURUSCA9IGlzRmluaXRlKFNDUk9MTEJBUl9XSURUSCkgPyBTQ1JPTExCQVJfV0lEVEggOiAwO1xuICAgICAgICAgIHNjcm9sbEVsZW0ucmVtb3ZlKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gU0NST0xMQkFSX1dJRFRIO1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBQcm92aWRlcyB0aGUgcGFkZGluZyByZXF1aXJlZCBvbiBhbiBlbGVtZW50IHRvIHJlcGxhY2UgdGhlIHNjcm9sbGJhci5cbiAgICAgICAqXG4gICAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBBbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAgICAgKiAgIDx1bD5cbiAgICAgICAqICAgICA8bGk+KipzY3JvbGxiYXJXaWR0aCoqOiB0aGUgd2lkdGggb2YgdGhlIHNjcm9sbGJhcjwvbGk+XG4gICAgICAgKiAgICAgPGxpPioqd2lkdGhPdmVyZmxvdyoqOiB3aGV0aGVyIHRoZSB0aGUgd2lkdGggaXMgb3ZlcmZsb3dpbmc8L2xpPlxuICAgICAgICogICAgIDxsaT4qKnJpZ2h0Kio6IHRoZSBhbW91bnQgb2YgcmlnaHQgcGFkZGluZyBvbiB0aGUgZWxlbWVudCBuZWVkZWQgdG8gcmVwbGFjZSB0aGUgc2Nyb2xsYmFyPC9saT5cbiAgICAgICAqICAgICA8bGk+KipyaWdodE9yaWdpbmFsKio6IHRoZSBhbW91bnQgb2YgcmlnaHQgcGFkZGluZyBjdXJyZW50bHkgb24gdGhlIGVsZW1lbnQ8L2xpPlxuICAgICAgICogICAgIDxsaT4qKmhlaWdodE92ZXJmbG93Kio6IHdoZXRoZXIgdGhlIHRoZSBoZWlnaHQgaXMgb3ZlcmZsb3dpbmc8L2xpPlxuICAgICAgICogICAgIDxsaT4qKmJvdHRvbSoqOiB0aGUgYW1vdW50IG9mIGJvdHRvbSBwYWRkaW5nIG9uIHRoZSBlbGVtZW50IG5lZWRlZCB0byByZXBsYWNlIHRoZSBzY3JvbGxiYXI8L2xpPlxuICAgICAgICogICAgIDxsaT4qKmJvdHRvbU9yaWdpbmFsKio6IHRoZSBhbW91bnQgb2YgYm90dG9tIHBhZGRpbmcgY3VycmVudGx5IG9uIHRoZSBlbGVtZW50PC9saT5cbiAgICAgICAqICAgPC91bD5cbiAgICAgICAqL1xuICAgICAgc2Nyb2xsYmFyUGFkZGluZzogZnVuY3Rpb24oZWxlbSkge1xuICAgICAgICBlbGVtID0gdGhpcy5nZXRSYXdOb2RlKGVsZW0pO1xuXG4gICAgICAgIHZhciBlbGVtU3R5bGUgPSAkd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbSk7XG4gICAgICAgIHZhciBwYWRkaW5nUmlnaHQgPSB0aGlzLnBhcnNlU3R5bGUoZWxlbVN0eWxlLnBhZGRpbmdSaWdodCk7XG4gICAgICAgIHZhciBwYWRkaW5nQm90dG9tID0gdGhpcy5wYXJzZVN0eWxlKGVsZW1TdHlsZS5wYWRkaW5nQm90dG9tKTtcbiAgICAgICAgdmFyIHNjcm9sbFBhcmVudCA9IHRoaXMuc2Nyb2xsUGFyZW50KGVsZW0sIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgdmFyIHNjcm9sbGJhcldpZHRoID0gdGhpcy5zY3JvbGxiYXJXaWR0aChCT0RZX1JFR0VYLnRlc3Qoc2Nyb2xsUGFyZW50LnRhZ05hbWUpKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHNjcm9sbGJhcldpZHRoOiBzY3JvbGxiYXJXaWR0aCxcbiAgICAgICAgICB3aWR0aE92ZXJmbG93OiBzY3JvbGxQYXJlbnQuc2Nyb2xsV2lkdGggPiBzY3JvbGxQYXJlbnQuY2xpZW50V2lkdGgsXG4gICAgICAgICAgcmlnaHQ6IHBhZGRpbmdSaWdodCArIHNjcm9sbGJhcldpZHRoLFxuICAgICAgICAgIG9yaWdpbmFsUmlnaHQ6IHBhZGRpbmdSaWdodCxcbiAgICAgICAgICBoZWlnaHRPdmVyZmxvdzogc2Nyb2xsUGFyZW50LnNjcm9sbEhlaWdodCA+IHNjcm9sbFBhcmVudC5jbGllbnRIZWlnaHQsXG4gICAgICAgICAgYm90dG9tOiBwYWRkaW5nQm90dG9tICsgc2Nyb2xsYmFyV2lkdGgsXG4gICAgICAgICAgb3JpZ2luYWxCb3R0b206IHBhZGRpbmdCb3R0b21cbiAgICAgICAgIH07XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIENoZWNrcyB0byBzZWUgaWYgdGhlIGVsZW1lbnQgaXMgc2Nyb2xsYWJsZS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge2VsZW1lbnR9IGVsZW0gLSBUaGUgZWxlbWVudCB0byBjaGVjay5cbiAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IFtpbmNsdWRlSGlkZGVuPWZhbHNlXSAtIFNob3VsZCBzY3JvbGwgc3R5bGUgb2YgJ2hpZGRlbicgYmUgY29uc2lkZXJlZCxcbiAgICAgICAqICAgZGVmYXVsdCBpcyBmYWxzZS5cbiAgICAgICAqXG4gICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gV2hldGhlciB0aGUgZWxlbWVudCBpcyBzY3JvbGxhYmxlLlxuICAgICAgICovXG4gICAgICBpc1Njcm9sbGFibGU6IGZ1bmN0aW9uKGVsZW0sIGluY2x1ZGVIaWRkZW4pIHtcbiAgICAgICAgZWxlbSA9IHRoaXMuZ2V0UmF3Tm9kZShlbGVtKTtcblxuICAgICAgICB2YXIgb3ZlcmZsb3dSZWdleCA9IGluY2x1ZGVIaWRkZW4gPyBPVkVSRkxPV19SRUdFWC5oaWRkZW4gOiBPVkVSRkxPV19SRUdFWC5ub3JtYWw7XG4gICAgICAgIHZhciBlbGVtU3R5bGUgPSAkd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbSk7XG4gICAgICAgIHJldHVybiBvdmVyZmxvd1JlZ2V4LnRlc3QoZWxlbVN0eWxlLm92ZXJmbG93ICsgZWxlbVN0eWxlLm92ZXJmbG93WSArIGVsZW1TdHlsZS5vdmVyZmxvd1gpO1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBQcm92aWRlcyB0aGUgY2xvc2VzdCBzY3JvbGxhYmxlIGFuY2VzdG9yLlxuICAgICAgICogQSBwb3J0IG9mIHRoZSBqUXVlcnkgVUkgc2Nyb2xsUGFyZW50IG1ldGhvZDpcbiAgICAgICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvanF1ZXJ5LXVpL2Jsb2IvbWFzdGVyL3VpL3Njcm9sbC1wYXJlbnQuanNcbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge2VsZW1lbnR9IGVsZW0gLSBUaGUgZWxlbWVudCB0byBmaW5kIHRoZSBzY3JvbGwgcGFyZW50IG9mLlxuICAgICAgICogQHBhcmFtIHtib29sZWFuPX0gW2luY2x1ZGVIaWRkZW49ZmFsc2VdIC0gU2hvdWxkIHNjcm9sbCBzdHlsZSBvZiAnaGlkZGVuJyBiZSBjb25zaWRlcmVkLFxuICAgICAgICogICBkZWZhdWx0IGlzIGZhbHNlLlxuICAgICAgICogQHBhcmFtIHtib29sZWFuPX0gW2luY2x1ZGVTZWxmPWZhbHNlXSAtIFNob3VsZCB0aGUgZWxlbWVudCBiZWluZyBwYXNzZWQgYmVcbiAgICAgICAqIGluY2x1ZGVkIGluIHRoZSBzY3JvbGxhYmxlIGxsb2t1cC5cbiAgICAgICAqXG4gICAgICAgKiBAcmV0dXJucyB7ZWxlbWVudH0gQSBIVE1MIGVsZW1lbnQuXG4gICAgICAgKi9cbiAgICAgIHNjcm9sbFBhcmVudDogZnVuY3Rpb24oZWxlbSwgaW5jbHVkZUhpZGRlbiwgaW5jbHVkZVNlbGYpIHtcbiAgICAgICAgZWxlbSA9IHRoaXMuZ2V0UmF3Tm9kZShlbGVtKTtcblxuICAgICAgICB2YXIgb3ZlcmZsb3dSZWdleCA9IGluY2x1ZGVIaWRkZW4gPyBPVkVSRkxPV19SRUdFWC5oaWRkZW4gOiBPVkVSRkxPV19SRUdFWC5ub3JtYWw7XG4gICAgICAgIHZhciBkb2N1bWVudEVsID0gJGRvY3VtZW50WzBdLmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgdmFyIGVsZW1TdHlsZSA9ICR3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtKTtcbiAgICAgICAgaWYgKGluY2x1ZGVTZWxmICYmIG92ZXJmbG93UmVnZXgudGVzdChlbGVtU3R5bGUub3ZlcmZsb3cgKyBlbGVtU3R5bGUub3ZlcmZsb3dZICsgZWxlbVN0eWxlLm92ZXJmbG93WCkpIHtcbiAgICAgICAgICByZXR1cm4gZWxlbTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXhjbHVkZVN0YXRpYyA9IGVsZW1TdHlsZS5wb3NpdGlvbiA9PT0gJ2Fic29sdXRlJztcbiAgICAgICAgdmFyIHNjcm9sbFBhcmVudCA9IGVsZW0ucGFyZW50RWxlbWVudCB8fCBkb2N1bWVudEVsO1xuXG4gICAgICAgIGlmIChzY3JvbGxQYXJlbnQgPT09IGRvY3VtZW50RWwgfHwgZWxlbVN0eWxlLnBvc2l0aW9uID09PSAnZml4ZWQnKSB7XG4gICAgICAgICAgcmV0dXJuIGRvY3VtZW50RWw7XG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSAoc2Nyb2xsUGFyZW50LnBhcmVudEVsZW1lbnQgJiYgc2Nyb2xsUGFyZW50ICE9PSBkb2N1bWVudEVsKSB7XG4gICAgICAgICAgdmFyIHNwU3R5bGUgPSAkd2luZG93LmdldENvbXB1dGVkU3R5bGUoc2Nyb2xsUGFyZW50KTtcbiAgICAgICAgICBpZiAoZXhjbHVkZVN0YXRpYyAmJiBzcFN0eWxlLnBvc2l0aW9uICE9PSAnc3RhdGljJykge1xuICAgICAgICAgICAgZXhjbHVkZVN0YXRpYyA9IGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghZXhjbHVkZVN0YXRpYyAmJiBvdmVyZmxvd1JlZ2V4LnRlc3Qoc3BTdHlsZS5vdmVyZmxvdyArIHNwU3R5bGUub3ZlcmZsb3dZICsgc3BTdHlsZS5vdmVyZmxvd1gpKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgc2Nyb2xsUGFyZW50ID0gc2Nyb2xsUGFyZW50LnBhcmVudEVsZW1lbnQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2Nyb2xsUGFyZW50O1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBQcm92aWRlcyByZWFkLW9ubHkgZXF1aXZhbGVudCBvZiBqUXVlcnkncyBwb3NpdGlvbiBmdW5jdGlvbjpcbiAgICAgICAqIGh0dHA6Ly9hcGkuanF1ZXJ5LmNvbS9wb3NpdGlvbi8gLSBkaXN0YW5jZSB0byBjbG9zZXN0IHBvc2l0aW9uZWRcbiAgICAgICAqIGFuY2VzdG9yLiAgRG9lcyBub3QgYWNjb3VudCBmb3IgbWFyZ2lucyBieSBkZWZhdWx0IGxpa2UgalF1ZXJ5IHBvc2l0aW9uLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7ZWxlbWVudH0gZWxlbSAtIFRoZSBlbGVtZW50IHRvIGNhY2x1bGF0ZSB0aGUgcG9zaXRpb24gb24uXG4gICAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBbaW5jbHVkZU1hcmdpbnM9ZmFsc2VdIC0gU2hvdWxkIG1hcmdpbnMgYmUgYWNjb3VudGVkXG4gICAgICAgKiBmb3IsIGRlZmF1bHQgaXMgZmFsc2UuXG4gICAgICAgKlxuICAgICAgICogQHJldHVybnMge29iamVjdH0gQW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgICAgICogICA8dWw+XG4gICAgICAgKiAgICAgPGxpPioqd2lkdGgqKjogdGhlIHdpZHRoIG9mIHRoZSBlbGVtZW50PC9saT5cbiAgICAgICAqICAgICA8bGk+KipoZWlnaHQqKjogdGhlIGhlaWdodCBvZiB0aGUgZWxlbWVudDwvbGk+XG4gICAgICAgKiAgICAgPGxpPioqdG9wKio6IGRpc3RhbmNlIHRvIHRvcCBlZGdlIG9mIG9mZnNldCBwYXJlbnQ8L2xpPlxuICAgICAgICogICAgIDxsaT4qKmxlZnQqKjogZGlzdGFuY2UgdG8gbGVmdCBlZGdlIG9mIG9mZnNldCBwYXJlbnQ8L2xpPlxuICAgICAgICogICA8L3VsPlxuICAgICAgICovXG4gICAgICBwb3NpdGlvbjogZnVuY3Rpb24oZWxlbSwgaW5jbHVkZU1hZ2lucykge1xuICAgICAgICBlbGVtID0gdGhpcy5nZXRSYXdOb2RlKGVsZW0pO1xuXG4gICAgICAgIHZhciBlbGVtT2Zmc2V0ID0gdGhpcy5vZmZzZXQoZWxlbSk7XG4gICAgICAgIGlmIChpbmNsdWRlTWFnaW5zKSB7XG4gICAgICAgICAgdmFyIGVsZW1TdHlsZSA9ICR3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtKTtcbiAgICAgICAgICBlbGVtT2Zmc2V0LnRvcCAtPSB0aGlzLnBhcnNlU3R5bGUoZWxlbVN0eWxlLm1hcmdpblRvcCk7XG4gICAgICAgICAgZWxlbU9mZnNldC5sZWZ0IC09IHRoaXMucGFyc2VTdHlsZShlbGVtU3R5bGUubWFyZ2luTGVmdCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMub2Zmc2V0UGFyZW50KGVsZW0pO1xuICAgICAgICB2YXIgcGFyZW50T2Zmc2V0ID0ge3RvcDogMCwgbGVmdDogMH07XG5cbiAgICAgICAgaWYgKHBhcmVudCAhPT0gJGRvY3VtZW50WzBdLmRvY3VtZW50RWxlbWVudCkge1xuICAgICAgICAgIHBhcmVudE9mZnNldCA9IHRoaXMub2Zmc2V0KHBhcmVudCk7XG4gICAgICAgICAgcGFyZW50T2Zmc2V0LnRvcCArPSBwYXJlbnQuY2xpZW50VG9wIC0gcGFyZW50LnNjcm9sbFRvcDtcbiAgICAgICAgICBwYXJlbnRPZmZzZXQubGVmdCArPSBwYXJlbnQuY2xpZW50TGVmdCAtIHBhcmVudC5zY3JvbGxMZWZ0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB3aWR0aDogTWF0aC5yb3VuZChhbmd1bGFyLmlzTnVtYmVyKGVsZW1PZmZzZXQud2lkdGgpID8gZWxlbU9mZnNldC53aWR0aCA6IGVsZW0ub2Zmc2V0V2lkdGgpLFxuICAgICAgICAgIGhlaWdodDogTWF0aC5yb3VuZChhbmd1bGFyLmlzTnVtYmVyKGVsZW1PZmZzZXQuaGVpZ2h0KSA/IGVsZW1PZmZzZXQuaGVpZ2h0IDogZWxlbS5vZmZzZXRIZWlnaHQpLFxuICAgICAgICAgIHRvcDogTWF0aC5yb3VuZChlbGVtT2Zmc2V0LnRvcCAtIHBhcmVudE9mZnNldC50b3ApLFxuICAgICAgICAgIGxlZnQ6IE1hdGgucm91bmQoZWxlbU9mZnNldC5sZWZ0IC0gcGFyZW50T2Zmc2V0LmxlZnQpXG4gICAgICAgIH07XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFByb3ZpZGVzIHJlYWQtb25seSBlcXVpdmFsZW50IG9mIGpRdWVyeSdzIG9mZnNldCBmdW5jdGlvbjpcbiAgICAgICAqIGh0dHA6Ly9hcGkuanF1ZXJ5LmNvbS9vZmZzZXQvIC0gZGlzdGFuY2UgdG8gdmlld3BvcnQuICBEb2VzXG4gICAgICAgKiBub3QgYWNjb3VudCBmb3IgYm9yZGVycywgbWFyZ2lucywgb3IgcGFkZGluZyBvbiB0aGUgYm9keVxuICAgICAgICogZWxlbWVudC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge2VsZW1lbnR9IGVsZW0gLSBUaGUgZWxlbWVudCB0byBjYWxjdWxhdGUgdGhlIG9mZnNldCBvbi5cbiAgICAgICAqXG4gICAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBBbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAgICAgKiAgIDx1bD5cbiAgICAgICAqICAgICA8bGk+Kip3aWR0aCoqOiB0aGUgd2lkdGggb2YgdGhlIGVsZW1lbnQ8L2xpPlxuICAgICAgICogICAgIDxsaT4qKmhlaWdodCoqOiB0aGUgaGVpZ2h0IG9mIHRoZSBlbGVtZW50PC9saT5cbiAgICAgICAqICAgICA8bGk+Kip0b3AqKjogZGlzdGFuY2UgdG8gdG9wIGVkZ2Ugb2Ygdmlld3BvcnQ8L2xpPlxuICAgICAgICogICAgIDxsaT4qKnJpZ2h0Kio6IGRpc3RhbmNlIHRvIGJvdHRvbSBlZGdlIG9mIHZpZXdwb3J0PC9saT5cbiAgICAgICAqICAgPC91bD5cbiAgICAgICAqL1xuICAgICAgb2Zmc2V0OiBmdW5jdGlvbihlbGVtKSB7XG4gICAgICAgIGVsZW0gPSB0aGlzLmdldFJhd05vZGUoZWxlbSk7XG5cbiAgICAgICAgdmFyIGVsZW1CQ1IgPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHdpZHRoOiBNYXRoLnJvdW5kKGFuZ3VsYXIuaXNOdW1iZXIoZWxlbUJDUi53aWR0aCkgPyBlbGVtQkNSLndpZHRoIDogZWxlbS5vZmZzZXRXaWR0aCksXG4gICAgICAgICAgaGVpZ2h0OiBNYXRoLnJvdW5kKGFuZ3VsYXIuaXNOdW1iZXIoZWxlbUJDUi5oZWlnaHQpID8gZWxlbUJDUi5oZWlnaHQgOiBlbGVtLm9mZnNldEhlaWdodCksXG4gICAgICAgICAgdG9wOiBNYXRoLnJvdW5kKGVsZW1CQ1IudG9wICsgKCR3aW5kb3cucGFnZVlPZmZzZXQgfHwgJGRvY3VtZW50WzBdLmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3ApKSxcbiAgICAgICAgICBsZWZ0OiBNYXRoLnJvdW5kKGVsZW1CQ1IubGVmdCArICgkd2luZG93LnBhZ2VYT2Zmc2V0IHx8ICRkb2N1bWVudFswXS5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCkpXG4gICAgICAgIH07XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFByb3ZpZGVzIG9mZnNldCBkaXN0YW5jZSB0byB0aGUgY2xvc2VzdCBzY3JvbGxhYmxlIGFuY2VzdG9yXG4gICAgICAgKiBvciB2aWV3cG9ydC4gIEFjY291bnRzIGZvciBib3JkZXIgYW5kIHNjcm9sbGJhciB3aWR0aC5cbiAgICAgICAqXG4gICAgICAgKiBSaWdodCBhbmQgYm90dG9tIGRpbWVuc2lvbnMgcmVwcmVzZW50IHRoZSBkaXN0YW5jZSB0byB0aGVcbiAgICAgICAqIHJlc3BlY3RpdmUgZWRnZSBvZiB0aGUgdmlld3BvcnQgZWxlbWVudC4gIElmIHRoZSBlbGVtZW50XG4gICAgICAgKiBlZGdlIGV4dGVuZHMgYmV5b25kIHRoZSB2aWV3cG9ydCwgYSBuZWdhdGl2ZSB2YWx1ZSB3aWxsIGJlXG4gICAgICAgKiByZXBvcnRlZC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge2VsZW1lbnR9IGVsZW0gLSBUaGUgZWxlbWVudCB0byBnZXQgdGhlIHZpZXdwb3J0IG9mZnNldCBmb3IuXG4gICAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBbdXNlRG9jdW1lbnQ9ZmFsc2VdIC0gU2hvdWxkIHRoZSB2aWV3cG9ydCBiZSB0aGUgZG9jdW1lbnQgZWxlbWVudCBpbnN0ZWFkXG4gICAgICAgKiBvZiB0aGUgZmlyc3Qgc2Nyb2xsYWJsZSBlbGVtZW50LCBkZWZhdWx0IGlzIGZhbHNlLlxuICAgICAgICogQHBhcmFtIHtib29sZWFuPX0gW2luY2x1ZGVQYWRkaW5nPXRydWVdIC0gU2hvdWxkIHRoZSBwYWRkaW5nIG9uIHRoZSBvZmZzZXQgcGFyZW50IGVsZW1lbnRcbiAgICAgICAqIGJlIGFjY291bnRlZCBmb3IsIGRlZmF1bHQgaXMgdHJ1ZS5cbiAgICAgICAqXG4gICAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBBbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAgICAgKiAgIDx1bD5cbiAgICAgICAqICAgICA8bGk+Kip0b3AqKjogZGlzdGFuY2UgdG8gdGhlIHRvcCBjb250ZW50IGVkZ2Ugb2Ygdmlld3BvcnQgZWxlbWVudDwvbGk+XG4gICAgICAgKiAgICAgPGxpPioqYm90dG9tKio6IGRpc3RhbmNlIHRvIHRoZSBib3R0b20gY29udGVudCBlZGdlIG9mIHZpZXdwb3J0IGVsZW1lbnQ8L2xpPlxuICAgICAgICogICAgIDxsaT4qKmxlZnQqKjogZGlzdGFuY2UgdG8gdGhlIGxlZnQgY29udGVudCBlZGdlIG9mIHZpZXdwb3J0IGVsZW1lbnQ8L2xpPlxuICAgICAgICogICAgIDxsaT4qKnJpZ2h0Kio6IGRpc3RhbmNlIHRvIHRoZSByaWdodCBjb250ZW50IGVkZ2Ugb2Ygdmlld3BvcnQgZWxlbWVudDwvbGk+XG4gICAgICAgKiAgIDwvdWw+XG4gICAgICAgKi9cbiAgICAgIHZpZXdwb3J0T2Zmc2V0OiBmdW5jdGlvbihlbGVtLCB1c2VEb2N1bWVudCwgaW5jbHVkZVBhZGRpbmcpIHtcbiAgICAgICAgZWxlbSA9IHRoaXMuZ2V0UmF3Tm9kZShlbGVtKTtcbiAgICAgICAgaW5jbHVkZVBhZGRpbmcgPSBpbmNsdWRlUGFkZGluZyAhPT0gZmFsc2UgPyB0cnVlIDogZmFsc2U7XG5cbiAgICAgICAgdmFyIGVsZW1CQ1IgPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB2YXIgb2Zmc2V0QkNSID0ge3RvcDogMCwgbGVmdDogMCwgYm90dG9tOiAwLCByaWdodDogMH07XG5cbiAgICAgICAgdmFyIG9mZnNldFBhcmVudCA9IHVzZURvY3VtZW50ID8gJGRvY3VtZW50WzBdLmRvY3VtZW50RWxlbWVudCA6IHRoaXMuc2Nyb2xsUGFyZW50KGVsZW0pO1xuICAgICAgICB2YXIgb2Zmc2V0UGFyZW50QkNSID0gb2Zmc2V0UGFyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICAgIG9mZnNldEJDUi50b3AgPSBvZmZzZXRQYXJlbnRCQ1IudG9wICsgb2Zmc2V0UGFyZW50LmNsaWVudFRvcDtcbiAgICAgICAgb2Zmc2V0QkNSLmxlZnQgPSBvZmZzZXRQYXJlbnRCQ1IubGVmdCArIG9mZnNldFBhcmVudC5jbGllbnRMZWZ0O1xuICAgICAgICBpZiAob2Zmc2V0UGFyZW50ID09PSAkZG9jdW1lbnRbMF0uZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgICAgICAgb2Zmc2V0QkNSLnRvcCArPSAkd2luZG93LnBhZ2VZT2Zmc2V0O1xuICAgICAgICAgIG9mZnNldEJDUi5sZWZ0ICs9ICR3aW5kb3cucGFnZVhPZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgb2Zmc2V0QkNSLmJvdHRvbSA9IG9mZnNldEJDUi50b3AgKyBvZmZzZXRQYXJlbnQuY2xpZW50SGVpZ2h0O1xuICAgICAgICBvZmZzZXRCQ1IucmlnaHQgPSBvZmZzZXRCQ1IubGVmdCArIG9mZnNldFBhcmVudC5jbGllbnRXaWR0aDtcblxuICAgICAgICBpZiAoaW5jbHVkZVBhZGRpbmcpIHtcbiAgICAgICAgICB2YXIgb2Zmc2V0UGFyZW50U3R5bGUgPSAkd2luZG93LmdldENvbXB1dGVkU3R5bGUob2Zmc2V0UGFyZW50KTtcbiAgICAgICAgICBvZmZzZXRCQ1IudG9wICs9IHRoaXMucGFyc2VTdHlsZShvZmZzZXRQYXJlbnRTdHlsZS5wYWRkaW5nVG9wKTtcbiAgICAgICAgICBvZmZzZXRCQ1IuYm90dG9tIC09IHRoaXMucGFyc2VTdHlsZShvZmZzZXRQYXJlbnRTdHlsZS5wYWRkaW5nQm90dG9tKTtcbiAgICAgICAgICBvZmZzZXRCQ1IubGVmdCArPSB0aGlzLnBhcnNlU3R5bGUob2Zmc2V0UGFyZW50U3R5bGUucGFkZGluZ0xlZnQpO1xuICAgICAgICAgIG9mZnNldEJDUi5yaWdodCAtPSB0aGlzLnBhcnNlU3R5bGUob2Zmc2V0UGFyZW50U3R5bGUucGFkZGluZ1JpZ2h0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdG9wOiBNYXRoLnJvdW5kKGVsZW1CQ1IudG9wIC0gb2Zmc2V0QkNSLnRvcCksXG4gICAgICAgICAgYm90dG9tOiBNYXRoLnJvdW5kKG9mZnNldEJDUi5ib3R0b20gLSBlbGVtQkNSLmJvdHRvbSksXG4gICAgICAgICAgbGVmdDogTWF0aC5yb3VuZChlbGVtQkNSLmxlZnQgLSBvZmZzZXRCQ1IubGVmdCksXG4gICAgICAgICAgcmlnaHQ6IE1hdGgucm91bmQob2Zmc2V0QkNSLnJpZ2h0IC0gZWxlbUJDUi5yaWdodClcbiAgICAgICAgfTtcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogUHJvdmlkZXMgYW4gYXJyYXkgb2YgcGxhY2VtZW50IHZhbHVlcyBwYXJzZWQgZnJvbSBhIHBsYWNlbWVudCBzdHJpbmcuXG4gICAgICAgKiBBbG9uZyB3aXRoIHRoZSAnYXV0bycgaW5kaWNhdG9yLCBzdXBwb3J0ZWQgcGxhY2VtZW50IHN0cmluZ3MgYXJlOlxuICAgICAgICogICA8dWw+XG4gICAgICAgKiAgICAgPGxpPnRvcDogZWxlbWVudCBvbiB0b3AsIGhvcml6b250YWxseSBjZW50ZXJlZCBvbiBob3N0IGVsZW1lbnQuPC9saT5cbiAgICAgICAqICAgICA8bGk+dG9wLWxlZnQ6IGVsZW1lbnQgb24gdG9wLCBsZWZ0IGVkZ2UgYWxpZ25lZCB3aXRoIGhvc3QgZWxlbWVudCBsZWZ0IGVkZ2UuPC9saT5cbiAgICAgICAqICAgICA8bGk+dG9wLXJpZ2h0OiBlbGVtZW50IG9uIHRvcCwgbGVyaWdodGZ0IGVkZ2UgYWxpZ25lZCB3aXRoIGhvc3QgZWxlbWVudCByaWdodCBlZGdlLjwvbGk+XG4gICAgICAgKiAgICAgPGxpPmJvdHRvbTogZWxlbWVudCBvbiBib3R0b20sIGhvcml6b250YWxseSBjZW50ZXJlZCBvbiBob3N0IGVsZW1lbnQuPC9saT5cbiAgICAgICAqICAgICA8bGk+Ym90dG9tLWxlZnQ6IGVsZW1lbnQgb24gYm90dG9tLCBsZWZ0IGVkZ2UgYWxpZ25lZCB3aXRoIGhvc3QgZWxlbWVudCBsZWZ0IGVkZ2UuPC9saT5cbiAgICAgICAqICAgICA8bGk+Ym90dG9tLXJpZ2h0OiBlbGVtZW50IG9uIGJvdHRvbSwgcmlnaHQgZWRnZSBhbGlnbmVkIHdpdGggaG9zdCBlbGVtZW50IHJpZ2h0IGVkZ2UuPC9saT5cbiAgICAgICAqICAgICA8bGk+bGVmdDogZWxlbWVudCBvbiBsZWZ0LCB2ZXJ0aWNhbGx5IGNlbnRlcmVkIG9uIGhvc3QgZWxlbWVudC48L2xpPlxuICAgICAgICogICAgIDxsaT5sZWZ0LXRvcDogZWxlbWVudCBvbiBsZWZ0LCB0b3AgZWRnZSBhbGlnbmVkIHdpdGggaG9zdCBlbGVtZW50IHRvcCBlZGdlLjwvbGk+XG4gICAgICAgKiAgICAgPGxpPmxlZnQtYm90dG9tOiBlbGVtZW50IG9uIGxlZnQsIGJvdHRvbSBlZGdlIGFsaWduZWQgd2l0aCBob3N0IGVsZW1lbnQgYm90dG9tIGVkZ2UuPC9saT5cbiAgICAgICAqICAgICA8bGk+cmlnaHQ6IGVsZW1lbnQgb24gcmlnaHQsIHZlcnRpY2FsbHkgY2VudGVyZWQgb24gaG9zdCBlbGVtZW50LjwvbGk+XG4gICAgICAgKiAgICAgPGxpPnJpZ2h0LXRvcDogZWxlbWVudCBvbiByaWdodCwgdG9wIGVkZ2UgYWxpZ25lZCB3aXRoIGhvc3QgZWxlbWVudCB0b3AgZWRnZS48L2xpPlxuICAgICAgICogICAgIDxsaT5yaWdodC1ib3R0b206IGVsZW1lbnQgb24gcmlnaHQsIGJvdHRvbSBlZGdlIGFsaWduZWQgd2l0aCBob3N0IGVsZW1lbnQgYm90dG9tIGVkZ2UuPC9saT5cbiAgICAgICAqICAgPC91bD5cbiAgICAgICAqIEEgcGxhY2VtZW50IHN0cmluZyB3aXRoIGFuICdhdXRvJyBpbmRpY2F0b3IgaXMgZXhwZWN0ZWQgdG8gYmVcbiAgICAgICAqIHNwYWNlIHNlcGFyYXRlZCBmcm9tIHRoZSBwbGFjZW1lbnQsIGkuZTogJ2F1dG8gYm90dG9tLWxlZnQnICBJZlxuICAgICAgICogdGhlIHByaW1hcnkgYW5kIHNlY29uZGFyeSBwbGFjZW1lbnQgdmFsdWVzIGRvIG5vdCBtYXRjaCAndG9wLFxuICAgICAgICogYm90dG9tLCBsZWZ0LCByaWdodCcgdGhlbiAndG9wJyB3aWxsIGJlIHRoZSBwcmltYXJ5IHBsYWNlbWVudCBhbmRcbiAgICAgICAqICdjZW50ZXInIHdpbGwgYmUgdGhlIHNlY29uZGFyeSBwbGFjZW1lbnQuICBJZiAnYXV0bycgaXMgcGFzc2VkLCB0cnVlXG4gICAgICAgKiB3aWxsIGJlIHJldHVybmVkIGFzIHRoZSAzcmQgdmFsdWUgb2YgdGhlIGFycmF5LlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwbGFjZW1lbnQgLSBUaGUgcGxhY2VtZW50IHN0cmluZyB0byBwYXJzZS5cbiAgICAgICAqXG4gICAgICAgKiBAcmV0dXJucyB7YXJyYXl9IEFuIGFycmF5IHdpdGggdGhlIGZvbGxvd2luZyB2YWx1ZXNcbiAgICAgICAqIDx1bD5cbiAgICAgICAqICAgPGxpPioqWzBdKio6IFRoZSBwcmltYXJ5IHBsYWNlbWVudC48L2xpPlxuICAgICAgICogICA8bGk+KipbMV0qKjogVGhlIHNlY29uZGFyeSBwbGFjZW1lbnQuPC9saT5cbiAgICAgICAqICAgPGxpPioqWzJdKio6IElmIGF1dG8gaXMgcGFzc2VkOiB0cnVlLCBlbHNlIHVuZGVmaW5lZC48L2xpPlxuICAgICAgICogPC91bD5cbiAgICAgICAqL1xuICAgICAgcGFyc2VQbGFjZW1lbnQ6IGZ1bmN0aW9uKHBsYWNlbWVudCkge1xuICAgICAgICB2YXIgYXV0b1BsYWNlID0gUExBQ0VNRU5UX1JFR0VYLmF1dG8udGVzdChwbGFjZW1lbnQpO1xuICAgICAgICBpZiAoYXV0b1BsYWNlKSB7XG4gICAgICAgICAgcGxhY2VtZW50ID0gcGxhY2VtZW50LnJlcGxhY2UoUExBQ0VNRU5UX1JFR0VYLmF1dG8sICcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBsYWNlbWVudCA9IHBsYWNlbWVudC5zcGxpdCgnLScpO1xuXG4gICAgICAgIHBsYWNlbWVudFswXSA9IHBsYWNlbWVudFswXSB8fCAndG9wJztcbiAgICAgICAgaWYgKCFQTEFDRU1FTlRfUkVHRVgucHJpbWFyeS50ZXN0KHBsYWNlbWVudFswXSkpIHtcbiAgICAgICAgICBwbGFjZW1lbnRbMF0gPSAndG9wJztcbiAgICAgICAgfVxuXG4gICAgICAgIHBsYWNlbWVudFsxXSA9IHBsYWNlbWVudFsxXSB8fCAnY2VudGVyJztcbiAgICAgICAgaWYgKCFQTEFDRU1FTlRfUkVHRVguc2Vjb25kYXJ5LnRlc3QocGxhY2VtZW50WzFdKSkge1xuICAgICAgICAgIHBsYWNlbWVudFsxXSA9ICdjZW50ZXInO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGF1dG9QbGFjZSkge1xuICAgICAgICAgIHBsYWNlbWVudFsyXSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGxhY2VtZW50WzJdID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGxhY2VtZW50O1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBQcm92aWRlcyBjb29yZGluYXRlcyBmb3IgYW4gZWxlbWVudCB0byBiZSBwb3NpdGlvbmVkIHJlbGF0aXZlIHRvXG4gICAgICAgKiBhbm90aGVyIGVsZW1lbnQuICBQYXNzaW5nICdhdXRvJyBhcyBwYXJ0IG9mIHRoZSBwbGFjZW1lbnQgcGFyYW1ldGVyXG4gICAgICAgKiB3aWxsIGVuYWJsZSBzbWFydCBwbGFjZW1lbnQgLSB3aGVyZSB0aGUgZWxlbWVudCBmaXRzLiBpLmU6XG4gICAgICAgKiAnYXV0byBsZWZ0LXRvcCcgd2lsbCBjaGVjayB0byBzZWUgaWYgdGhlcmUgaXMgZW5vdWdoIHNwYWNlIHRvIHRoZSBsZWZ0XG4gICAgICAgKiBvZiB0aGUgaG9zdEVsZW0gdG8gZml0IHRoZSB0YXJnZXRFbGVtLCBpZiBub3QgcGxhY2UgcmlnaHQgKHNhbWUgZm9yIHNlY29uZGFyeVxuICAgICAgICogdG9wIHBsYWNlbWVudCkuICBBdmFpbGFibGUgc3BhY2UgaXMgY2FsY3VsYXRlZCB1c2luZyB0aGUgdmlld3BvcnRPZmZzZXRcbiAgICAgICAqIGZ1bmN0aW9uLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7ZWxlbWVudH0gaG9zdEVsZW0gLSBUaGUgZWxlbWVudCB0byBwb3NpdGlvbiBhZ2FpbnN0LlxuICAgICAgICogQHBhcmFtIHtlbGVtZW50fSB0YXJnZXRFbGVtIC0gVGhlIGVsZW1lbnQgdG8gcG9zaXRpb24uXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZz19IFtwbGFjZW1lbnQ9dG9wXSAtIFRoZSBwbGFjZW1lbnQgZm9yIHRoZSB0YXJnZXRFbGVtLFxuICAgICAgICogICBkZWZhdWx0IGlzICd0b3AnLiAnY2VudGVyJyBpcyBhc3N1bWVkIGFzIHNlY29uZGFyeSBwbGFjZW1lbnQgZm9yXG4gICAgICAgKiAgICd0b3AnLCAnbGVmdCcsICdyaWdodCcsIGFuZCAnYm90dG9tJyBwbGFjZW1lbnRzLiAgQXZhaWxhYmxlIHBsYWNlbWVudHMgYXJlOlxuICAgICAgICogICA8dWw+XG4gICAgICAgKiAgICAgPGxpPnRvcDwvbGk+XG4gICAgICAgKiAgICAgPGxpPnRvcC1yaWdodDwvbGk+XG4gICAgICAgKiAgICAgPGxpPnRvcC1sZWZ0PC9saT5cbiAgICAgICAqICAgICA8bGk+Ym90dG9tPC9saT5cbiAgICAgICAqICAgICA8bGk+Ym90dG9tLWxlZnQ8L2xpPlxuICAgICAgICogICAgIDxsaT5ib3R0b20tcmlnaHQ8L2xpPlxuICAgICAgICogICAgIDxsaT5sZWZ0PC9saT5cbiAgICAgICAqICAgICA8bGk+bGVmdC10b3A8L2xpPlxuICAgICAgICogICAgIDxsaT5sZWZ0LWJvdHRvbTwvbGk+XG4gICAgICAgKiAgICAgPGxpPnJpZ2h0PC9saT5cbiAgICAgICAqICAgICA8bGk+cmlnaHQtdG9wPC9saT5cbiAgICAgICAqICAgICA8bGk+cmlnaHQtYm90dG9tPC9saT5cbiAgICAgICAqICAgPC91bD5cbiAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IFthcHBlbmRUb0JvZHk9ZmFsc2VdIC0gU2hvdWxkIHRoZSB0b3AgYW5kIGxlZnQgdmFsdWVzIHJldHVybmVkXG4gICAgICAgKiAgIGJlIGNhbGN1bGF0ZWQgZnJvbSB0aGUgYm9keSBlbGVtZW50LCBkZWZhdWx0IGlzIGZhbHNlLlxuICAgICAgICpcbiAgICAgICAqIEByZXR1cm5zIHtvYmplY3R9IEFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICAgICAqICAgPHVsPlxuICAgICAgICogICAgIDxsaT4qKnRvcCoqOiBWYWx1ZSBmb3IgdGFyZ2V0RWxlbSB0b3AuPC9saT5cbiAgICAgICAqICAgICA8bGk+KipsZWZ0Kio6IFZhbHVlIGZvciB0YXJnZXRFbGVtIGxlZnQuPC9saT5cbiAgICAgICAqICAgICA8bGk+KipwbGFjZW1lbnQqKjogVGhlIHJlc29sdmVkIHBsYWNlbWVudC48L2xpPlxuICAgICAgICogICA8L3VsPlxuICAgICAgICovXG4gICAgICBwb3NpdGlvbkVsZW1lbnRzOiBmdW5jdGlvbihob3N0RWxlbSwgdGFyZ2V0RWxlbSwgcGxhY2VtZW50LCBhcHBlbmRUb0JvZHkpIHtcbiAgICAgICAgaG9zdEVsZW0gPSB0aGlzLmdldFJhd05vZGUoaG9zdEVsZW0pO1xuICAgICAgICB0YXJnZXRFbGVtID0gdGhpcy5nZXRSYXdOb2RlKHRhcmdldEVsZW0pO1xuXG4gICAgICAgIC8vIG5lZWQgdG8gcmVhZCBmcm9tIHByb3AgdG8gc3VwcG9ydCB0ZXN0cy5cbiAgICAgICAgdmFyIHRhcmdldFdpZHRoID0gYW5ndWxhci5pc0RlZmluZWQodGFyZ2V0RWxlbS5vZmZzZXRXaWR0aCkgPyB0YXJnZXRFbGVtLm9mZnNldFdpZHRoIDogdGFyZ2V0RWxlbS5wcm9wKCdvZmZzZXRXaWR0aCcpO1xuICAgICAgICB2YXIgdGFyZ2V0SGVpZ2h0ID0gYW5ndWxhci5pc0RlZmluZWQodGFyZ2V0RWxlbS5vZmZzZXRIZWlnaHQpID8gdGFyZ2V0RWxlbS5vZmZzZXRIZWlnaHQgOiB0YXJnZXRFbGVtLnByb3AoJ29mZnNldEhlaWdodCcpO1xuXG4gICAgICAgIHBsYWNlbWVudCA9IHRoaXMucGFyc2VQbGFjZW1lbnQocGxhY2VtZW50KTtcblxuICAgICAgICB2YXIgaG9zdEVsZW1Qb3MgPSBhcHBlbmRUb0JvZHkgPyB0aGlzLm9mZnNldChob3N0RWxlbSkgOiB0aGlzLnBvc2l0aW9uKGhvc3RFbGVtKTtcbiAgICAgICAgdmFyIHRhcmdldEVsZW1Qb3MgPSB7dG9wOiAwLCBsZWZ0OiAwLCBwbGFjZW1lbnQ6ICcnfTtcblxuICAgICAgICBpZiAocGxhY2VtZW50WzJdKSB7XG4gICAgICAgICAgdmFyIHZpZXdwb3J0T2Zmc2V0ID0gdGhpcy52aWV3cG9ydE9mZnNldChob3N0RWxlbSwgYXBwZW5kVG9Cb2R5KTtcblxuICAgICAgICAgIHZhciB0YXJnZXRFbGVtU3R5bGUgPSAkd2luZG93LmdldENvbXB1dGVkU3R5bGUodGFyZ2V0RWxlbSk7XG4gICAgICAgICAgdmFyIGFkanVzdGVkU2l6ZSA9IHtcbiAgICAgICAgICAgIHdpZHRoOiB0YXJnZXRXaWR0aCArIE1hdGgucm91bmQoTWF0aC5hYnModGhpcy5wYXJzZVN0eWxlKHRhcmdldEVsZW1TdHlsZS5tYXJnaW5MZWZ0KSArIHRoaXMucGFyc2VTdHlsZSh0YXJnZXRFbGVtU3R5bGUubWFyZ2luUmlnaHQpKSksXG4gICAgICAgICAgICBoZWlnaHQ6IHRhcmdldEhlaWdodCArIE1hdGgucm91bmQoTWF0aC5hYnModGhpcy5wYXJzZVN0eWxlKHRhcmdldEVsZW1TdHlsZS5tYXJnaW5Ub3ApICsgdGhpcy5wYXJzZVN0eWxlKHRhcmdldEVsZW1TdHlsZS5tYXJnaW5Cb3R0b20pKSlcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgcGxhY2VtZW50WzBdID0gcGxhY2VtZW50WzBdID09PSAndG9wJyAmJiBhZGp1c3RlZFNpemUuaGVpZ2h0ID4gdmlld3BvcnRPZmZzZXQudG9wICYmIGFkanVzdGVkU2l6ZS5oZWlnaHQgPD0gdmlld3BvcnRPZmZzZXQuYm90dG9tID8gJ2JvdHRvbScgOlxuICAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlbWVudFswXSA9PT0gJ2JvdHRvbScgJiYgYWRqdXN0ZWRTaXplLmhlaWdodCA+IHZpZXdwb3J0T2Zmc2V0LmJvdHRvbSAmJiBhZGp1c3RlZFNpemUuaGVpZ2h0IDw9IHZpZXdwb3J0T2Zmc2V0LnRvcCA/ICd0b3AnIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZW1lbnRbMF0gPT09ICdsZWZ0JyAmJiBhZGp1c3RlZFNpemUud2lkdGggPiB2aWV3cG9ydE9mZnNldC5sZWZ0ICYmIGFkanVzdGVkU2l6ZS53aWR0aCA8PSB2aWV3cG9ydE9mZnNldC5yaWdodCA/ICdyaWdodCcgOlxuICAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlbWVudFswXSA9PT0gJ3JpZ2h0JyAmJiBhZGp1c3RlZFNpemUud2lkdGggPiB2aWV3cG9ydE9mZnNldC5yaWdodCAmJiBhZGp1c3RlZFNpemUud2lkdGggPD0gdmlld3BvcnRPZmZzZXQubGVmdCA/ICdsZWZ0JyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2VtZW50WzBdO1xuXG4gICAgICAgICAgcGxhY2VtZW50WzFdID0gcGxhY2VtZW50WzFdID09PSAndG9wJyAmJiBhZGp1c3RlZFNpemUuaGVpZ2h0IC0gaG9zdEVsZW1Qb3MuaGVpZ2h0ID4gdmlld3BvcnRPZmZzZXQuYm90dG9tICYmIGFkanVzdGVkU2l6ZS5oZWlnaHQgLSBob3N0RWxlbVBvcy5oZWlnaHQgPD0gdmlld3BvcnRPZmZzZXQudG9wID8gJ2JvdHRvbScgOlxuICAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlbWVudFsxXSA9PT0gJ2JvdHRvbScgJiYgYWRqdXN0ZWRTaXplLmhlaWdodCAtIGhvc3RFbGVtUG9zLmhlaWdodCA+IHZpZXdwb3J0T2Zmc2V0LnRvcCAmJiBhZGp1c3RlZFNpemUuaGVpZ2h0IC0gaG9zdEVsZW1Qb3MuaGVpZ2h0IDw9IHZpZXdwb3J0T2Zmc2V0LmJvdHRvbSA/ICd0b3AnIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZW1lbnRbMV0gPT09ICdsZWZ0JyAmJiBhZGp1c3RlZFNpemUud2lkdGggLSBob3N0RWxlbVBvcy53aWR0aCA+IHZpZXdwb3J0T2Zmc2V0LnJpZ2h0ICYmIGFkanVzdGVkU2l6ZS53aWR0aCAtIGhvc3RFbGVtUG9zLndpZHRoIDw9IHZpZXdwb3J0T2Zmc2V0LmxlZnQgPyAncmlnaHQnIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZW1lbnRbMV0gPT09ICdyaWdodCcgJiYgYWRqdXN0ZWRTaXplLndpZHRoIC0gaG9zdEVsZW1Qb3Mud2lkdGggPiB2aWV3cG9ydE9mZnNldC5sZWZ0ICYmIGFkanVzdGVkU2l6ZS53aWR0aCAtIGhvc3RFbGVtUG9zLndpZHRoIDw9IHZpZXdwb3J0T2Zmc2V0LnJpZ2h0ID8gJ2xlZnQnIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZW1lbnRbMV07XG5cbiAgICAgICAgICBpZiAocGxhY2VtZW50WzFdID09PSAnY2VudGVyJykge1xuICAgICAgICAgICAgaWYgKFBMQUNFTUVOVF9SRUdFWC52ZXJ0aWNhbC50ZXN0KHBsYWNlbWVudFswXSkpIHtcbiAgICAgICAgICAgICAgdmFyIHhPdmVyZmxvdyA9IGhvc3RFbGVtUG9zLndpZHRoIC8gMiAtIHRhcmdldFdpZHRoIC8gMjtcbiAgICAgICAgICAgICAgaWYgKHZpZXdwb3J0T2Zmc2V0LmxlZnQgKyB4T3ZlcmZsb3cgPCAwICYmIGFkanVzdGVkU2l6ZS53aWR0aCAtIGhvc3RFbGVtUG9zLndpZHRoIDw9IHZpZXdwb3J0T2Zmc2V0LnJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgcGxhY2VtZW50WzFdID0gJ2xlZnQnO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHZpZXdwb3J0T2Zmc2V0LnJpZ2h0ICsgeE92ZXJmbG93IDwgMCAmJiBhZGp1c3RlZFNpemUud2lkdGggLSBob3N0RWxlbVBvcy53aWR0aCA8PSB2aWV3cG9ydE9mZnNldC5sZWZ0KSB7XG4gICAgICAgICAgICAgICAgcGxhY2VtZW50WzFdID0gJ3JpZ2h0JztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIHlPdmVyZmxvdyA9IGhvc3RFbGVtUG9zLmhlaWdodCAvIDIgLSBhZGp1c3RlZFNpemUuaGVpZ2h0IC8gMjtcbiAgICAgICAgICAgICAgaWYgKHZpZXdwb3J0T2Zmc2V0LnRvcCArIHlPdmVyZmxvdyA8IDAgJiYgYWRqdXN0ZWRTaXplLmhlaWdodCAtIGhvc3RFbGVtUG9zLmhlaWdodCA8PSB2aWV3cG9ydE9mZnNldC5ib3R0b20pIHtcbiAgICAgICAgICAgICAgICBwbGFjZW1lbnRbMV0gPSAndG9wJztcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICh2aWV3cG9ydE9mZnNldC5ib3R0b20gKyB5T3ZlcmZsb3cgPCAwICYmIGFkanVzdGVkU2l6ZS5oZWlnaHQgLSBob3N0RWxlbVBvcy5oZWlnaHQgPD0gdmlld3BvcnRPZmZzZXQudG9wKSB7XG4gICAgICAgICAgICAgICAgcGxhY2VtZW50WzFdID0gJ2JvdHRvbSc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2ggKHBsYWNlbWVudFswXSkge1xuICAgICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgICB0YXJnZXRFbGVtUG9zLnRvcCA9IGhvc3RFbGVtUG9zLnRvcCAtIHRhcmdldEhlaWdodDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgICB0YXJnZXRFbGVtUG9zLnRvcCA9IGhvc3RFbGVtUG9zLnRvcCArIGhvc3RFbGVtUG9zLmhlaWdodDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgICAgdGFyZ2V0RWxlbVBvcy5sZWZ0ID0gaG9zdEVsZW1Qb3MubGVmdCAtIHRhcmdldFdpZHRoO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgICAgdGFyZ2V0RWxlbVBvcy5sZWZ0ID0gaG9zdEVsZW1Qb3MubGVmdCArIGhvc3RFbGVtUG9zLndpZHRoO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2ggKHBsYWNlbWVudFsxXSkge1xuICAgICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgICB0YXJnZXRFbGVtUG9zLnRvcCA9IGhvc3RFbGVtUG9zLnRvcDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgICB0YXJnZXRFbGVtUG9zLnRvcCA9IGhvc3RFbGVtUG9zLnRvcCArIGhvc3RFbGVtUG9zLmhlaWdodCAtIHRhcmdldEhlaWdodDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgICAgdGFyZ2V0RWxlbVBvcy5sZWZ0ID0gaG9zdEVsZW1Qb3MubGVmdDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICAgIHRhcmdldEVsZW1Qb3MubGVmdCA9IGhvc3RFbGVtUG9zLmxlZnQgKyBob3N0RWxlbVBvcy53aWR0aCAtIHRhcmdldFdpZHRoO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgICAgICAgIGlmIChQTEFDRU1FTlRfUkVHRVgudmVydGljYWwudGVzdChwbGFjZW1lbnRbMF0pKSB7XG4gICAgICAgICAgICAgIHRhcmdldEVsZW1Qb3MubGVmdCA9IGhvc3RFbGVtUG9zLmxlZnQgKyBob3N0RWxlbVBvcy53aWR0aCAvIDIgLSB0YXJnZXRXaWR0aCAvIDI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0YXJnZXRFbGVtUG9zLnRvcCA9IGhvc3RFbGVtUG9zLnRvcCArIGhvc3RFbGVtUG9zLmhlaWdodCAvIDIgLSB0YXJnZXRIZWlnaHQgLyAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICB0YXJnZXRFbGVtUG9zLnRvcCA9IE1hdGgucm91bmQodGFyZ2V0RWxlbVBvcy50b3ApO1xuICAgICAgICB0YXJnZXRFbGVtUG9zLmxlZnQgPSBNYXRoLnJvdW5kKHRhcmdldEVsZW1Qb3MubGVmdCk7XG4gICAgICAgIHRhcmdldEVsZW1Qb3MucGxhY2VtZW50ID0gcGxhY2VtZW50WzFdID09PSAnY2VudGVyJyA/IHBsYWNlbWVudFswXSA6IHBsYWNlbWVudFswXSArICctJyArIHBsYWNlbWVudFsxXTtcblxuICAgICAgICByZXR1cm4gdGFyZ2V0RWxlbVBvcztcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogUHJvdmlkZXMgYSB3YXkgdG8gYWRqdXN0IHRoZSB0b3AgcG9zaXRpb25pbmcgYWZ0ZXIgZmlyc3RcbiAgICAgICAqIHJlbmRlciB0byBjb3JyZWN0bHkgYWxpZ24gZWxlbWVudCB0byB0b3AgYWZ0ZXIgY29udGVudFxuICAgICAgICogcmVuZGVyaW5nIGNhdXNlcyByZXNpemVkIGVsZW1lbnQgaGVpZ2h0XG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHthcnJheX0gcGxhY2VtZW50Q2xhc3NlcyAtIFRoZSBhcnJheSBvZiBzdHJpbmdzIG9mIGNsYXNzZXNcbiAgICAgICAqIGVsZW1lbnQgc2hvdWxkIGhhdmUuXG4gICAgICAgKiBAcGFyYW0ge29iamVjdH0gY29udGFpbmVyUG9zaXRpb24gLSBUaGUgb2JqZWN0IHdpdGggY29udGFpbmVyXG4gICAgICAgKiBwb3NpdGlvbiBpbmZvcm1hdGlvblxuICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGluaXRpYWxIZWlnaHQgLSBUaGUgaW5pdGlhbCBoZWlnaHQgZm9yIHRoZSBlbGVtLlxuICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGN1cnJlbnRIZWlnaHQgLSBUaGUgY3VycmVudCBoZWlnaHQgZm9yIHRoZSBlbGVtLlxuICAgICAgICovXG4gICAgICBhZGp1c3RUb3A6IGZ1bmN0aW9uKHBsYWNlbWVudENsYXNzZXMsIGNvbnRhaW5lclBvc2l0aW9uLCBpbml0aWFsSGVpZ2h0LCBjdXJyZW50SGVpZ2h0KSB7XG4gICAgICAgIGlmIChwbGFjZW1lbnRDbGFzc2VzLmluZGV4T2YoJ3RvcCcpICE9PSAtMSAmJiBpbml0aWFsSGVpZ2h0ICE9PSBjdXJyZW50SGVpZ2h0KSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRvcDogY29udGFpbmVyUG9zaXRpb24udG9wIC0gY3VycmVudEhlaWdodCArICdweCdcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFByb3ZpZGVzIGEgd2F5IGZvciBwb3NpdGlvbmluZyB0b29sdGlwICYgZHJvcGRvd25cbiAgICAgICAqIGFycm93cyB3aGVuIHVzaW5nIHBsYWNlbWVudCBvcHRpb25zIGJleW9uZCB0aGUgc3RhbmRhcmRcbiAgICAgICAqIGxlZnQsIHJpZ2h0LCB0b3AsIG9yIGJvdHRvbS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge2VsZW1lbnR9IGVsZW0gLSBUaGUgdG9vbHRpcC9kcm9wZG93biBlbGVtZW50LlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHBsYWNlbWVudCAtIFRoZSBwbGFjZW1lbnQgZm9yIHRoZSBlbGVtLlxuICAgICAgICovXG4gICAgICBwb3NpdGlvbkFycm93OiBmdW5jdGlvbihlbGVtLCBwbGFjZW1lbnQpIHtcbiAgICAgICAgZWxlbSA9IHRoaXMuZ2V0UmF3Tm9kZShlbGVtKTtcblxuICAgICAgICB2YXIgaW5uZXJFbGVtID0gZWxlbS5xdWVyeVNlbGVjdG9yKCcudG9vbHRpcC1pbm5lciwgLnBvcG92ZXItaW5uZXInKTtcbiAgICAgICAgaWYgKCFpbm5lckVsZW0pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaXNUb29sdGlwID0gYW5ndWxhci5lbGVtZW50KGlubmVyRWxlbSkuaGFzQ2xhc3MoJ3Rvb2x0aXAtaW5uZXInKTtcblxuICAgICAgICB2YXIgYXJyb3dFbGVtID0gaXNUb29sdGlwID8gZWxlbS5xdWVyeVNlbGVjdG9yKCcudG9vbHRpcC1hcnJvdycpIDogZWxlbS5xdWVyeVNlbGVjdG9yKCcuYXJyb3cnKTtcbiAgICAgICAgaWYgKCFhcnJvd0VsZW0pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYXJyb3dDc3MgPSB7XG4gICAgICAgICAgdG9wOiAnJyxcbiAgICAgICAgICBib3R0b206ICcnLFxuICAgICAgICAgIGxlZnQ6ICcnLFxuICAgICAgICAgIHJpZ2h0OiAnJ1xuICAgICAgICB9O1xuXG4gICAgICAgIHBsYWNlbWVudCA9IHRoaXMucGFyc2VQbGFjZW1lbnQocGxhY2VtZW50KTtcbiAgICAgICAgaWYgKHBsYWNlbWVudFsxXSA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICAvLyBubyBhZGp1c3RtZW50IG5lY2Vzc2FyeSAtIGp1c3QgcmVzZXQgc3R5bGVzXG4gICAgICAgICAgYW5ndWxhci5lbGVtZW50KGFycm93RWxlbSkuY3NzKGFycm93Q3NzKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYm9yZGVyUHJvcCA9ICdib3JkZXItJyArIHBsYWNlbWVudFswXSArICctd2lkdGgnO1xuICAgICAgICB2YXIgYm9yZGVyV2lkdGggPSAkd2luZG93LmdldENvbXB1dGVkU3R5bGUoYXJyb3dFbGVtKVtib3JkZXJQcm9wXTtcblxuICAgICAgICB2YXIgYm9yZGVyUmFkaXVzUHJvcCA9ICdib3JkZXItJztcbiAgICAgICAgaWYgKFBMQUNFTUVOVF9SRUdFWC52ZXJ0aWNhbC50ZXN0KHBsYWNlbWVudFswXSkpIHtcbiAgICAgICAgICBib3JkZXJSYWRpdXNQcm9wICs9IHBsYWNlbWVudFswXSArICctJyArIHBsYWNlbWVudFsxXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBib3JkZXJSYWRpdXNQcm9wICs9IHBsYWNlbWVudFsxXSArICctJyArIHBsYWNlbWVudFswXTtcbiAgICAgICAgfVxuICAgICAgICBib3JkZXJSYWRpdXNQcm9wICs9ICctcmFkaXVzJztcbiAgICAgICAgdmFyIGJvcmRlclJhZGl1cyA9ICR3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShpc1Rvb2x0aXAgPyBpbm5lckVsZW0gOiBlbGVtKVtib3JkZXJSYWRpdXNQcm9wXTtcblxuICAgICAgICBzd2l0Y2ggKHBsYWNlbWVudFswXSkge1xuICAgICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgICBhcnJvd0Nzcy5ib3R0b20gPSBpc1Rvb2x0aXAgPyAnMCcgOiAnLScgKyBib3JkZXJXaWR0aDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgICBhcnJvd0Nzcy50b3AgPSBpc1Rvb2x0aXAgPyAnMCcgOiAnLScgKyBib3JkZXJXaWR0aDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgICAgYXJyb3dDc3MucmlnaHQgPSBpc1Rvb2x0aXAgPyAnMCcgOiAnLScgKyBib3JkZXJXaWR0aDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICAgIGFycm93Q3NzLmxlZnQgPSBpc1Rvb2x0aXAgPyAnMCcgOiAnLScgKyBib3JkZXJXaWR0aDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgYXJyb3dDc3NbcGxhY2VtZW50WzFdXSA9IGJvcmRlclJhZGl1cztcblxuICAgICAgICBhbmd1bGFyLmVsZW1lbnQoYXJyb3dFbGVtKS5jc3MoYXJyb3dDc3MpO1xuICAgICAgfVxuICAgIH07XG4gIH1dKTtcblxuYW5ndWxhci5tb2R1bGUoJ3VpLmJvb3RzdHJhcC5kYXRlcGlja2VyUG9wdXAnLCBbJ3VpLmJvb3RzdHJhcC5kYXRlcGlja2VyJywgJ3VpLmJvb3RzdHJhcC5wb3NpdGlvbiddKVxuXG4udmFsdWUoJyRkYXRlcGlja2VyUG9wdXBMaXRlcmFsV2FybmluZycsIHRydWUpXG5cbi5jb25zdGFudCgndWliRGF0ZXBpY2tlclBvcHVwQ29uZmlnJywge1xuICBhbHRJbnB1dEZvcm1hdHM6IFtdLFxuICBhcHBlbmRUb0JvZHk6IGZhbHNlLFxuICBjbGVhclRleHQ6ICdDbGVhcicsXG4gIGNsb3NlT25EYXRlU2VsZWN0aW9uOiB0cnVlLFxuICBjbG9zZVRleHQ6ICdEb25lJyxcbiAgY3VycmVudFRleHQ6ICdUb2RheScsXG4gIGRhdGVwaWNrZXJQb3B1cDogJ3l5eXktTU0tZGQnLFxuICBkYXRlcGlja2VyUG9wdXBUZW1wbGF0ZVVybDogJ3VpYi90ZW1wbGF0ZS9kYXRlcGlja2VyUG9wdXAvcG9wdXAuaHRtbCcsXG4gIGRhdGVwaWNrZXJUZW1wbGF0ZVVybDogJ3VpYi90ZW1wbGF0ZS9kYXRlcGlja2VyL2RhdGVwaWNrZXIuaHRtbCcsXG4gIGh0bWw1VHlwZXM6IHtcbiAgICBkYXRlOiAneXl5eS1NTS1kZCcsXG4gICAgJ2RhdGV0aW1lLWxvY2FsJzogJ3l5eXktTU0tZGRUSEg6bW06c3Muc3NzJyxcbiAgICAnbW9udGgnOiAneXl5eS1NTSdcbiAgfSxcbiAgb25PcGVuRm9jdXM6IHRydWUsXG4gIHNob3dCdXR0b25CYXI6IHRydWUsXG4gIHBsYWNlbWVudDogJ2F1dG8gYm90dG9tLWxlZnQnXG59KVxuXG4uY29udHJvbGxlcignVWliRGF0ZXBpY2tlclBvcHVwQ29udHJvbGxlcicsIFsnJHNjb3BlJywgJyRlbGVtZW50JywgJyRhdHRycycsICckY29tcGlsZScsICckbG9nJywgJyRwYXJzZScsICckd2luZG93JywgJyRkb2N1bWVudCcsICckcm9vdFNjb3BlJywgJyR1aWJQb3NpdGlvbicsICdkYXRlRmlsdGVyJywgJ3VpYkRhdGVQYXJzZXInLCAndWliRGF0ZXBpY2tlclBvcHVwQ29uZmlnJywgJyR0aW1lb3V0JywgJ3VpYkRhdGVwaWNrZXJDb25maWcnLCAnJGRhdGVwaWNrZXJQb3B1cExpdGVyYWxXYXJuaW5nJyxcbmZ1bmN0aW9uKCRzY29wZSwgJGVsZW1lbnQsICRhdHRycywgJGNvbXBpbGUsICRsb2csICRwYXJzZSwgJHdpbmRvdywgJGRvY3VtZW50LCAkcm9vdFNjb3BlLCAkcG9zaXRpb24sIGRhdGVGaWx0ZXIsIGRhdGVQYXJzZXIsIGRhdGVwaWNrZXJQb3B1cENvbmZpZywgJHRpbWVvdXQsIGRhdGVwaWNrZXJDb25maWcsICRkYXRlcGlja2VyUG9wdXBMaXRlcmFsV2FybmluZykge1xuICB2YXIgY2FjaGUgPSB7fSxcbiAgICBpc0h0bWw1RGF0ZUlucHV0ID0gZmFsc2U7XG4gIHZhciBkYXRlRm9ybWF0LCBjbG9zZU9uRGF0ZVNlbGVjdGlvbiwgYXBwZW5kVG9Cb2R5LCBvbk9wZW5Gb2N1cyxcbiAgICBkYXRlcGlja2VyUG9wdXBUZW1wbGF0ZVVybCwgZGF0ZXBpY2tlclRlbXBsYXRlVXJsLCBwb3B1cEVsLCBkYXRlcGlja2VyRWwsIHNjcm9sbFBhcmVudEVsLFxuICAgIG5nTW9kZWwsIG5nTW9kZWxPcHRpb25zLCAkcG9wdXAsIGFsdElucHV0Rm9ybWF0cywgd2F0Y2hMaXN0ZW5lcnMgPSBbXTtcblxuICB0aGlzLmluaXQgPSBmdW5jdGlvbihfbmdNb2RlbF8pIHtcbiAgICBuZ01vZGVsID0gX25nTW9kZWxfO1xuICAgIG5nTW9kZWxPcHRpb25zID0gZXh0cmFjdE9wdGlvbnMobmdNb2RlbCk7XG4gICAgY2xvc2VPbkRhdGVTZWxlY3Rpb24gPSBhbmd1bGFyLmlzRGVmaW5lZCgkYXR0cnMuY2xvc2VPbkRhdGVTZWxlY3Rpb24pID9cbiAgICAgICRzY29wZS4kcGFyZW50LiRldmFsKCRhdHRycy5jbG9zZU9uRGF0ZVNlbGVjdGlvbikgOlxuICAgICAgZGF0ZXBpY2tlclBvcHVwQ29uZmlnLmNsb3NlT25EYXRlU2VsZWN0aW9uO1xuICAgIGFwcGVuZFRvQm9keSA9IGFuZ3VsYXIuaXNEZWZpbmVkKCRhdHRycy5kYXRlcGlja2VyQXBwZW5kVG9Cb2R5KSA/XG4gICAgICAkc2NvcGUuJHBhcmVudC4kZXZhbCgkYXR0cnMuZGF0ZXBpY2tlckFwcGVuZFRvQm9keSkgOlxuICAgICAgZGF0ZXBpY2tlclBvcHVwQ29uZmlnLmFwcGVuZFRvQm9keTtcbiAgICBvbk9wZW5Gb2N1cyA9IGFuZ3VsYXIuaXNEZWZpbmVkKCRhdHRycy5vbk9wZW5Gb2N1cykgP1xuICAgICAgJHNjb3BlLiRwYXJlbnQuJGV2YWwoJGF0dHJzLm9uT3BlbkZvY3VzKSA6IGRhdGVwaWNrZXJQb3B1cENvbmZpZy5vbk9wZW5Gb2N1cztcbiAgICBkYXRlcGlja2VyUG9wdXBUZW1wbGF0ZVVybCA9IGFuZ3VsYXIuaXNEZWZpbmVkKCRhdHRycy5kYXRlcGlja2VyUG9wdXBUZW1wbGF0ZVVybCkgP1xuICAgICAgJGF0dHJzLmRhdGVwaWNrZXJQb3B1cFRlbXBsYXRlVXJsIDpcbiAgICAgIGRhdGVwaWNrZXJQb3B1cENvbmZpZy5kYXRlcGlja2VyUG9wdXBUZW1wbGF0ZVVybDtcbiAgICBkYXRlcGlja2VyVGVtcGxhdGVVcmwgPSBhbmd1bGFyLmlzRGVmaW5lZCgkYXR0cnMuZGF0ZXBpY2tlclRlbXBsYXRlVXJsKSA/XG4gICAgICAkYXR0cnMuZGF0ZXBpY2tlclRlbXBsYXRlVXJsIDogZGF0ZXBpY2tlclBvcHVwQ29uZmlnLmRhdGVwaWNrZXJUZW1wbGF0ZVVybDtcbiAgICBhbHRJbnB1dEZvcm1hdHMgPSBhbmd1bGFyLmlzRGVmaW5lZCgkYXR0cnMuYWx0SW5wdXRGb3JtYXRzKSA/XG4gICAgICAkc2NvcGUuJHBhcmVudC4kZXZhbCgkYXR0cnMuYWx0SW5wdXRGb3JtYXRzKSA6XG4gICAgICBkYXRlcGlja2VyUG9wdXBDb25maWcuYWx0SW5wdXRGb3JtYXRzO1xuXG4gICAgJHNjb3BlLnNob3dCdXR0b25CYXIgPSBhbmd1bGFyLmlzRGVmaW5lZCgkYXR0cnMuc2hvd0J1dHRvbkJhcikgP1xuICAgICAgJHNjb3BlLiRwYXJlbnQuJGV2YWwoJGF0dHJzLnNob3dCdXR0b25CYXIpIDpcbiAgICAgIGRhdGVwaWNrZXJQb3B1cENvbmZpZy5zaG93QnV0dG9uQmFyO1xuXG4gICAgaWYgKGRhdGVwaWNrZXJQb3B1cENvbmZpZy5odG1sNVR5cGVzWyRhdHRycy50eXBlXSkge1xuICAgICAgZGF0ZUZvcm1hdCA9IGRhdGVwaWNrZXJQb3B1cENvbmZpZy5odG1sNVR5cGVzWyRhdHRycy50eXBlXTtcbiAgICAgIGlzSHRtbDVEYXRlSW5wdXQgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBkYXRlRm9ybWF0ID0gJGF0dHJzLnVpYkRhdGVwaWNrZXJQb3B1cCB8fCBkYXRlcGlja2VyUG9wdXBDb25maWcuZGF0ZXBpY2tlclBvcHVwO1xuICAgICAgJGF0dHJzLiRvYnNlcnZlKCd1aWJEYXRlcGlja2VyUG9wdXAnLCBmdW5jdGlvbih2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdmFyIG5ld0RhdGVGb3JtYXQgPSB2YWx1ZSB8fCBkYXRlcGlja2VyUG9wdXBDb25maWcuZGF0ZXBpY2tlclBvcHVwO1xuICAgICAgICAvLyBJbnZhbGlkYXRlIHRoZSAkbW9kZWxWYWx1ZSB0byBlbnN1cmUgdGhhdCBmb3JtYXR0ZXJzIHJlLXJ1blxuICAgICAgICAvLyBGSVhNRTogUmVmYWN0b3Igd2hlbiBQUiBpcyBtZXJnZWQ6IGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIuanMvcHVsbC8xMDc2NFxuICAgICAgICBpZiAobmV3RGF0ZUZvcm1hdCAhPT0gZGF0ZUZvcm1hdCkge1xuICAgICAgICAgIGRhdGVGb3JtYXQgPSBuZXdEYXRlRm9ybWF0O1xuICAgICAgICAgIG5nTW9kZWwuJG1vZGVsVmFsdWUgPSBudWxsO1xuXG4gICAgICAgICAgaWYgKCFkYXRlRm9ybWF0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VpYkRhdGVwaWNrZXJQb3B1cCBtdXN0IGhhdmUgYSBkYXRlIGZvcm1hdCBzcGVjaWZpZWQuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoIWRhdGVGb3JtYXQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndWliRGF0ZXBpY2tlclBvcHVwIG11c3QgaGF2ZSBhIGRhdGUgZm9ybWF0IHNwZWNpZmllZC4nKTtcbiAgICB9XG5cbiAgICBpZiAoaXNIdG1sNURhdGVJbnB1dCAmJiAkYXR0cnMudWliRGF0ZXBpY2tlclBvcHVwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hUTUw1IGRhdGUgaW5wdXQgdHlwZXMgZG8gbm90IHN1cHBvcnQgY3VzdG9tIGZvcm1hdHMuJyk7XG4gICAgfVxuXG4gICAgLy8gcG9wdXAgZWxlbWVudCB1c2VkIHRvIGRpc3BsYXkgY2FsZW5kYXJcbiAgICBwb3B1cEVsID0gYW5ndWxhci5lbGVtZW50KCc8ZGl2IHVpYi1kYXRlcGlja2VyLXBvcHVwLXdyYXA+PGRpdiB1aWItZGF0ZXBpY2tlcj48L2Rpdj48L2Rpdj4nKTtcblxuICAgIHBvcHVwRWwuYXR0cih7XG4gICAgICAnbmctbW9kZWwnOiAnZGF0ZScsXG4gICAgICAnbmctY2hhbmdlJzogJ2RhdGVTZWxlY3Rpb24oZGF0ZSknLFxuICAgICAgJ3RlbXBsYXRlLXVybCc6IGRhdGVwaWNrZXJQb3B1cFRlbXBsYXRlVXJsXG4gICAgfSk7XG5cbiAgICAvLyBkYXRlcGlja2VyIGVsZW1lbnRcbiAgICBkYXRlcGlja2VyRWwgPSBhbmd1bGFyLmVsZW1lbnQocG9wdXBFbC5jaGlsZHJlbigpWzBdKTtcbiAgICBkYXRlcGlja2VyRWwuYXR0cigndGVtcGxhdGUtdXJsJywgZGF0ZXBpY2tlclRlbXBsYXRlVXJsKTtcblxuICAgIGlmICghJHNjb3BlLmRhdGVwaWNrZXJPcHRpb25zKSB7XG4gICAgICAkc2NvcGUuZGF0ZXBpY2tlck9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICBpZiAoaXNIdG1sNURhdGVJbnB1dCkge1xuICAgICAgaWYgKCRhdHRycy50eXBlID09PSAnbW9udGgnKSB7XG4gICAgICAgICRzY29wZS5kYXRlcGlja2VyT3B0aW9ucy5kYXRlcGlja2VyTW9kZSA9ICdtb250aCc7XG4gICAgICAgICRzY29wZS5kYXRlcGlja2VyT3B0aW9ucy5taW5Nb2RlID0gJ21vbnRoJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBkYXRlcGlja2VyRWwuYXR0cignZGF0ZXBpY2tlci1vcHRpb25zJywgJ2RhdGVwaWNrZXJPcHRpb25zJyk7XG5cbiAgICBpZiAoIWlzSHRtbDVEYXRlSW5wdXQpIHtcbiAgICAgIC8vIEludGVybmFsIEFQSSB0byBtYWludGFpbiB0aGUgY29ycmVjdCBuZy1pbnZhbGlkLVtrZXldIGNsYXNzXG4gICAgICBuZ01vZGVsLiQkcGFyc2VyTmFtZSA9ICdkYXRlJztcbiAgICAgIG5nTW9kZWwuJHZhbGlkYXRvcnMuZGF0ZSA9IHZhbGlkYXRvcjtcbiAgICAgIG5nTW9kZWwuJHBhcnNlcnMudW5zaGlmdChwYXJzZURhdGUpO1xuICAgICAgbmdNb2RlbC4kZm9ybWF0dGVycy5wdXNoKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIGlmIChuZ01vZGVsLiRpc0VtcHR5KHZhbHVlKSkge1xuICAgICAgICAgICRzY29wZS5kYXRlID0gdmFsdWU7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFuZ3VsYXIuaXNOdW1iZXIodmFsdWUpKSB7XG4gICAgICAgICAgdmFsdWUgPSBuZXcgRGF0ZSh2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICAkc2NvcGUuZGF0ZSA9IGRhdGVQYXJzZXIuZnJvbVRpbWV6b25lKHZhbHVlLCBuZ01vZGVsT3B0aW9ucy5nZXRPcHRpb24oJ3RpbWV6b25lJykpO1xuXG4gICAgICAgIHJldHVybiBkYXRlUGFyc2VyLmZpbHRlcigkc2NvcGUuZGF0ZSwgZGF0ZUZvcm1hdCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmdNb2RlbC4kZm9ybWF0dGVycy5wdXNoKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICRzY29wZS5kYXRlID0gZGF0ZVBhcnNlci5mcm9tVGltZXpvbmUodmFsdWUsIG5nTW9kZWxPcHRpb25zLmdldE9wdGlvbigndGltZXpvbmUnKSk7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIERldGVjdCBjaGFuZ2VzIGluIHRoZSB2aWV3IGZyb20gdGhlIHRleHQgYm94XG4gICAgbmdNb2RlbC4kdmlld0NoYW5nZUxpc3RlbmVycy5wdXNoKGZ1bmN0aW9uKCkge1xuICAgICAgJHNjb3BlLmRhdGUgPSBwYXJzZURhdGVTdHJpbmcobmdNb2RlbC4kdmlld1ZhbHVlKTtcbiAgICB9KTtcblxuICAgICRlbGVtZW50Lm9uKCdrZXlkb3duJywgaW5wdXRLZXlkb3duQmluZCk7XG5cbiAgICAkcG9wdXAgPSAkY29tcGlsZShwb3B1cEVsKSgkc2NvcGUpO1xuICAgIC8vIFByZXZlbnQgalF1ZXJ5IGNhY2hlIG1lbW9yeSBsZWFrICh0ZW1wbGF0ZSBpcyBub3cgcmVkdW5kYW50IGFmdGVyIGxpbmtpbmcpXG4gICAgcG9wdXBFbC5yZW1vdmUoKTtcblxuICAgIGlmIChhcHBlbmRUb0JvZHkpIHtcbiAgICAgICRkb2N1bWVudC5maW5kKCdib2R5JykuYXBwZW5kKCRwb3B1cCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICRlbGVtZW50LmFmdGVyKCRwb3B1cCk7XG4gICAgfVxuXG4gICAgJHNjb3BlLiRvbignJGRlc3Ryb3knLCBmdW5jdGlvbigpIHtcbiAgICAgIGlmICgkc2NvcGUuaXNPcGVuID09PSB0cnVlKSB7XG4gICAgICAgIGlmICghJHJvb3RTY29wZS4kJHBoYXNlKSB7XG4gICAgICAgICAgJHNjb3BlLiRhcHBseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICRzY29wZS5pc09wZW4gPSBmYWxzZTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAkcG9wdXAucmVtb3ZlKCk7XG4gICAgICAkZWxlbWVudC5vZmYoJ2tleWRvd24nLCBpbnB1dEtleWRvd25CaW5kKTtcbiAgICAgICRkb2N1bWVudC5vZmYoJ2NsaWNrJywgZG9jdW1lbnRDbGlja0JpbmQpO1xuICAgICAgaWYgKHNjcm9sbFBhcmVudEVsKSB7XG4gICAgICAgIHNjcm9sbFBhcmVudEVsLm9mZignc2Nyb2xsJywgcG9zaXRpb25Qb3B1cCk7XG4gICAgICB9XG4gICAgICBhbmd1bGFyLmVsZW1lbnQoJHdpbmRvdykub2ZmKCdyZXNpemUnLCBwb3NpdGlvblBvcHVwKTtcblxuICAgICAgLy9DbGVhciBhbGwgd2F0Y2ggbGlzdGVuZXJzIG9uIGRlc3Ryb3lcbiAgICAgIHdoaWxlICh3YXRjaExpc3RlbmVycy5sZW5ndGgpIHtcbiAgICAgICAgd2F0Y2hMaXN0ZW5lcnMuc2hpZnQoKSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gICRzY29wZS5nZXRUZXh0ID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgcmV0dXJuICRzY29wZVtrZXkgKyAnVGV4dCddIHx8IGRhdGVwaWNrZXJQb3B1cENvbmZpZ1trZXkgKyAnVGV4dCddO1xuICB9O1xuXG4gICRzY29wZS5pc0Rpc2FibGVkID0gZnVuY3Rpb24oZGF0ZSkge1xuICAgIGlmIChkYXRlID09PSAndG9kYXknKSB7XG4gICAgICBkYXRlID0gZGF0ZVBhcnNlci5mcm9tVGltZXpvbmUobmV3IERhdGUoKSwgbmdNb2RlbE9wdGlvbnMuZ2V0T3B0aW9uKCd0aW1lem9uZScpKTtcbiAgICB9XG5cbiAgICB2YXIgZGF0ZXMgPSB7fTtcbiAgICBhbmd1bGFyLmZvckVhY2goWydtaW5EYXRlJywgJ21heERhdGUnXSwgZnVuY3Rpb24oa2V5KSB7XG4gICAgICBpZiAoISRzY29wZS5kYXRlcGlja2VyT3B0aW9uc1trZXldKSB7XG4gICAgICAgIGRhdGVzW2tleV0gPSBudWxsO1xuICAgICAgfSBlbHNlIGlmIChhbmd1bGFyLmlzRGF0ZSgkc2NvcGUuZGF0ZXBpY2tlck9wdGlvbnNba2V5XSkpIHtcbiAgICAgICAgZGF0ZXNba2V5XSA9IG5ldyBEYXRlKCRzY29wZS5kYXRlcGlja2VyT3B0aW9uc1trZXldKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICgkZGF0ZXBpY2tlclBvcHVwTGl0ZXJhbFdhcm5pbmcpIHtcbiAgICAgICAgICAkbG9nLndhcm4oJ0xpdGVyYWwgZGF0ZSBzdXBwb3J0IGhhcyBiZWVuIGRlcHJlY2F0ZWQsIHBsZWFzZSBzd2l0Y2ggdG8gZGF0ZSBvYmplY3QgdXNhZ2UnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRhdGVzW2tleV0gPSBuZXcgRGF0ZShkYXRlRmlsdGVyKCRzY29wZS5kYXRlcGlja2VyT3B0aW9uc1trZXldLCAnbWVkaXVtJykpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuICRzY29wZS5kYXRlcGlja2VyT3B0aW9ucyAmJlxuICAgICAgZGF0ZXMubWluRGF0ZSAmJiAkc2NvcGUuY29tcGFyZShkYXRlLCBkYXRlcy5taW5EYXRlKSA8IDAgfHxcbiAgICAgIGRhdGVzLm1heERhdGUgJiYgJHNjb3BlLmNvbXBhcmUoZGF0ZSwgZGF0ZXMubWF4RGF0ZSkgPiAwO1xuICB9O1xuXG4gICRzY29wZS5jb21wYXJlID0gZnVuY3Rpb24oZGF0ZTEsIGRhdGUyKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKGRhdGUxLmdldEZ1bGxZZWFyKCksIGRhdGUxLmdldE1vbnRoKCksIGRhdGUxLmdldERhdGUoKSkgLSBuZXcgRGF0ZShkYXRlMi5nZXRGdWxsWWVhcigpLCBkYXRlMi5nZXRNb250aCgpLCBkYXRlMi5nZXREYXRlKCkpO1xuICB9O1xuXG4gIC8vIElubmVyIGNoYW5nZVxuICAkc2NvcGUuZGF0ZVNlbGVjdGlvbiA9IGZ1bmN0aW9uKGR0KSB7XG4gICAgJHNjb3BlLmRhdGUgPSBkdDtcbiAgICB2YXIgZGF0ZSA9ICRzY29wZS5kYXRlID8gZGF0ZVBhcnNlci5maWx0ZXIoJHNjb3BlLmRhdGUsIGRhdGVGb3JtYXQpIDogbnVsbDsgLy8gU2V0dGluZyB0byBOVUxMIGlzIG5lY2Vzc2FyeSBmb3IgZm9ybSB2YWxpZGF0b3JzIHRvIGZ1bmN0aW9uXG4gICAgJGVsZW1lbnQudmFsKGRhdGUpO1xuICAgIG5nTW9kZWwuJHNldFZpZXdWYWx1ZShkYXRlKTtcblxuICAgIGlmIChjbG9zZU9uRGF0ZVNlbGVjdGlvbikge1xuICAgICAgJHNjb3BlLmlzT3BlbiA9IGZhbHNlO1xuICAgICAgJGVsZW1lbnRbMF0uZm9jdXMoKTtcbiAgICB9XG4gIH07XG5cbiAgJHNjb3BlLmtleWRvd24gPSBmdW5jdGlvbihldnQpIHtcbiAgICBpZiAoZXZ0LndoaWNoID09PSAyNykge1xuICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgJHNjb3BlLmlzT3BlbiA9IGZhbHNlO1xuICAgICAgJGVsZW1lbnRbMF0uZm9jdXMoKTtcbiAgICB9XG4gIH07XG5cbiAgJHNjb3BlLnNlbGVjdCA9IGZ1bmN0aW9uKGRhdGUsIGV2dCkge1xuICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgIGlmIChkYXRlID09PSAndG9kYXknKSB7XG4gICAgICB2YXIgdG9kYXkgPSBuZXcgRGF0ZSgpO1xuICAgICAgaWYgKGFuZ3VsYXIuaXNEYXRlKCRzY29wZS5kYXRlKSkge1xuICAgICAgICBkYXRlID0gbmV3IERhdGUoJHNjb3BlLmRhdGUpO1xuICAgICAgICBkYXRlLnNldEZ1bGxZZWFyKHRvZGF5LmdldEZ1bGxZZWFyKCksIHRvZGF5LmdldE1vbnRoKCksIHRvZGF5LmdldERhdGUoKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXRlID0gZGF0ZVBhcnNlci5mcm9tVGltZXpvbmUodG9kYXksIG5nTW9kZWxPcHRpb25zLmdldE9wdGlvbigndGltZXpvbmUnKSk7XG4gICAgICAgIGRhdGUuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG4gICAgICB9XG4gICAgfVxuICAgICRzY29wZS5kYXRlU2VsZWN0aW9uKGRhdGUpO1xuICB9O1xuXG4gICRzY29wZS5jbG9zZSA9IGZ1bmN0aW9uKGV2dCkge1xuICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICRzY29wZS5pc09wZW4gPSBmYWxzZTtcbiAgICAkZWxlbWVudFswXS5mb2N1cygpO1xuICB9O1xuXG4gICRzY29wZS5kaXNhYmxlZCA9IGFuZ3VsYXIuaXNEZWZpbmVkKCRhdHRycy5kaXNhYmxlZCkgfHwgZmFsc2U7XG4gIGlmICgkYXR0cnMubmdEaXNhYmxlZCkge1xuICAgIHdhdGNoTGlzdGVuZXJzLnB1c2goJHNjb3BlLiRwYXJlbnQuJHdhdGNoKCRwYXJzZSgkYXR0cnMubmdEaXNhYmxlZCksIGZ1bmN0aW9uKGRpc2FibGVkKSB7XG4gICAgICAkc2NvcGUuZGlzYWJsZWQgPSBkaXNhYmxlZDtcbiAgICB9KSk7XG4gIH1cblxuICAkc2NvcGUuJHdhdGNoKCdpc09wZW4nLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgaWYgKCEkc2NvcGUuZGlzYWJsZWQpIHtcbiAgICAgICAgJHRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcG9zaXRpb25Qb3B1cCgpO1xuXG4gICAgICAgICAgaWYgKG9uT3BlbkZvY3VzKSB7XG4gICAgICAgICAgICAkc2NvcGUuJGJyb2FkY2FzdCgndWliOmRhdGVwaWNrZXIuZm9jdXMnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAkZG9jdW1lbnQub24oJ2NsaWNrJywgZG9jdW1lbnRDbGlja0JpbmQpO1xuXG4gICAgICAgICAgdmFyIHBsYWNlbWVudCA9ICRhdHRycy5wb3B1cFBsYWNlbWVudCA/ICRhdHRycy5wb3B1cFBsYWNlbWVudCA6IGRhdGVwaWNrZXJQb3B1cENvbmZpZy5wbGFjZW1lbnQ7XG4gICAgICAgICAgaWYgKGFwcGVuZFRvQm9keSB8fCAkcG9zaXRpb24ucGFyc2VQbGFjZW1lbnQocGxhY2VtZW50KVsyXSkge1xuICAgICAgICAgICAgc2Nyb2xsUGFyZW50RWwgPSBzY3JvbGxQYXJlbnRFbCB8fCBhbmd1bGFyLmVsZW1lbnQoJHBvc2l0aW9uLnNjcm9sbFBhcmVudCgkZWxlbWVudCkpO1xuICAgICAgICAgICAgaWYgKHNjcm9sbFBhcmVudEVsKSB7XG4gICAgICAgICAgICAgIHNjcm9sbFBhcmVudEVsLm9uKCdzY3JvbGwnLCBwb3NpdGlvblBvcHVwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2Nyb2xsUGFyZW50RWwgPSBudWxsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGFuZ3VsYXIuZWxlbWVudCgkd2luZG93KS5vbigncmVzaXplJywgcG9zaXRpb25Qb3B1cCk7XG4gICAgICAgIH0sIDAsIGZhbHNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICRzY29wZS5pc09wZW4gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgJGRvY3VtZW50Lm9mZignY2xpY2snLCBkb2N1bWVudENsaWNrQmluZCk7XG4gICAgICBpZiAoc2Nyb2xsUGFyZW50RWwpIHtcbiAgICAgICAgc2Nyb2xsUGFyZW50RWwub2ZmKCdzY3JvbGwnLCBwb3NpdGlvblBvcHVwKTtcbiAgICAgIH1cbiAgICAgIGFuZ3VsYXIuZWxlbWVudCgkd2luZG93KS5vZmYoJ3Jlc2l6ZScsIHBvc2l0aW9uUG9wdXApO1xuICAgIH1cbiAgfSk7XG5cbiAgZnVuY3Rpb24gY2FtZWx0b0Rhc2goc3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC8oW0EtWl0pL2csIGZ1bmN0aW9uKCQxKSB7IHJldHVybiAnLScgKyAkMS50b0xvd2VyQ2FzZSgpOyB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlRGF0ZVN0cmluZyh2aWV3VmFsdWUpIHtcbiAgICB2YXIgZGF0ZSA9IGRhdGVQYXJzZXIucGFyc2Uodmlld1ZhbHVlLCBkYXRlRm9ybWF0LCAkc2NvcGUuZGF0ZSk7XG4gICAgaWYgKGlzTmFOKGRhdGUpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFsdElucHV0Rm9ybWF0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBkYXRlID0gZGF0ZVBhcnNlci5wYXJzZSh2aWV3VmFsdWUsIGFsdElucHV0Rm9ybWF0c1tpXSwgJHNjb3BlLmRhdGUpO1xuICAgICAgICBpZiAoIWlzTmFOKGRhdGUpKSB7XG4gICAgICAgICAgcmV0dXJuIGRhdGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRhdGU7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZURhdGUodmlld1ZhbHVlKSB7XG4gICAgaWYgKGFuZ3VsYXIuaXNOdW1iZXIodmlld1ZhbHVlKSkge1xuICAgICAgLy8gcHJlc3VtYWJseSB0aW1lc3RhbXAgdG8gZGF0ZSBvYmplY3RcbiAgICAgIHZpZXdWYWx1ZSA9IG5ldyBEYXRlKHZpZXdWYWx1ZSk7XG4gICAgfVxuXG4gICAgaWYgKCF2aWV3VmFsdWUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmIChhbmd1bGFyLmlzRGF0ZSh2aWV3VmFsdWUpICYmICFpc05hTih2aWV3VmFsdWUpKSB7XG4gICAgICByZXR1cm4gdmlld1ZhbHVlO1xuICAgIH1cblxuICAgIGlmIChhbmd1bGFyLmlzU3RyaW5nKHZpZXdWYWx1ZSkpIHtcbiAgICAgIHZhciBkYXRlID0gcGFyc2VEYXRlU3RyaW5nKHZpZXdWYWx1ZSk7XG4gICAgICBpZiAoIWlzTmFOKGRhdGUpKSB7XG4gICAgICAgIHJldHVybiBkYXRlUGFyc2VyLnRvVGltZXpvbmUoZGF0ZSwgbmdNb2RlbE9wdGlvbnMuZ2V0T3B0aW9uKCd0aW1lem9uZScpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbmdNb2RlbE9wdGlvbnMuZ2V0T3B0aW9uKCdhbGxvd0ludmFsaWQnKSA/IHZpZXdWYWx1ZSA6IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHZhbGlkYXRvcihtb2RlbFZhbHVlLCB2aWV3VmFsdWUpIHtcbiAgICB2YXIgdmFsdWUgPSBtb2RlbFZhbHVlIHx8IHZpZXdWYWx1ZTtcblxuICAgIGlmICghJGF0dHJzLm5nUmVxdWlyZWQgJiYgIXZhbHVlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoYW5ndWxhci5pc051bWJlcih2YWx1ZSkpIHtcbiAgICAgIHZhbHVlID0gbmV3IERhdGUodmFsdWUpO1xuICAgIH1cblxuICAgIGlmICghdmFsdWUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChhbmd1bGFyLmlzRGF0ZSh2YWx1ZSkgJiYgIWlzTmFOKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGFuZ3VsYXIuaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICByZXR1cm4gIWlzTmFOKHBhcnNlRGF0ZVN0cmluZyh2YWx1ZSkpO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRvY3VtZW50Q2xpY2tCaW5kKGV2ZW50KSB7XG4gICAgaWYgKCEkc2NvcGUuaXNPcGVuICYmICRzY29wZS5kaXNhYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwb3B1cCA9ICRwb3B1cFswXTtcbiAgICB2YXIgZHBDb250YWluc1RhcmdldCA9ICRlbGVtZW50WzBdLmNvbnRhaW5zKGV2ZW50LnRhcmdldCk7XG4gICAgLy8gVGhlIHBvcHVwIG5vZGUgbWF5IG5vdCBiZSBhbiBlbGVtZW50IG5vZGVcbiAgICAvLyBJbiBzb21lIGJyb3dzZXJzIChJRSkgb25seSBlbGVtZW50IG5vZGVzIGhhdmUgdGhlICdjb250YWlucycgZnVuY3Rpb25cbiAgICB2YXIgcG9wdXBDb250YWluc1RhcmdldCA9IHBvcHVwLmNvbnRhaW5zICE9PSB1bmRlZmluZWQgJiYgcG9wdXAuY29udGFpbnMoZXZlbnQudGFyZ2V0KTtcbiAgICBpZiAoJHNjb3BlLmlzT3BlbiAmJiAhKGRwQ29udGFpbnNUYXJnZXQgfHwgcG9wdXBDb250YWluc1RhcmdldCkpIHtcbiAgICAgICRzY29wZS4kYXBwbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICRzY29wZS5pc09wZW4gPSBmYWxzZTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlucHV0S2V5ZG93bkJpbmQoZXZ0KSB7XG4gICAgaWYgKGV2dC53aGljaCA9PT0gMjcgJiYgJHNjb3BlLmlzT3Blbikge1xuICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAkc2NvcGUuJGFwcGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAkc2NvcGUuaXNPcGVuID0gZmFsc2U7XG4gICAgICB9KTtcbiAgICAgICRlbGVtZW50WzBdLmZvY3VzKCk7XG4gICAgfSBlbHNlIGlmIChldnQud2hpY2ggPT09IDQwICYmICEkc2NvcGUuaXNPcGVuKSB7XG4gICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICRzY29wZS4kYXBwbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICRzY29wZS5pc09wZW4gPSB0cnVlO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcG9zaXRpb25Qb3B1cCgpIHtcbiAgICBpZiAoJHNjb3BlLmlzT3Blbikge1xuICAgICAgdmFyIGRwRWxlbWVudCA9IGFuZ3VsYXIuZWxlbWVudCgkcG9wdXBbMF0ucXVlcnlTZWxlY3RvcignLnVpYi1kYXRlcGlja2VyLXBvcHVwJykpO1xuICAgICAgdmFyIHBsYWNlbWVudCA9ICRhdHRycy5wb3B1cFBsYWNlbWVudCA/ICRhdHRycy5wb3B1cFBsYWNlbWVudCA6IGRhdGVwaWNrZXJQb3B1cENvbmZpZy5wbGFjZW1lbnQ7XG4gICAgICB2YXIgcG9zaXRpb24gPSAkcG9zaXRpb24ucG9zaXRpb25FbGVtZW50cygkZWxlbWVudCwgZHBFbGVtZW50LCBwbGFjZW1lbnQsIGFwcGVuZFRvQm9keSk7XG4gICAgICBkcEVsZW1lbnQuY3NzKHt0b3A6IHBvc2l0aW9uLnRvcCArICdweCcsIGxlZnQ6IHBvc2l0aW9uLmxlZnQgKyAncHgnfSk7XG4gICAgICBpZiAoZHBFbGVtZW50Lmhhc0NsYXNzKCd1aWItcG9zaXRpb24tbWVhc3VyZScpKSB7XG4gICAgICAgIGRwRWxlbWVudC5yZW1vdmVDbGFzcygndWliLXBvc2l0aW9uLW1lYXN1cmUnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBleHRyYWN0T3B0aW9ucyhuZ01vZGVsQ3RybCkge1xuICAgIHZhciBuZ01vZGVsT3B0aW9ucztcblxuICAgIGlmIChhbmd1bGFyLnZlcnNpb24ubWlub3IgPCA2KSB7IC8vIGluIGFuZ3VsYXIgPCAxLjYgJG9wdGlvbnMgY291bGQgYmUgbWlzc2luZ1xuICAgICAgLy8gZ3VhcmFudGVlIGEgdmFsdWVcbiAgICAgIG5nTW9kZWxPcHRpb25zID0gYW5ndWxhci5pc09iamVjdChuZ01vZGVsQ3RybC4kb3B0aW9ucykgP1xuICAgICAgICBuZ01vZGVsQ3RybC4kb3B0aW9ucyA6XG4gICAgICAgIHtcbiAgICAgICAgICB0aW1lem9uZTogbnVsbFxuICAgICAgICB9O1xuXG4gICAgICAvLyBtaW1pYyAxLjYrIGFwaVxuICAgICAgbmdNb2RlbE9wdGlvbnMuZ2V0T3B0aW9uID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICByZXR1cm4gbmdNb2RlbE9wdGlvbnNba2V5XTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHsgLy8gaW4gYW5ndWxhciA+PTEuNiAkb3B0aW9ucyBpcyBhbHdheXMgcHJlc2VudFxuICAgICAgbmdNb2RlbE9wdGlvbnMgPSBuZ01vZGVsQ3RybC4kb3B0aW9ucztcbiAgICB9XG5cbiAgICByZXR1cm4gbmdNb2RlbE9wdGlvbnM7XG4gIH1cblxuICAkc2NvcGUuJG9uKCd1aWI6ZGF0ZXBpY2tlci5tb2RlJywgZnVuY3Rpb24oKSB7XG4gICAgJHRpbWVvdXQocG9zaXRpb25Qb3B1cCwgMCwgZmFsc2UpO1xuICB9KTtcbn1dKVxuXG4uZGlyZWN0aXZlKCd1aWJEYXRlcGlja2VyUG9wdXAnLCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHtcbiAgICByZXF1aXJlOiBbJ25nTW9kZWwnLCAndWliRGF0ZXBpY2tlclBvcHVwJ10sXG4gICAgY29udHJvbGxlcjogJ1VpYkRhdGVwaWNrZXJQb3B1cENvbnRyb2xsZXInLFxuICAgIHNjb3BlOiB7XG4gICAgICBkYXRlcGlja2VyT3B0aW9uczogJz0/JyxcbiAgICAgIGlzT3BlbjogJz0/JyxcbiAgICAgIGN1cnJlbnRUZXh0OiAnQCcsXG4gICAgICBjbGVhclRleHQ6ICdAJyxcbiAgICAgIGNsb3NlVGV4dDogJ0AnXG4gICAgfSxcbiAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cnMsIGN0cmxzKSB7XG4gICAgICB2YXIgbmdNb2RlbCA9IGN0cmxzWzBdLFxuICAgICAgICBjdHJsID0gY3RybHNbMV07XG5cbiAgICAgIGN0cmwuaW5pdChuZ01vZGVsKTtcbiAgICB9XG4gIH07XG59KVxuXG4uZGlyZWN0aXZlKCd1aWJEYXRlcGlja2VyUG9wdXBXcmFwJywgZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7XG4gICAgcmVzdHJpY3Q6ICdBJyxcbiAgICB0cmFuc2NsdWRlOiB0cnVlLFxuICAgIHRlbXBsYXRlVXJsOiBmdW5jdGlvbihlbGVtZW50LCBhdHRycykge1xuICAgICAgcmV0dXJuIGF0dHJzLnRlbXBsYXRlVXJsIHx8ICd1aWIvdGVtcGxhdGUvZGF0ZXBpY2tlclBvcHVwL3BvcHVwLmh0bWwnO1xuICAgIH1cbiAgfTtcbn0pO1xuXG5hbmd1bGFyLm1vZHVsZSgndWkuYm9vdHN0cmFwLmRlYm91bmNlJywgW10pXG4vKipcbiAqIEEgaGVscGVyLCBpbnRlcm5hbCBzZXJ2aWNlIHRoYXQgZGVib3VuY2VzIGEgZnVuY3Rpb25cbiAqL1xuICAuZmFjdG9yeSgnJCRkZWJvdW5jZScsIFsnJHRpbWVvdXQnLCBmdW5jdGlvbigkdGltZW91dCkge1xuICAgIHJldHVybiBmdW5jdGlvbihjYWxsYmFjaywgZGVib3VuY2VUaW1lKSB7XG4gICAgICB2YXIgdGltZW91dFByb21pc2U7XG5cbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgIGlmICh0aW1lb3V0UHJvbWlzZSkge1xuICAgICAgICAgICR0aW1lb3V0LmNhbmNlbCh0aW1lb3V0UHJvbWlzZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aW1lb3V0UHJvbWlzZSA9ICR0aW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgICAgICB9LCBkZWJvdW5jZVRpbWUpO1xuICAgICAgfTtcbiAgICB9O1xuICB9XSk7XG5cbmFuZ3VsYXIubW9kdWxlKCd1aS5ib290c3RyYXAubXVsdGlNYXAnLCBbXSlcbi8qKlxuICogQSBoZWxwZXIsIGludGVybmFsIGRhdGEgc3RydWN0dXJlIHRoYXQgc3RvcmVzIGFsbCByZWZlcmVuY2VzIGF0dGFjaGVkIHRvIGtleVxuICovXG4gIC5mYWN0b3J5KCckJG11bHRpTWFwJywgZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNyZWF0ZU5ldzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBtYXAgPSB7fTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGVudHJpZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKG1hcCkubWFwKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgICAgICAgIHZhbHVlOiBtYXBba2V5XVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIG1hcFtrZXldO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgaGFzS2V5OiBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiAhIW1hcFtrZXldO1xuICAgICAgICAgIH0sXG4gICAgICAgICAga2V5czogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMobWFwKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHB1dDogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKCFtYXBba2V5XSkge1xuICAgICAgICAgICAgICBtYXBba2V5XSA9IFtdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtYXBba2V5XS5wdXNoKHZhbHVlKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlbW92ZTogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlcyA9IG1hcFtrZXldO1xuXG4gICAgICAgICAgICBpZiAoIXZhbHVlcykge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBpZHggPSB2YWx1ZXMuaW5kZXhPZih2YWx1ZSk7XG5cbiAgICAgICAgICAgIGlmIChpZHggIT09IC0xKSB7XG4gICAgICAgICAgICAgIHZhbHVlcy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCF2YWx1ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGRlbGV0ZSBtYXBba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG5cbmFuZ3VsYXIubW9kdWxlKCd1aS5ib290c3RyYXAuZHJvcGRvd24nLCBbJ3VpLmJvb3RzdHJhcC5tdWx0aU1hcCcsICd1aS5ib290c3RyYXAucG9zaXRpb24nXSlcblxuLmNvbnN0YW50KCd1aWJEcm9wZG93bkNvbmZpZycsIHtcbiAgYXBwZW5kVG9PcGVuQ2xhc3M6ICd1aWItZHJvcGRvd24tb3BlbicsXG4gIG9wZW5DbGFzczogJ29wZW4nXG59KVxuXG4uc2VydmljZSgndWliRHJvcGRvd25TZXJ2aWNlJywgWyckZG9jdW1lbnQnLCAnJHJvb3RTY29wZScsICckJG11bHRpTWFwJywgZnVuY3Rpb24oJGRvY3VtZW50LCAkcm9vdFNjb3BlLCAkJG11bHRpTWFwKSB7XG4gIHZhciBvcGVuU2NvcGUgPSBudWxsO1xuICB2YXIgb3BlbmVkQ29udGFpbmVycyA9ICQkbXVsdGlNYXAuY3JlYXRlTmV3KCk7XG5cbiAgdGhpcy5pc09ubHlPcGVuID0gZnVuY3Rpb24oZHJvcGRvd25TY29wZSwgYXBwZW5kVG8pIHtcbiAgICB2YXIgb3BlbmVkRHJvcGRvd25zID0gb3BlbmVkQ29udGFpbmVycy5nZXQoYXBwZW5kVG8pO1xuICAgIGlmIChvcGVuZWREcm9wZG93bnMpIHtcbiAgICAgIHZhciBvcGVuRHJvcGRvd24gPSBvcGVuZWREcm9wZG93bnMucmVkdWNlKGZ1bmN0aW9uKHRvQ2xvc2UsIGRyb3Bkb3duKSB7XG4gICAgICAgIGlmIChkcm9wZG93bi5zY29wZSA9PT0gZHJvcGRvd25TY29wZSkge1xuICAgICAgICAgIHJldHVybiBkcm9wZG93bjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0b0Nsb3NlO1xuICAgICAgfSwge30pO1xuICAgICAgaWYgKG9wZW5Ecm9wZG93bikge1xuICAgICAgICByZXR1cm4gb3BlbmVkRHJvcGRvd25zLmxlbmd0aCA9PT0gMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgdGhpcy5vcGVuID0gZnVuY3Rpb24oZHJvcGRvd25TY29wZSwgZWxlbWVudCwgYXBwZW5kVG8pIHtcbiAgICBpZiAoIW9wZW5TY29wZSkge1xuICAgICAgJGRvY3VtZW50Lm9uKCdjbGljaycsIGNsb3NlRHJvcGRvd24pO1xuICAgIH1cblxuICAgIGlmIChvcGVuU2NvcGUgJiYgb3BlblNjb3BlICE9PSBkcm9wZG93blNjb3BlKSB7XG4gICAgICBvcGVuU2NvcGUuaXNPcGVuID0gZmFsc2U7XG4gICAgfVxuXG4gICAgb3BlblNjb3BlID0gZHJvcGRvd25TY29wZTtcblxuICAgIGlmICghYXBwZW5kVG8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgb3BlbmVkRHJvcGRvd25zID0gb3BlbmVkQ29udGFpbmVycy5nZXQoYXBwZW5kVG8pO1xuICAgIGlmIChvcGVuZWREcm9wZG93bnMpIHtcbiAgICAgIHZhciBvcGVuZWRTY29wZXMgPSBvcGVuZWREcm9wZG93bnMubWFwKGZ1bmN0aW9uKGRyb3Bkb3duKSB7XG4gICAgICAgIHJldHVybiBkcm9wZG93bi5zY29wZTtcbiAgICAgIH0pO1xuICAgICAgaWYgKG9wZW5lZFNjb3Blcy5pbmRleE9mKGRyb3Bkb3duU2NvcGUpID09PSAtMSkge1xuICAgICAgICBvcGVuZWRDb250YWluZXJzLnB1dChhcHBlbmRUbywge1xuICAgICAgICAgIHNjb3BlOiBkcm9wZG93blNjb3BlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBvcGVuZWRDb250YWluZXJzLnB1dChhcHBlbmRUbywge1xuICAgICAgICBzY29wZTogZHJvcGRvd25TY29wZVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIHRoaXMuY2xvc2UgPSBmdW5jdGlvbihkcm9wZG93blNjb3BlLCBlbGVtZW50LCBhcHBlbmRUbykge1xuICAgIGlmIChvcGVuU2NvcGUgPT09IGRyb3Bkb3duU2NvcGUpIHtcbiAgICAgICRkb2N1bWVudC5vZmYoJ2NsaWNrJywgY2xvc2VEcm9wZG93bik7XG4gICAgICAkZG9jdW1lbnQub2ZmKCdrZXlkb3duJywgdGhpcy5rZXliaW5kRmlsdGVyKTtcbiAgICAgIG9wZW5TY29wZSA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKCFhcHBlbmRUbykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBvcGVuZWREcm9wZG93bnMgPSBvcGVuZWRDb250YWluZXJzLmdldChhcHBlbmRUbyk7XG4gICAgaWYgKG9wZW5lZERyb3Bkb3ducykge1xuICAgICAgdmFyIGRyb3Bkb3duVG9DbG9zZSA9IG9wZW5lZERyb3Bkb3ducy5yZWR1Y2UoZnVuY3Rpb24odG9DbG9zZSwgZHJvcGRvd24pIHtcbiAgICAgICAgaWYgKGRyb3Bkb3duLnNjb3BlID09PSBkcm9wZG93blNjb3BlKSB7XG4gICAgICAgICAgcmV0dXJuIGRyb3Bkb3duO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRvQ2xvc2U7XG4gICAgICB9LCB7fSk7XG4gICAgICBpZiAoZHJvcGRvd25Ub0Nsb3NlKSB7XG4gICAgICAgIG9wZW5lZENvbnRhaW5lcnMucmVtb3ZlKGFwcGVuZFRvLCBkcm9wZG93blRvQ2xvc2UpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YXIgY2xvc2VEcm9wZG93biA9IGZ1bmN0aW9uKGV2dCkge1xuICAgIC8vIFRoaXMgbWV0aG9kIG1heSBzdGlsbCBiZSBjYWxsZWQgZHVyaW5nIHRoZSBzYW1lIG1vdXNlIGV2ZW50IHRoYXRcbiAgICAvLyB1bmJvdW5kIHRoaXMgZXZlbnQgaGFuZGxlci4gU28gY2hlY2sgb3BlblNjb3BlIGJlZm9yZSBwcm9jZWVkaW5nLlxuICAgIGlmICghb3BlblNjb3BlIHx8ICFvcGVuU2NvcGUuaXNPcGVuKSB7IHJldHVybjsgfVxuXG4gICAgaWYgKGV2dCAmJiBvcGVuU2NvcGUuZ2V0QXV0b0Nsb3NlKCkgPT09ICdkaXNhYmxlZCcpIHsgcmV0dXJuOyB9XG5cbiAgICBpZiAoZXZ0ICYmIGV2dC53aGljaCA9PT0gMykgeyByZXR1cm47IH1cblxuICAgIHZhciB0b2dnbGVFbGVtZW50ID0gb3BlblNjb3BlLmdldFRvZ2dsZUVsZW1lbnQoKTtcbiAgICBpZiAoZXZ0ICYmIHRvZ2dsZUVsZW1lbnQgJiYgdG9nZ2xlRWxlbWVudFswXS5jb250YWlucyhldnQudGFyZ2V0KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBkcm9wZG93bkVsZW1lbnQgPSBvcGVuU2NvcGUuZ2V0RHJvcGRvd25FbGVtZW50KCk7XG4gICAgaWYgKGV2dCAmJiBvcGVuU2NvcGUuZ2V0QXV0b0Nsb3NlKCkgPT09ICdvdXRzaWRlQ2xpY2snICYmXG4gICAgICBkcm9wZG93bkVsZW1lbnQgJiYgZHJvcGRvd25FbGVtZW50WzBdLmNvbnRhaW5zKGV2dC50YXJnZXQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgb3BlblNjb3BlLmZvY3VzVG9nZ2xlRWxlbWVudCgpO1xuICAgIG9wZW5TY29wZS5pc09wZW4gPSBmYWxzZTtcblxuICAgIGlmICghJHJvb3RTY29wZS4kJHBoYXNlKSB7XG4gICAgICBvcGVuU2NvcGUuJGFwcGx5KCk7XG4gICAgfVxuICB9O1xuXG4gIHRoaXMua2V5YmluZEZpbHRlciA9IGZ1bmN0aW9uKGV2dCkge1xuICAgIGlmICghb3BlblNjb3BlKSB7XG4gICAgICAvLyBzZWUgdGhpcy5jbG9zZSBhcyBFU0MgY291bGQgaGF2ZSBiZWVuIHByZXNzZWQgd2hpY2gga2lsbHMgdGhlIHNjb3BlIHNvIHdlIGNhbiBub3QgcHJvY2VlZFxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBkcm9wZG93bkVsZW1lbnQgPSBvcGVuU2NvcGUuZ2V0RHJvcGRvd25FbGVtZW50KCk7XG4gICAgdmFyIHRvZ2dsZUVsZW1lbnQgPSBvcGVuU2NvcGUuZ2V0VG9nZ2xlRWxlbWVudCgpO1xuICAgIHZhciBkcm9wZG93bkVsZW1lbnRUYXJnZXRlZCA9IGRyb3Bkb3duRWxlbWVudCAmJiBkcm9wZG93bkVsZW1lbnRbMF0uY29udGFpbnMoZXZ0LnRhcmdldCk7XG4gICAgdmFyIHRvZ2dsZUVsZW1lbnRUYXJnZXRlZCA9IHRvZ2dsZUVsZW1lbnQgJiYgdG9nZ2xlRWxlbWVudFswXS5jb250YWlucyhldnQudGFyZ2V0KTtcbiAgICBpZiAoZXZ0LndoaWNoID09PSAyNykge1xuICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgb3BlblNjb3BlLmZvY3VzVG9nZ2xlRWxlbWVudCgpO1xuICAgICAgY2xvc2VEcm9wZG93bigpO1xuICAgIH0gZWxzZSBpZiAob3BlblNjb3BlLmlzS2V5bmF2RW5hYmxlZCgpICYmIFszOCwgNDBdLmluZGV4T2YoZXZ0LndoaWNoKSAhPT0gLTEgJiYgb3BlblNjb3BlLmlzT3BlbiAmJiAoZHJvcGRvd25FbGVtZW50VGFyZ2V0ZWQgfHwgdG9nZ2xlRWxlbWVudFRhcmdldGVkKSkge1xuICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICBvcGVuU2NvcGUuZm9jdXNEcm9wZG93bkVudHJ5KGV2dC53aGljaCk7XG4gICAgfVxuICB9O1xufV0pXG5cbi5jb250cm9sbGVyKCdVaWJEcm9wZG93bkNvbnRyb2xsZXInLCBbJyRzY29wZScsICckZWxlbWVudCcsICckYXR0cnMnLCAnJHBhcnNlJywgJ3VpYkRyb3Bkb3duQ29uZmlnJywgJ3VpYkRyb3Bkb3duU2VydmljZScsICckYW5pbWF0ZScsICckdWliUG9zaXRpb24nLCAnJGRvY3VtZW50JywgJyRjb21waWxlJywgJyR0ZW1wbGF0ZVJlcXVlc3QnLCBmdW5jdGlvbigkc2NvcGUsICRlbGVtZW50LCAkYXR0cnMsICRwYXJzZSwgZHJvcGRvd25Db25maWcsIHVpYkRyb3Bkb3duU2VydmljZSwgJGFuaW1hdGUsICRwb3NpdGlvbiwgJGRvY3VtZW50LCAkY29tcGlsZSwgJHRlbXBsYXRlUmVxdWVzdCkge1xuICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgc2NvcGUgPSAkc2NvcGUuJG5ldygpLCAvLyBjcmVhdGUgYSBjaGlsZCBzY29wZSBzbyB3ZSBhcmUgbm90IHBvbGx1dGluZyBvcmlnaW5hbCBvbmVcbiAgICB0ZW1wbGF0ZVNjb3BlLFxuICAgIGFwcGVuZFRvT3BlbkNsYXNzID0gZHJvcGRvd25Db25maWcuYXBwZW5kVG9PcGVuQ2xhc3MsXG4gICAgb3BlbkNsYXNzID0gZHJvcGRvd25Db25maWcub3BlbkNsYXNzLFxuICAgIGdldElzT3BlbixcbiAgICBzZXRJc09wZW4gPSBhbmd1bGFyLm5vb3AsXG4gICAgdG9nZ2xlSW52b2tlciA9ICRhdHRycy5vblRvZ2dsZSA/ICRwYXJzZSgkYXR0cnMub25Ub2dnbGUpIDogYW5ndWxhci5ub29wLFxuICAgIGtleW5hdkVuYWJsZWQgPSBmYWxzZSxcbiAgICBzZWxlY3RlZE9wdGlvbiA9IG51bGwsXG4gICAgYm9keSA9ICRkb2N1bWVudC5maW5kKCdib2R5Jyk7XG5cbiAgJGVsZW1lbnQuYWRkQ2xhc3MoJ2Ryb3Bkb3duJyk7XG5cbiAgdGhpcy5pbml0ID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCRhdHRycy5pc09wZW4pIHtcbiAgICAgIGdldElzT3BlbiA9ICRwYXJzZSgkYXR0cnMuaXNPcGVuKTtcbiAgICAgIHNldElzT3BlbiA9IGdldElzT3Blbi5hc3NpZ247XG5cbiAgICAgICRzY29wZS4kd2F0Y2goZ2V0SXNPcGVuLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBzY29wZS5pc09wZW4gPSAhIXZhbHVlO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAga2V5bmF2RW5hYmxlZCA9IGFuZ3VsYXIuaXNEZWZpbmVkKCRhdHRycy5rZXlib2FyZE5hdik7XG4gIH07XG5cbiAgdGhpcy50b2dnbGUgPSBmdW5jdGlvbihvcGVuKSB7XG4gICAgc2NvcGUuaXNPcGVuID0gYXJndW1lbnRzLmxlbmd0aCA/ICEhb3BlbiA6ICFzY29wZS5pc09wZW47XG4gICAgaWYgKGFuZ3VsYXIuaXNGdW5jdGlvbihzZXRJc09wZW4pKSB7XG4gICAgICBzZXRJc09wZW4oc2NvcGUsIHNjb3BlLmlzT3Blbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNjb3BlLmlzT3BlbjtcbiAgfTtcblxuICAvLyBBbGxvdyBvdGhlciBkaXJlY3RpdmVzIHRvIHdhdGNoIHN0YXR1c1xuICB0aGlzLmlzT3BlbiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBzY29wZS5pc09wZW47XG4gIH07XG5cbiAgc2NvcGUuZ2V0VG9nZ2xlRWxlbWVudCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBzZWxmLnRvZ2dsZUVsZW1lbnQ7XG4gIH07XG5cbiAgc2NvcGUuZ2V0QXV0b0Nsb3NlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICRhdHRycy5hdXRvQ2xvc2UgfHwgJ2Fsd2F5cyc7IC8vb3IgJ291dHNpZGVDbGljaycgb3IgJ2Rpc2FibGVkJ1xuICB9O1xuXG4gIHNjb3BlLmdldEVsZW1lbnQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gJGVsZW1lbnQ7XG4gIH07XG5cbiAgc2NvcGUuaXNLZXluYXZFbmFibGVkID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGtleW5hdkVuYWJsZWQ7XG4gIH07XG5cbiAgc2NvcGUuZm9jdXNEcm9wZG93bkVudHJ5ID0gZnVuY3Rpb24oa2V5Q29kZSkge1xuICAgIHZhciBlbGVtcyA9IHNlbGYuZHJvcGRvd25NZW51ID8gLy9JZiBhcHBlbmQgdG8gYm9keSBpcyB1c2VkLlxuICAgICAgYW5ndWxhci5lbGVtZW50KHNlbGYuZHJvcGRvd25NZW51KS5maW5kKCdhJykgOlxuICAgICAgJGVsZW1lbnQuZmluZCgndWwnKS5lcSgwKS5maW5kKCdhJyk7XG5cbiAgICBzd2l0Y2ggKGtleUNvZGUpIHtcbiAgICAgIGNhc2UgNDA6IHtcbiAgICAgICAgaWYgKCFhbmd1bGFyLmlzTnVtYmVyKHNlbGYuc2VsZWN0ZWRPcHRpb24pKSB7XG4gICAgICAgICAgc2VsZi5zZWxlY3RlZE9wdGlvbiA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2VsZi5zZWxlY3RlZE9wdGlvbiA9IHNlbGYuc2VsZWN0ZWRPcHRpb24gPT09IGVsZW1zLmxlbmd0aCAtIDEgP1xuICAgICAgICAgICAgc2VsZi5zZWxlY3RlZE9wdGlvbiA6XG4gICAgICAgICAgICBzZWxmLnNlbGVjdGVkT3B0aW9uICsgMTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgMzg6IHtcbiAgICAgICAgaWYgKCFhbmd1bGFyLmlzTnVtYmVyKHNlbGYuc2VsZWN0ZWRPcHRpb24pKSB7XG4gICAgICAgICAgc2VsZi5zZWxlY3RlZE9wdGlvbiA9IGVsZW1zLmxlbmd0aCAtIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2VsZi5zZWxlY3RlZE9wdGlvbiA9IHNlbGYuc2VsZWN0ZWRPcHRpb24gPT09IDAgP1xuICAgICAgICAgICAgMCA6IHNlbGYuc2VsZWN0ZWRPcHRpb24gLSAxO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBlbGVtc1tzZWxmLnNlbGVjdGVkT3B0aW9uXS5mb2N1cygpO1xuICB9O1xuXG4gIHNjb3BlLmdldERyb3Bkb3duRWxlbWVudCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBzZWxmLmRyb3Bkb3duTWVudTtcbiAgfTtcblxuICBzY29wZS5mb2N1c1RvZ2dsZUVsZW1lbnQgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoc2VsZi50b2dnbGVFbGVtZW50KSB7XG4gICAgICBzZWxmLnRvZ2dsZUVsZW1lbnRbMF0uZm9jdXMoKTtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gcmVtb3ZlRHJvcGRvd25NZW51KCkge1xuICAgICRlbGVtZW50LmFwcGVuZChzZWxmLmRyb3Bkb3duTWVudSk7XG4gIH1cblxuICBzY29wZS4kd2F0Y2goJ2lzT3BlbicsIGZ1bmN0aW9uKGlzT3Blbiwgd2FzT3Blbikge1xuICAgIHZhciBhcHBlbmRUbyA9IG51bGwsXG4gICAgICBhcHBlbmRUb0JvZHkgPSBmYWxzZTtcblxuICAgIGlmIChhbmd1bGFyLmlzRGVmaW5lZCgkYXR0cnMuZHJvcGRvd25BcHBlbmRUbykpIHtcbiAgICAgIHZhciBhcHBlbmRUb0VsID0gJHBhcnNlKCRhdHRycy5kcm9wZG93bkFwcGVuZFRvKShzY29wZSk7XG4gICAgICBpZiAoYXBwZW5kVG9FbCkge1xuICAgICAgICBhcHBlbmRUbyA9IGFuZ3VsYXIuZWxlbWVudChhcHBlbmRUb0VsKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYW5ndWxhci5pc0RlZmluZWQoJGF0dHJzLmRyb3Bkb3duQXBwZW5kVG9Cb2R5KSkge1xuICAgICAgdmFyIGFwcGVuZFRvQm9keVZhbHVlID0gJHBhcnNlKCRhdHRycy5kcm9wZG93bkFwcGVuZFRvQm9keSkoc2NvcGUpO1xuICAgICAgaWYgKGFwcGVuZFRvQm9keVZhbHVlICE9PSBmYWxzZSkge1xuICAgICAgICBhcHBlbmRUb0JvZHkgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChhcHBlbmRUb0JvZHkgJiYgIWFwcGVuZFRvKSB7XG4gICAgICBhcHBlbmRUbyA9IGJvZHk7XG4gICAgfVxuXG4gICAgaWYgKGFwcGVuZFRvICYmIHNlbGYuZHJvcGRvd25NZW51KSB7XG4gICAgICBpZiAoaXNPcGVuKSB7XG4gICAgICAgIGFwcGVuZFRvLmFwcGVuZChzZWxmLmRyb3Bkb3duTWVudSk7XG4gICAgICAgICRlbGVtZW50Lm9uKCckZGVzdHJveScsIHJlbW92ZURyb3Bkb3duTWVudSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAkZWxlbWVudC5vZmYoJyRkZXN0cm95JywgcmVtb3ZlRHJvcGRvd25NZW51KTtcbiAgICAgICAgcmVtb3ZlRHJvcGRvd25NZW51KCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGFwcGVuZFRvICYmIHNlbGYuZHJvcGRvd25NZW51KSB7XG4gICAgICB2YXIgcG9zID0gJHBvc2l0aW9uLnBvc2l0aW9uRWxlbWVudHMoJGVsZW1lbnQsIHNlbGYuZHJvcGRvd25NZW51LCAnYm90dG9tLWxlZnQnLCB0cnVlKSxcbiAgICAgICAgY3NzLFxuICAgICAgICByaWdodGFsaWduLFxuICAgICAgICBzY3JvbGxiYXJQYWRkaW5nLFxuICAgICAgICBzY3JvbGxiYXJXaWR0aCA9IDA7XG5cbiAgICAgIGNzcyA9IHtcbiAgICAgICAgdG9wOiBwb3MudG9wICsgJ3B4JyxcbiAgICAgICAgZGlzcGxheTogaXNPcGVuID8gJ2Jsb2NrJyA6ICdub25lJ1xuICAgICAgfTtcblxuICAgICAgcmlnaHRhbGlnbiA9IHNlbGYuZHJvcGRvd25NZW51Lmhhc0NsYXNzKCdkcm9wZG93bi1tZW51LXJpZ2h0Jyk7XG4gICAgICBpZiAoIXJpZ2h0YWxpZ24pIHtcbiAgICAgICAgY3NzLmxlZnQgPSBwb3MubGVmdCArICdweCc7XG4gICAgICAgIGNzcy5yaWdodCA9ICdhdXRvJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNzcy5sZWZ0ID0gJ2F1dG8nO1xuICAgICAgICBzY3JvbGxiYXJQYWRkaW5nID0gJHBvc2l0aW9uLnNjcm9sbGJhclBhZGRpbmcoYXBwZW5kVG8pO1xuXG4gICAgICAgIGlmIChzY3JvbGxiYXJQYWRkaW5nLmhlaWdodE92ZXJmbG93ICYmIHNjcm9sbGJhclBhZGRpbmcuc2Nyb2xsYmFyV2lkdGgpIHtcbiAgICAgICAgICBzY3JvbGxiYXJXaWR0aCA9IHNjcm9sbGJhclBhZGRpbmcuc2Nyb2xsYmFyV2lkdGg7XG4gICAgICAgIH1cblxuICAgICAgICBjc3MucmlnaHQgPSB3aW5kb3cuaW5uZXJXaWR0aCAtIHNjcm9sbGJhcldpZHRoIC1cbiAgICAgICAgICAocG9zLmxlZnQgKyAkZWxlbWVudC5wcm9wKCdvZmZzZXRXaWR0aCcpKSArICdweCc7XG4gICAgICB9XG5cbiAgICAgIC8vIE5lZWQgdG8gYWRqdXN0IG91ciBwb3NpdGlvbmluZyB0byBiZSByZWxhdGl2ZSB0byB0aGUgYXBwZW5kVG8gY29udGFpbmVyXG4gICAgICAvLyBpZiBpdCdzIG5vdCB0aGUgYm9keSBlbGVtZW50XG4gICAgICBpZiAoIWFwcGVuZFRvQm9keSkge1xuICAgICAgICB2YXIgYXBwZW5kT2Zmc2V0ID0gJHBvc2l0aW9uLm9mZnNldChhcHBlbmRUbyk7XG5cbiAgICAgICAgY3NzLnRvcCA9IHBvcy50b3AgLSBhcHBlbmRPZmZzZXQudG9wICsgJ3B4JztcblxuICAgICAgICBpZiAoIXJpZ2h0YWxpZ24pIHtcbiAgICAgICAgICBjc3MubGVmdCA9IHBvcy5sZWZ0IC0gYXBwZW5kT2Zmc2V0LmxlZnQgKyAncHgnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNzcy5yaWdodCA9IHdpbmRvdy5pbm5lcldpZHRoIC1cbiAgICAgICAgICAgIChwb3MubGVmdCAtIGFwcGVuZE9mZnNldC5sZWZ0ICsgJGVsZW1lbnQucHJvcCgnb2Zmc2V0V2lkdGgnKSkgKyAncHgnO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHNlbGYuZHJvcGRvd25NZW51LmNzcyhjc3MpO1xuICAgIH1cblxuICAgIHZhciBvcGVuQ29udGFpbmVyID0gYXBwZW5kVG8gPyBhcHBlbmRUbyA6ICRlbGVtZW50O1xuICAgIHZhciBkcm9wZG93bk9wZW5DbGFzcyA9IGFwcGVuZFRvID8gYXBwZW5kVG9PcGVuQ2xhc3MgOiBvcGVuQ2xhc3M7XG4gICAgdmFyIGhhc09wZW5DbGFzcyA9IG9wZW5Db250YWluZXIuaGFzQ2xhc3MoZHJvcGRvd25PcGVuQ2xhc3MpO1xuICAgIHZhciBpc09ubHlPcGVuID0gdWliRHJvcGRvd25TZXJ2aWNlLmlzT25seU9wZW4oJHNjb3BlLCBhcHBlbmRUbyk7XG5cbiAgICBpZiAoaGFzT3BlbkNsYXNzID09PSAhaXNPcGVuKSB7XG4gICAgICB2YXIgdG9nZ2xlQ2xhc3M7XG4gICAgICBpZiAoYXBwZW5kVG8pIHtcbiAgICAgICAgdG9nZ2xlQ2xhc3MgPSAhaXNPbmx5T3BlbiA/ICdhZGRDbGFzcycgOiAncmVtb3ZlQ2xhc3MnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdG9nZ2xlQ2xhc3MgPSBpc09wZW4gPyAnYWRkQ2xhc3MnIDogJ3JlbW92ZUNsYXNzJztcbiAgICAgIH1cbiAgICAgICRhbmltYXRlW3RvZ2dsZUNsYXNzXShvcGVuQ29udGFpbmVyLCBkcm9wZG93bk9wZW5DbGFzcykudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKGFuZ3VsYXIuaXNEZWZpbmVkKGlzT3BlbikgJiYgaXNPcGVuICE9PSB3YXNPcGVuKSB7XG4gICAgICAgICAgdG9nZ2xlSW52b2tlcigkc2NvcGUsIHsgb3BlbjogISFpc09wZW4gfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChpc09wZW4pIHtcbiAgICAgIGlmIChzZWxmLmRyb3Bkb3duTWVudVRlbXBsYXRlVXJsKSB7XG4gICAgICAgICR0ZW1wbGF0ZVJlcXVlc3Qoc2VsZi5kcm9wZG93bk1lbnVUZW1wbGF0ZVVybCkudGhlbihmdW5jdGlvbih0cGxDb250ZW50KSB7XG4gICAgICAgICAgdGVtcGxhdGVTY29wZSA9IHNjb3BlLiRuZXcoKTtcbiAgICAgICAgICAkY29tcGlsZSh0cGxDb250ZW50LnRyaW0oKSkodGVtcGxhdGVTY29wZSwgZnVuY3Rpb24oZHJvcGRvd25FbGVtZW50KSB7XG4gICAgICAgICAgICB2YXIgbmV3RWwgPSBkcm9wZG93bkVsZW1lbnQ7XG4gICAgICAgICAgICBzZWxmLmRyb3Bkb3duTWVudS5yZXBsYWNlV2l0aChuZXdFbCk7XG4gICAgICAgICAgICBzZWxmLmRyb3Bkb3duTWVudSA9IG5ld0VsO1xuICAgICAgICAgICAgJGRvY3VtZW50Lm9uKCdrZXlkb3duJywgdWliRHJvcGRvd25TZXJ2aWNlLmtleWJpbmRGaWx0ZXIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICRkb2N1bWVudC5vbigna2V5ZG93bicsIHVpYkRyb3Bkb3duU2VydmljZS5rZXliaW5kRmlsdGVyKTtcbiAgICAgIH1cblxuICAgICAgc2NvcGUuZm9jdXNUb2dnbGVFbGVtZW50KCk7XG4gICAgICB1aWJEcm9wZG93blNlcnZpY2Uub3BlbihzY29wZSwgJGVsZW1lbnQsIGFwcGVuZFRvKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdWliRHJvcGRvd25TZXJ2aWNlLmNsb3NlKHNjb3BlLCAkZWxlbWVudCwgYXBwZW5kVG8pO1xuICAgICAgaWYgKHNlbGYuZHJvcGRvd25NZW51VGVtcGxhdGVVcmwpIHtcbiAgICAgICAgaWYgKHRlbXBsYXRlU2NvcGUpIHtcbiAgICAgICAgICB0ZW1wbGF0ZVNjb3BlLiRkZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5ld0VsID0gYW5ndWxhci5lbGVtZW50KCc8dWwgY2xhc3M9XCJkcm9wZG93bi1tZW51XCI+PC91bD4nKTtcbiAgICAgICAgc2VsZi5kcm9wZG93bk1lbnUucmVwbGFjZVdpdGgobmV3RWwpO1xuICAgICAgICBzZWxmLmRyb3Bkb3duTWVudSA9IG5ld0VsO1xuICAgICAgfVxuXG4gICAgICBzZWxmLnNlbGVjdGVkT3B0aW9uID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoYW5ndWxhci5pc0Z1bmN0aW9uKHNldElzT3BlbikpIHtcbiAgICAgIHNldElzT3Blbigkc2NvcGUsIGlzT3Blbik7XG4gICAgfVxuICB9KTtcbn1dKVxuXG4uZGlyZWN0aXZlKCd1aWJEcm9wZG93bicsIGZ1bmN0aW9uKCkge1xuICByZXR1cm4ge1xuICAgIGNvbnRyb2xsZXI6ICdVaWJEcm9wZG93bkNvbnRyb2xsZXInLFxuICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRycywgZHJvcGRvd25DdHJsKSB7XG4gICAgICBkcm9wZG93bkN0cmwuaW5pdCgpO1xuICAgIH1cbiAgfTtcbn0pXG5cbi5kaXJlY3RpdmUoJ3VpYkRyb3Bkb3duTWVudScsIGZ1bmN0aW9uKCkge1xuICByZXR1cm4ge1xuICAgIHJlc3RyaWN0OiAnQScsXG4gICAgcmVxdWlyZTogJz9edWliRHJvcGRvd24nLFxuICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRycywgZHJvcGRvd25DdHJsKSB7XG4gICAgICBpZiAoIWRyb3Bkb3duQ3RybCB8fCBhbmd1bGFyLmlzRGVmaW5lZChhdHRycy5kcm9wZG93bk5lc3RlZCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBlbGVtZW50LmFkZENsYXNzKCdkcm9wZG93bi1tZW51Jyk7XG5cbiAgICAgIHZhciB0cGxVcmwgPSBhdHRycy50ZW1wbGF0ZVVybDtcbiAgICAgIGlmICh0cGxVcmwpIHtcbiAgICAgICAgZHJvcGRvd25DdHJsLmRyb3Bkb3duTWVudVRlbXBsYXRlVXJsID0gdHBsVXJsO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWRyb3Bkb3duQ3RybC5kcm9wZG93bk1lbnUpIHtcbiAgICAgICAgZHJvcGRvd25DdHJsLmRyb3Bkb3duTWVudSA9IGVsZW1lbnQ7XG4gICAgICB9XG4gICAgfVxuICB9O1xufSlcblxuLmRpcmVjdGl2ZSgndWliRHJvcGRvd25Ub2dnbGUnLCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHtcbiAgICByZXF1aXJlOiAnP151aWJEcm9wZG93bicsXG4gICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHJzLCBkcm9wZG93bkN0cmwpIHtcbiAgICAgIGlmICghZHJvcGRvd25DdHJsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZWxlbWVudC5hZGRDbGFzcygnZHJvcGRvd24tdG9nZ2xlJyk7XG5cbiAgICAgIGRyb3Bkb3duQ3RybC50b2dnbGVFbGVtZW50ID0gZWxlbWVudDtcblxuICAgICAgdmFyIHRvZ2dsZURyb3Bkb3duID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICBpZiAoIWVsZW1lbnQuaGFzQ2xhc3MoJ2Rpc2FibGVkJykgJiYgIWF0dHJzLmRpc2FibGVkKSB7XG4gICAgICAgICAgc2NvcGUuJGFwcGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZHJvcGRvd25DdHJsLnRvZ2dsZSgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBlbGVtZW50Lm9uKCdjbGljaycsIHRvZ2dsZURyb3Bkb3duKTtcblxuICAgICAgLy8gV0FJLUFSSUFcbiAgICAgIGVsZW1lbnQuYXR0cih7ICdhcmlhLWhhc3BvcHVwJzogdHJ1ZSwgJ2FyaWEtZXhwYW5kZWQnOiBmYWxzZSB9KTtcbiAgICAgIHNjb3BlLiR3YXRjaChkcm9wZG93bkN0cmwuaXNPcGVuLCBmdW5jdGlvbihpc09wZW4pIHtcbiAgICAgICAgZWxlbWVudC5hdHRyKCdhcmlhLWV4cGFuZGVkJywgISFpc09wZW4pO1xuICAgICAgfSk7XG5cbiAgICAgIHNjb3BlLiRvbignJGRlc3Ryb3knLCBmdW5jdGlvbigpIHtcbiAgICAgICAgZWxlbWVudC5vZmYoJ2NsaWNrJywgdG9nZ2xlRHJvcGRvd24pO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xufSk7XG5cbmFuZ3VsYXIubW9kdWxlKCd1aS5ib290c3RyYXAuc3RhY2tlZE1hcCcsIFtdKVxuLyoqXG4gKiBBIGhlbHBlciwgaW50ZXJuYWwgZGF0YSBzdHJ1Y3R1cmUgdGhhdCBhY3RzIGFzIGEgbWFwIGJ1dCBhbHNvIGFsbG93cyBnZXR0aW5nIC8gcmVtb3ZpbmdcbiAqIGVsZW1lbnRzIGluIHRoZSBMSUZPIG9yZGVyXG4gKi9cbiAgLmZhY3RvcnkoJyQkc3RhY2tlZE1hcCcsIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjcmVhdGVOZXc6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc3RhY2sgPSBbXTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGFkZDogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgc3RhY2sucHVzaCh7XG4gICAgICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhY2subGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgaWYgKGtleSA9PT0gc3RhY2tbaV0ua2V5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YWNrW2ldO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBrZXlzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBrZXlzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YWNrLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIGtleXMucHVzaChzdGFja1tpXS5rZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGtleXM7XG4gICAgICAgICAgfSxcbiAgICAgICAgICB0b3A6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgIHZhciBpZHggPSAtMTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhY2subGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgaWYgKGtleSA9PT0gc3RhY2tbaV0ua2V5KSB7XG4gICAgICAgICAgICAgICAgaWR4ID0gaTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN0YWNrLnNwbGljZShpZHgsIDEpWzBdO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVtb3ZlVG9wOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGFjay5wb3AoKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGxlbmd0aDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhY2subGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuICB9KTtcbmFuZ3VsYXIubW9kdWxlKCd1aS5ib290c3RyYXAubW9kYWwnLCBbJ3VpLmJvb3RzdHJhcC5tdWx0aU1hcCcsICd1aS5ib290c3RyYXAuc3RhY2tlZE1hcCcsICd1aS5ib290c3RyYXAucG9zaXRpb24nXSlcbi8qKlxuICogUGx1Z2dhYmxlIHJlc29sdmUgbWVjaGFuaXNtIGZvciB0aGUgbW9kYWwgcmVzb2x2ZSByZXNvbHV0aW9uXG4gKiBTdXBwb3J0cyBVSSBSb3V0ZXIncyAkcmVzb2x2ZSBzZXJ2aWNlXG4gKi9cbiAgLnByb3ZpZGVyKCckdWliUmVzb2x2ZScsIGZ1bmN0aW9uKCkge1xuICAgIHZhciByZXNvbHZlID0gdGhpcztcbiAgICB0aGlzLnJlc29sdmVyID0gbnVsbDtcblxuICAgIHRoaXMuc2V0UmVzb2x2ZXIgPSBmdW5jdGlvbihyZXNvbHZlcikge1xuICAgICAgdGhpcy5yZXNvbHZlciA9IHJlc29sdmVyO1xuICAgIH07XG5cbiAgICB0aGlzLiRnZXQgPSBbJyRpbmplY3RvcicsICckcScsIGZ1bmN0aW9uKCRpbmplY3RvciwgJHEpIHtcbiAgICAgIHZhciByZXNvbHZlciA9IHJlc29sdmUucmVzb2x2ZXIgPyAkaW5qZWN0b3IuZ2V0KHJlc29sdmUucmVzb2x2ZXIpIDogbnVsbDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlc29sdmU6IGZ1bmN0aW9uKGludm9jYWJsZXMsIGxvY2FscywgcGFyZW50LCBzZWxmKSB7XG4gICAgICAgICAgaWYgKHJlc29sdmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZXIucmVzb2x2ZShpbnZvY2FibGVzLCBsb2NhbHMsIHBhcmVudCwgc2VsZik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHByb21pc2VzID0gW107XG5cbiAgICAgICAgICBhbmd1bGFyLmZvckVhY2goaW52b2NhYmxlcywgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChhbmd1bGFyLmlzRnVuY3Rpb24odmFsdWUpIHx8IGFuZ3VsYXIuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaCgkcS5yZXNvbHZlKCRpbmplY3Rvci5pbnZva2UodmFsdWUpKSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGFuZ3VsYXIuaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgICAgICAgIHByb21pc2VzLnB1c2goJHEucmVzb2x2ZSgkaW5qZWN0b3IuZ2V0KHZhbHVlKSkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaCgkcS5yZXNvbHZlKHZhbHVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICByZXR1cm4gJHEuYWxsKHByb21pc2VzKS50aGVuKGZ1bmN0aW9uKHJlc29sdmVzKSB7XG4gICAgICAgICAgICB2YXIgcmVzb2x2ZU9iaiA9IHt9O1xuICAgICAgICAgICAgdmFyIHJlc29sdmVJdGVyID0gMDtcbiAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChpbnZvY2FibGVzLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICAgICAgICAgIHJlc29sdmVPYmpba2V5XSA9IHJlc29sdmVzW3Jlc29sdmVJdGVyKytdO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlT2JqO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1dO1xuICB9KVxuXG4vKipcbiAqIEEgaGVscGVyIGRpcmVjdGl2ZSBmb3IgdGhlICRtb2RhbCBzZXJ2aWNlLiBJdCBjcmVhdGVzIGEgYmFja2Ryb3AgZWxlbWVudC5cbiAqL1xuICAuZGlyZWN0aXZlKCd1aWJNb2RhbEJhY2tkcm9wJywgWyckYW5pbWF0ZScsICckaW5qZWN0b3InLCAnJHVpYk1vZGFsU3RhY2snLFxuICBmdW5jdGlvbigkYW5pbWF0ZSwgJGluamVjdG9yLCAkbW9kYWxTdGFjaykge1xuICAgIHJldHVybiB7XG4gICAgICByZXN0cmljdDogJ0EnLFxuICAgICAgY29tcGlsZTogZnVuY3Rpb24odEVsZW1lbnQsIHRBdHRycykge1xuICAgICAgICB0RWxlbWVudC5hZGRDbGFzcyh0QXR0cnMuYmFja2Ryb3BDbGFzcyk7XG4gICAgICAgIHJldHVybiBsaW5rRm47XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGxpbmtGbihzY29wZSwgZWxlbWVudCwgYXR0cnMpIHtcbiAgICAgIGlmIChhdHRycy5tb2RhbEluQ2xhc3MpIHtcbiAgICAgICAgJGFuaW1hdGUuYWRkQ2xhc3MoZWxlbWVudCwgYXR0cnMubW9kYWxJbkNsYXNzKTtcblxuICAgICAgICBzY29wZS4kb24oJG1vZGFsU3RhY2suTk9XX0NMT1NJTkdfRVZFTlQsIGZ1bmN0aW9uKGUsIHNldElzQXN5bmMpIHtcbiAgICAgICAgICB2YXIgZG9uZSA9IHNldElzQXN5bmMoKTtcbiAgICAgICAgICBpZiAoc2NvcGUubW9kYWxPcHRpb25zLmFuaW1hdGlvbikge1xuICAgICAgICAgICAgJGFuaW1hdGUucmVtb3ZlQ2xhc3MoZWxlbWVudCwgYXR0cnMubW9kYWxJbkNsYXNzKS50aGVuKGRvbmUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKVxuXG4gIC5kaXJlY3RpdmUoJ3VpYk1vZGFsV2luZG93JywgWyckdWliTW9kYWxTdGFjaycsICckcScsICckYW5pbWF0ZUNzcycsICckZG9jdW1lbnQnLFxuICBmdW5jdGlvbigkbW9kYWxTdGFjaywgJHEsICRhbmltYXRlQ3NzLCAkZG9jdW1lbnQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc2NvcGU6IHtcbiAgICAgICAgaW5kZXg6ICdAJ1xuICAgICAgfSxcbiAgICAgIHJlc3RyaWN0OiAnQScsXG4gICAgICB0cmFuc2NsdWRlOiB0cnVlLFxuICAgICAgdGVtcGxhdGVVcmw6IGZ1bmN0aW9uKHRFbGVtZW50LCB0QXR0cnMpIHtcbiAgICAgICAgcmV0dXJuIHRBdHRycy50ZW1wbGF0ZVVybCB8fCAndWliL3RlbXBsYXRlL21vZGFsL3dpbmRvdy5odG1sJztcbiAgICAgIH0sXG4gICAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cnMpIHtcbiAgICAgICAgZWxlbWVudC5hZGRDbGFzcyhhdHRycy53aW5kb3dUb3BDbGFzcyB8fCAnJyk7XG4gICAgICAgIHNjb3BlLnNpemUgPSBhdHRycy5zaXplO1xuXG4gICAgICAgIHNjb3BlLmNsb3NlID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgICAgdmFyIG1vZGFsID0gJG1vZGFsU3RhY2suZ2V0VG9wKCk7XG4gICAgICAgICAgaWYgKG1vZGFsICYmIG1vZGFsLnZhbHVlLmJhY2tkcm9wICYmXG4gICAgICAgICAgICBtb2RhbC52YWx1ZS5iYWNrZHJvcCAhPT0gJ3N0YXRpYycgJiZcbiAgICAgICAgICAgIGV2dC50YXJnZXQgPT09IGV2dC5jdXJyZW50VGFyZ2V0KSB7XG4gICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICRtb2RhbFN0YWNrLmRpc21pc3MobW9kYWwua2V5LCAnYmFja2Ryb3AgY2xpY2snKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gbW92ZWQgZnJvbSB0ZW1wbGF0ZSB0byBmaXggaXNzdWUgIzIyODBcbiAgICAgICAgZWxlbWVudC5vbignY2xpY2snLCBzY29wZS5jbG9zZSk7XG5cbiAgICAgICAgLy8gVGhpcyBwcm9wZXJ0eSBpcyBvbmx5IGFkZGVkIHRvIHRoZSBzY29wZSBmb3IgdGhlIHB1cnBvc2Ugb2YgZGV0ZWN0aW5nIHdoZW4gdGhpcyBkaXJlY3RpdmUgaXMgcmVuZGVyZWQuXG4gICAgICAgIC8vIFdlIGNhbiBkZXRlY3QgdGhhdCBieSB1c2luZyB0aGlzIHByb3BlcnR5IGluIHRoZSB0ZW1wbGF0ZSBhc3NvY2lhdGVkIHdpdGggdGhpcyBkaXJlY3RpdmUgYW5kIHRoZW4gdXNlXG4gICAgICAgIC8vIHtAbGluayBBdHRyaWJ1dGUjJG9ic2VydmV9IG9uIGl0LiBGb3IgbW9yZSBkZXRhaWxzIHBsZWFzZSBzZWUge0BsaW5rIFRhYmxlQ29sdW1uUmVzaXplfS5cbiAgICAgICAgc2NvcGUuJGlzUmVuZGVyZWQgPSB0cnVlO1xuXG4gICAgICAgIC8vIERlZmVycmVkIG9iamVjdCB0aGF0IHdpbGwgYmUgcmVzb2x2ZWQgd2hlbiB0aGlzIG1vZGFsIGlzIHJlbmRlcmVkLlxuICAgICAgICB2YXIgbW9kYWxSZW5kZXJEZWZlck9iaiA9ICRxLmRlZmVyKCk7XG4gICAgICAgIC8vIFJlc29sdmUgcmVuZGVyIHByb21pc2UgcG9zdC1kaWdlc3RcbiAgICAgICAgc2NvcGUuJCRwb3N0RGlnZXN0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIG1vZGFsUmVuZGVyRGVmZXJPYmoucmVzb2x2ZSgpO1xuICAgICAgICB9KTtcblxuICAgICAgICBtb2RhbFJlbmRlckRlZmVyT2JqLnByb21pc2UudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgYW5pbWF0aW9uUHJvbWlzZSA9IG51bGw7XG5cbiAgICAgICAgICBpZiAoYXR0cnMubW9kYWxJbkNsYXNzKSB7XG4gICAgICAgICAgICBhbmltYXRpb25Qcm9taXNlID0gJGFuaW1hdGVDc3MoZWxlbWVudCwge1xuICAgICAgICAgICAgICBhZGRDbGFzczogYXR0cnMubW9kYWxJbkNsYXNzXG4gICAgICAgICAgICB9KS5zdGFydCgpO1xuXG4gICAgICAgICAgICBzY29wZS4kb24oJG1vZGFsU3RhY2suTk9XX0NMT1NJTkdfRVZFTlQsIGZ1bmN0aW9uKGUsIHNldElzQXN5bmMpIHtcbiAgICAgICAgICAgICAgdmFyIGRvbmUgPSBzZXRJc0FzeW5jKCk7XG4gICAgICAgICAgICAgICRhbmltYXRlQ3NzKGVsZW1lbnQsIHtcbiAgICAgICAgICAgICAgICByZW1vdmVDbGFzczogYXR0cnMubW9kYWxJbkNsYXNzXG4gICAgICAgICAgICAgIH0pLnN0YXJ0KCkudGhlbihkb25lKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuXG4gICAgICAgICAgJHEud2hlbihhbmltYXRpb25Qcm9taXNlKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gTm90aWZ5IHtAbGluayAkbW9kYWxTdGFja30gdGhhdCBtb2RhbCBpcyByZW5kZXJlZC5cbiAgICAgICAgICAgIHZhciBtb2RhbCA9ICRtb2RhbFN0YWNrLmdldFRvcCgpO1xuICAgICAgICAgICAgaWYgKG1vZGFsKSB7XG4gICAgICAgICAgICAgICRtb2RhbFN0YWNrLm1vZGFsUmVuZGVyZWQobW9kYWwua2V5KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJZiBzb21ldGhpbmcgd2l0aGluIHRoZSBmcmVzaGx5LW9wZW5lZCBtb2RhbCBhbHJlYWR5IGhhcyBmb2N1cyAocGVyaGFwcyB2aWEgYVxuICAgICAgICAgICAgICogZGlyZWN0aXZlIHRoYXQgY2F1c2VzIGZvY3VzKSB0aGVuIHRoZXJlJ3Mgbm8gbmVlZCB0byB0cnkgdG8gZm9jdXMgYW55dGhpbmcuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmICghKCRkb2N1bWVudFswXS5hY3RpdmVFbGVtZW50ICYmIGVsZW1lbnRbMF0uY29udGFpbnMoJGRvY3VtZW50WzBdLmFjdGl2ZUVsZW1lbnQpKSkge1xuICAgICAgICAgICAgICB2YXIgaW5wdXRXaXRoQXV0b2ZvY3VzID0gZWxlbWVudFswXS5xdWVyeVNlbGVjdG9yKCdbYXV0b2ZvY3VzXScpO1xuICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICogQXV0by1mb2N1c2luZyBvZiBhIGZyZXNobHktb3BlbmVkIG1vZGFsIGVsZW1lbnQgY2F1c2VzIGFueSBjaGlsZCBlbGVtZW50c1xuICAgICAgICAgICAgICAgKiB3aXRoIHRoZSBhdXRvZm9jdXMgYXR0cmlidXRlIHRvIGxvc2UgZm9jdXMuIFRoaXMgaXMgYW4gaXNzdWUgb24gdG91Y2hcbiAgICAgICAgICAgICAgICogYmFzZWQgZGV2aWNlcyB3aGljaCB3aWxsIHNob3cgYW5kIHRoZW4gaGlkZSB0aGUgb25zY3JlZW4ga2V5Ym9hcmQuXG4gICAgICAgICAgICAgICAqIEF0dGVtcHRzIHRvIHJlZm9jdXMgdGhlIGF1dG9mb2N1cyBlbGVtZW50IHZpYSBKYXZhU2NyaXB0IHdpbGwgbm90IHJlb3BlblxuICAgICAgICAgICAgICAgKiB0aGUgb25zY3JlZW4ga2V5Ym9hcmQuIEZpeGVkIGJ5IHVwZGF0ZWQgdGhlIGZvY3VzaW5nIGxvZ2ljIHRvIG9ubHkgYXV0b2ZvY3VzXG4gICAgICAgICAgICAgICAqIHRoZSBtb2RhbCBlbGVtZW50IGlmIHRoZSBtb2RhbCBkb2VzIG5vdCBjb250YWluIGFuIGF1dG9mb2N1cyBlbGVtZW50LlxuICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgaWYgKGlucHV0V2l0aEF1dG9mb2N1cykge1xuICAgICAgICAgICAgICAgIGlucHV0V2l0aEF1dG9mb2N1cy5mb2N1cygpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVsZW1lbnRbMF0uZm9jdXMoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICB9XSlcblxuICAuZGlyZWN0aXZlKCd1aWJNb2RhbEFuaW1hdGlvbkNsYXNzJywgZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbXBpbGU6IGZ1bmN0aW9uKHRFbGVtZW50LCB0QXR0cnMpIHtcbiAgICAgICAgaWYgKHRBdHRycy5tb2RhbEFuaW1hdGlvbikge1xuICAgICAgICAgIHRFbGVtZW50LmFkZENsYXNzKHRBdHRycy51aWJNb2RhbEFuaW1hdGlvbkNsYXNzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH0pXG5cbiAgLmRpcmVjdGl2ZSgndWliTW9kYWxUcmFuc2NsdWRlJywgWyckYW5pbWF0ZScsIGZ1bmN0aW9uKCRhbmltYXRlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRycywgY29udHJvbGxlciwgdHJhbnNjbHVkZSkge1xuICAgICAgICB0cmFuc2NsdWRlKHNjb3BlLiRwYXJlbnQsIGZ1bmN0aW9uKGNsb25lKSB7XG4gICAgICAgICAgZWxlbWVudC5lbXB0eSgpO1xuICAgICAgICAgICRhbmltYXRlLmVudGVyKGNsb25lLCBlbGVtZW50KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgfV0pXG5cbiAgLmZhY3RvcnkoJyR1aWJNb2RhbFN0YWNrJywgWyckYW5pbWF0ZScsICckYW5pbWF0ZUNzcycsICckZG9jdW1lbnQnLFxuICAgICckY29tcGlsZScsICckcm9vdFNjb3BlJywgJyRxJywgJyQkbXVsdGlNYXAnLCAnJCRzdGFja2VkTWFwJywgJyR1aWJQb3NpdGlvbicsXG4gICAgZnVuY3Rpb24oJGFuaW1hdGUsICRhbmltYXRlQ3NzLCAkZG9jdW1lbnQsICRjb21waWxlLCAkcm9vdFNjb3BlLCAkcSwgJCRtdWx0aU1hcCwgJCRzdGFja2VkTWFwLCAkdWliUG9zaXRpb24pIHtcbiAgICAgIHZhciBPUEVORURfTU9EQUxfQ0xBU1MgPSAnbW9kYWwtb3Blbic7XG5cbiAgICAgIHZhciBiYWNrZHJvcERvbUVsLCBiYWNrZHJvcFNjb3BlO1xuICAgICAgdmFyIG9wZW5lZFdpbmRvd3MgPSAkJHN0YWNrZWRNYXAuY3JlYXRlTmV3KCk7XG4gICAgICB2YXIgb3BlbmVkQ2xhc3NlcyA9ICQkbXVsdGlNYXAuY3JlYXRlTmV3KCk7XG4gICAgICB2YXIgJG1vZGFsU3RhY2sgPSB7XG4gICAgICAgIE5PV19DTE9TSU5HX0VWRU5UOiAnbW9kYWwuc3RhY2subm93LWNsb3NpbmcnXG4gICAgICB9O1xuICAgICAgdmFyIHRvcE1vZGFsSW5kZXggPSAwO1xuICAgICAgdmFyIHByZXZpb3VzVG9wT3BlbmVkTW9kYWwgPSBudWxsO1xuICAgICAgdmFyIEFSSUFfSElEREVOX0FUVFJJQlVURV9OQU1FID0gJ2RhdGEtYm9vdHN0cmFwLW1vZGFsLWFyaWEtaGlkZGVuLWNvdW50JztcblxuICAgICAgLy9Nb2RhbCBmb2N1cyBiZWhhdmlvclxuICAgICAgdmFyIHRhYmJhYmxlU2VsZWN0b3IgPSAnYVtocmVmXSwgYXJlYVtocmVmXSwgaW5wdXQ6bm90KFtkaXNhYmxlZF0pOm5vdChbdGFiaW5kZXg9XFwnLTFcXCddKSwgJyArXG4gICAgICAgICdidXR0b246bm90KFtkaXNhYmxlZF0pOm5vdChbdGFiaW5kZXg9XFwnLTFcXCddKSxzZWxlY3Q6bm90KFtkaXNhYmxlZF0pOm5vdChbdGFiaW5kZXg9XFwnLTFcXCddKSwgdGV4dGFyZWE6bm90KFtkaXNhYmxlZF0pOm5vdChbdGFiaW5kZXg9XFwnLTFcXCddKSwgJyArXG4gICAgICAgICdpZnJhbWUsIG9iamVjdCwgZW1iZWQsICpbdGFiaW5kZXhdOm5vdChbdGFiaW5kZXg9XFwnLTFcXCddKSwgKltjb250ZW50ZWRpdGFibGU9dHJ1ZV0nO1xuICAgICAgdmFyIHNjcm9sbGJhclBhZGRpbmc7XG4gICAgICB2YXIgU05BS0VfQ0FTRV9SRUdFWFAgPSAvW0EtWl0vZztcblxuICAgICAgLy8gVE9ETzogZXh0cmFjdCBpbnRvIGNvbW1vbiBkZXBlbmRlbmN5IHdpdGggdG9vbHRpcFxuICAgICAgZnVuY3Rpb24gc25ha2VfY2FzZShuYW1lKSB7XG4gICAgICAgIHZhciBzZXBhcmF0b3IgPSAnLSc7XG4gICAgICAgIHJldHVybiBuYW1lLnJlcGxhY2UoU05BS0VfQ0FTRV9SRUdFWFAsIGZ1bmN0aW9uKGxldHRlciwgcG9zKSB7XG4gICAgICAgICAgcmV0dXJuIChwb3MgPyBzZXBhcmF0b3IgOiAnJykgKyBsZXR0ZXIudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGlzVmlzaWJsZShlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiAhIShlbGVtZW50Lm9mZnNldFdpZHRoIHx8XG4gICAgICAgICAgZWxlbWVudC5vZmZzZXRIZWlnaHQgfHxcbiAgICAgICAgICBlbGVtZW50LmdldENsaWVudFJlY3RzKCkubGVuZ3RoKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gYmFja2Ryb3BJbmRleCgpIHtcbiAgICAgICAgdmFyIHRvcEJhY2tkcm9wSW5kZXggPSAtMTtcbiAgICAgICAgdmFyIG9wZW5lZCA9IG9wZW5lZFdpbmRvd3Mua2V5cygpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9wZW5lZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChvcGVuZWRXaW5kb3dzLmdldChvcGVuZWRbaV0pLnZhbHVlLmJhY2tkcm9wKSB7XG4gICAgICAgICAgICB0b3BCYWNrZHJvcEluZGV4ID0gaTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiBhbnkgYmFja2Ryb3AgZXhpc3QsIGVuc3VyZSB0aGF0IGl0J3MgaW5kZXggaXMgYWx3YXlzXG4gICAgICAgIC8vIHJpZ2h0IGJlbG93IHRoZSB0b3AgbW9kYWxcbiAgICAgICAgaWYgKHRvcEJhY2tkcm9wSW5kZXggPiAtMSAmJiB0b3BCYWNrZHJvcEluZGV4IDwgdG9wTW9kYWxJbmRleCkge1xuICAgICAgICAgIHRvcEJhY2tkcm9wSW5kZXggPSB0b3BNb2RhbEluZGV4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b3BCYWNrZHJvcEluZGV4O1xuICAgICAgfVxuXG4gICAgICAkcm9vdFNjb3BlLiR3YXRjaChiYWNrZHJvcEluZGV4LCBmdW5jdGlvbihuZXdCYWNrZHJvcEluZGV4KSB7XG4gICAgICAgIGlmIChiYWNrZHJvcFNjb3BlKSB7XG4gICAgICAgICAgYmFja2Ryb3BTY29wZS5pbmRleCA9IG5ld0JhY2tkcm9wSW5kZXg7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBmdW5jdGlvbiByZW1vdmVNb2RhbFdpbmRvdyhtb2RhbEluc3RhbmNlLCBlbGVtZW50VG9SZWNlaXZlRm9jdXMpIHtcbiAgICAgICAgdmFyIG1vZGFsV2luZG93ID0gb3BlbmVkV2luZG93cy5nZXQobW9kYWxJbnN0YW5jZSkudmFsdWU7XG4gICAgICAgIHZhciBhcHBlbmRUb0VsZW1lbnQgPSBtb2RhbFdpbmRvdy5hcHBlbmRUbztcblxuICAgICAgICAvL2NsZWFuIHVwIHRoZSBzdGFja1xuICAgICAgICBvcGVuZWRXaW5kb3dzLnJlbW92ZShtb2RhbEluc3RhbmNlKTtcbiAgICAgICAgcHJldmlvdXNUb3BPcGVuZWRNb2RhbCA9IG9wZW5lZFdpbmRvd3MudG9wKCk7XG4gICAgICAgIGlmIChwcmV2aW91c1RvcE9wZW5lZE1vZGFsKSB7XG4gICAgICAgICAgdG9wTW9kYWxJbmRleCA9IHBhcnNlSW50KHByZXZpb3VzVG9wT3BlbmVkTW9kYWwudmFsdWUubW9kYWxEb21FbC5hdHRyKCdpbmRleCcpLCAxMCk7XG4gICAgICAgIH1cblxuICAgICAgICByZW1vdmVBZnRlckFuaW1hdGUobW9kYWxXaW5kb3cubW9kYWxEb21FbCwgbW9kYWxXaW5kb3cubW9kYWxTY29wZSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIG1vZGFsQm9keUNsYXNzID0gbW9kYWxXaW5kb3cub3BlbmVkQ2xhc3MgfHwgT1BFTkVEX01PREFMX0NMQVNTO1xuICAgICAgICAgIG9wZW5lZENsYXNzZXMucmVtb3ZlKG1vZGFsQm9keUNsYXNzLCBtb2RhbEluc3RhbmNlKTtcbiAgICAgICAgICB2YXIgYXJlQW55T3BlbiA9IG9wZW5lZENsYXNzZXMuaGFzS2V5KG1vZGFsQm9keUNsYXNzKTtcbiAgICAgICAgICBhcHBlbmRUb0VsZW1lbnQudG9nZ2xlQ2xhc3MobW9kYWxCb2R5Q2xhc3MsIGFyZUFueU9wZW4pO1xuICAgICAgICAgIGlmICghYXJlQW55T3BlbiAmJiBzY3JvbGxiYXJQYWRkaW5nICYmIHNjcm9sbGJhclBhZGRpbmcuaGVpZ2h0T3ZlcmZsb3cgJiYgc2Nyb2xsYmFyUGFkZGluZy5zY3JvbGxiYXJXaWR0aCkge1xuICAgICAgICAgICAgaWYgKHNjcm9sbGJhclBhZGRpbmcub3JpZ2luYWxSaWdodCkge1xuICAgICAgICAgICAgICBhcHBlbmRUb0VsZW1lbnQuY3NzKHtwYWRkaW5nUmlnaHQ6IHNjcm9sbGJhclBhZGRpbmcub3JpZ2luYWxSaWdodCArICdweCd9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGFwcGVuZFRvRWxlbWVudC5jc3Moe3BhZGRpbmdSaWdodDogJyd9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNjcm9sbGJhclBhZGRpbmcgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0b2dnbGVUb3BXaW5kb3dDbGFzcyh0cnVlKTtcbiAgICAgICAgfSwgbW9kYWxXaW5kb3cuY2xvc2VkRGVmZXJyZWQpO1xuICAgICAgICBjaGVja1JlbW92ZUJhY2tkcm9wKCk7XG5cbiAgICAgICAgLy9tb3ZlIGZvY3VzIHRvIHNwZWNpZmllZCBlbGVtZW50IGlmIGF2YWlsYWJsZSwgb3IgZWxzZSB0byBib2R5XG4gICAgICAgIGlmIChlbGVtZW50VG9SZWNlaXZlRm9jdXMgJiYgZWxlbWVudFRvUmVjZWl2ZUZvY3VzLmZvY3VzKSB7XG4gICAgICAgICAgZWxlbWVudFRvUmVjZWl2ZUZvY3VzLmZvY3VzKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoYXBwZW5kVG9FbGVtZW50LmZvY3VzKSB7XG4gICAgICAgICAgYXBwZW5kVG9FbGVtZW50LmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQWRkIG9yIHJlbW92ZSBcIndpbmRvd1RvcENsYXNzXCIgZnJvbSB0aGUgdG9wIHdpbmRvdyBpbiB0aGUgc3RhY2tcbiAgICAgIGZ1bmN0aW9uIHRvZ2dsZVRvcFdpbmRvd0NsYXNzKHRvZ2dsZVN3aXRjaCkge1xuICAgICAgICB2YXIgbW9kYWxXaW5kb3c7XG5cbiAgICAgICAgaWYgKG9wZW5lZFdpbmRvd3MubGVuZ3RoKCkgPiAwKSB7XG4gICAgICAgICAgbW9kYWxXaW5kb3cgPSBvcGVuZWRXaW5kb3dzLnRvcCgpLnZhbHVlO1xuICAgICAgICAgIG1vZGFsV2luZG93Lm1vZGFsRG9tRWwudG9nZ2xlQ2xhc3MobW9kYWxXaW5kb3cud2luZG93VG9wQ2xhc3MgfHwgJycsIHRvZ2dsZVN3aXRjaCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gY2hlY2tSZW1vdmVCYWNrZHJvcCgpIHtcbiAgICAgICAgLy9yZW1vdmUgYmFja2Ryb3AgaWYgbm8gbG9uZ2VyIG5lZWRlZFxuICAgICAgICBpZiAoYmFja2Ryb3BEb21FbCAmJiBiYWNrZHJvcEluZGV4KCkgPT09IC0xKSB7XG4gICAgICAgICAgdmFyIGJhY2tkcm9wU2NvcGVSZWYgPSBiYWNrZHJvcFNjb3BlO1xuICAgICAgICAgIHJlbW92ZUFmdGVyQW5pbWF0ZShiYWNrZHJvcERvbUVsLCBiYWNrZHJvcFNjb3BlLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGJhY2tkcm9wU2NvcGVSZWYgPSBudWxsO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJhY2tkcm9wRG9tRWwgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgYmFja2Ryb3BTY29wZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiByZW1vdmVBZnRlckFuaW1hdGUoZG9tRWwsIHNjb3BlLCBkb25lLCBjbG9zZWREZWZlcnJlZCkge1xuICAgICAgICB2YXIgYXN5bmNEZWZlcnJlZDtcbiAgICAgICAgdmFyIGFzeW5jUHJvbWlzZSA9IG51bGw7XG4gICAgICAgIHZhciBzZXRJc0FzeW5jID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKCFhc3luY0RlZmVycmVkKSB7XG4gICAgICAgICAgICBhc3luY0RlZmVycmVkID0gJHEuZGVmZXIoKTtcbiAgICAgICAgICAgIGFzeW5jUHJvbWlzZSA9IGFzeW5jRGVmZXJyZWQucHJvbWlzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gYXN5bmNEb25lKCkge1xuICAgICAgICAgICAgYXN5bmNEZWZlcnJlZC5yZXNvbHZlKCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgc2NvcGUuJGJyb2FkY2FzdCgkbW9kYWxTdGFjay5OT1dfQ0xPU0lOR19FVkVOVCwgc2V0SXNBc3luYyk7XG5cbiAgICAgICAgLy8gTm90ZSB0aGF0IGl0J3MgaW50ZW50aW9uYWwgdGhhdCBhc3luY1Byb21pc2UgbWlnaHQgYmUgbnVsbC5cbiAgICAgICAgLy8gVGhhdCdzIHdoZW4gc2V0SXNBc3luYyBoYXMgbm90IGJlZW4gY2FsbGVkIGR1cmluZyB0aGVcbiAgICAgICAgLy8gTk9XX0NMT1NJTkdfRVZFTlQgYnJvYWRjYXN0LlxuICAgICAgICByZXR1cm4gJHEud2hlbihhc3luY1Byb21pc2UpLnRoZW4oYWZ0ZXJBbmltYXRpbmcpO1xuXG4gICAgICAgIGZ1bmN0aW9uIGFmdGVyQW5pbWF0aW5nKCkge1xuICAgICAgICAgIGlmIChhZnRlckFuaW1hdGluZy5kb25lKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGFmdGVyQW5pbWF0aW5nLmRvbmUgPSB0cnVlO1xuXG4gICAgICAgICAgJGFuaW1hdGUubGVhdmUoZG9tRWwpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRvbUVsLnJlbW92ZSgpO1xuICAgICAgICAgICAgaWYgKGNsb3NlZERlZmVycmVkKSB7XG4gICAgICAgICAgICAgIGNsb3NlZERlZmVycmVkLnJlc29sdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHNjb3BlLiRkZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgJGRvY3VtZW50Lm9uKCdrZXlkb3duJywga2V5ZG93bkxpc3RlbmVyKTtcblxuICAgICAgJHJvb3RTY29wZS4kb24oJyRkZXN0cm95JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICRkb2N1bWVudC5vZmYoJ2tleWRvd24nLCBrZXlkb3duTGlzdGVuZXIpO1xuICAgICAgfSk7XG5cbiAgICAgIGZ1bmN0aW9uIGtleWRvd25MaXN0ZW5lcihldnQpIHtcbiAgICAgICAgaWYgKGV2dC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xuICAgICAgICAgIHJldHVybiBldnQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbW9kYWwgPSBvcGVuZWRXaW5kb3dzLnRvcCgpO1xuICAgICAgICBpZiAobW9kYWwpIHtcbiAgICAgICAgICBzd2l0Y2ggKGV2dC53aGljaCkge1xuICAgICAgICAgICAgY2FzZSAyNzoge1xuICAgICAgICAgICAgICBpZiAobW9kYWwudmFsdWUua2V5Ym9hcmQpIHtcbiAgICAgICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRhcHBseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICRtb2RhbFN0YWNrLmRpc21pc3MobW9kYWwua2V5LCAnZXNjYXBlIGtleSBwcmVzcycpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSA5OiB7XG4gICAgICAgICAgICAgIHZhciBsaXN0ID0gJG1vZGFsU3RhY2subG9hZEZvY3VzRWxlbWVudExpc3QobW9kYWwpO1xuICAgICAgICAgICAgICB2YXIgZm9jdXNDaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgICAgICAgIGlmIChldnQuc2hpZnRLZXkpIHtcbiAgICAgICAgICAgICAgICBpZiAoJG1vZGFsU3RhY2suaXNGb2N1c0luRmlyc3RJdGVtKGV2dCwgbGlzdCkgfHwgJG1vZGFsU3RhY2suaXNNb2RhbEZvY3VzZWQoZXZ0LCBtb2RhbCkpIHtcbiAgICAgICAgICAgICAgICAgIGZvY3VzQ2hhbmdlZCA9ICRtb2RhbFN0YWNrLmZvY3VzTGFzdEZvY3VzYWJsZUVsZW1lbnQobGlzdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICgkbW9kYWxTdGFjay5pc0ZvY3VzSW5MYXN0SXRlbShldnQsIGxpc3QpKSB7XG4gICAgICAgICAgICAgICAgICBmb2N1c0NoYW5nZWQgPSAkbW9kYWxTdGFjay5mb2N1c0ZpcnN0Rm9jdXNhYmxlRWxlbWVudChsaXN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoZm9jdXNDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgICRtb2RhbFN0YWNrLm9wZW4gPSBmdW5jdGlvbihtb2RhbEluc3RhbmNlLCBtb2RhbCkge1xuICAgICAgICB2YXIgbW9kYWxPcGVuZXIgPSAkZG9jdW1lbnRbMF0uYWN0aXZlRWxlbWVudCxcbiAgICAgICAgICBtb2RhbEJvZHlDbGFzcyA9IG1vZGFsLm9wZW5lZENsYXNzIHx8IE9QRU5FRF9NT0RBTF9DTEFTUztcblxuICAgICAgICB0b2dnbGVUb3BXaW5kb3dDbGFzcyhmYWxzZSk7XG5cbiAgICAgICAgLy8gU3RvcmUgdGhlIGN1cnJlbnQgdG9wIGZpcnN0LCB0byBkZXRlcm1pbmUgd2hhdCBpbmRleCB3ZSBvdWdodCB0byB1c2VcbiAgICAgICAgLy8gZm9yIHRoZSBjdXJyZW50IHRvcCBtb2RhbFxuICAgICAgICBwcmV2aW91c1RvcE9wZW5lZE1vZGFsID0gb3BlbmVkV2luZG93cy50b3AoKTtcblxuICAgICAgICBvcGVuZWRXaW5kb3dzLmFkZChtb2RhbEluc3RhbmNlLCB7XG4gICAgICAgICAgZGVmZXJyZWQ6IG1vZGFsLmRlZmVycmVkLFxuICAgICAgICAgIHJlbmRlckRlZmVycmVkOiBtb2RhbC5yZW5kZXJEZWZlcnJlZCxcbiAgICAgICAgICBjbG9zZWREZWZlcnJlZDogbW9kYWwuY2xvc2VkRGVmZXJyZWQsXG4gICAgICAgICAgbW9kYWxTY29wZTogbW9kYWwuc2NvcGUsXG4gICAgICAgICAgYmFja2Ryb3A6IG1vZGFsLmJhY2tkcm9wLFxuICAgICAgICAgIGtleWJvYXJkOiBtb2RhbC5rZXlib2FyZCxcbiAgICAgICAgICBvcGVuZWRDbGFzczogbW9kYWwub3BlbmVkQ2xhc3MsXG4gICAgICAgICAgd2luZG93VG9wQ2xhc3M6IG1vZGFsLndpbmRvd1RvcENsYXNzLFxuICAgICAgICAgIGFuaW1hdGlvbjogbW9kYWwuYW5pbWF0aW9uLFxuICAgICAgICAgIGFwcGVuZFRvOiBtb2RhbC5hcHBlbmRUb1xuICAgICAgICB9KTtcblxuICAgICAgICBvcGVuZWRDbGFzc2VzLnB1dChtb2RhbEJvZHlDbGFzcywgbW9kYWxJbnN0YW5jZSk7XG5cbiAgICAgICAgdmFyIGFwcGVuZFRvRWxlbWVudCA9IG1vZGFsLmFwcGVuZFRvLFxuICAgICAgICAgICAgY3VyckJhY2tkcm9wSW5kZXggPSBiYWNrZHJvcEluZGV4KCk7XG5cbiAgICAgICAgaWYgKGN1cnJCYWNrZHJvcEluZGV4ID49IDAgJiYgIWJhY2tkcm9wRG9tRWwpIHtcbiAgICAgICAgICBiYWNrZHJvcFNjb3BlID0gJHJvb3RTY29wZS4kbmV3KHRydWUpO1xuICAgICAgICAgIGJhY2tkcm9wU2NvcGUubW9kYWxPcHRpb25zID0gbW9kYWw7XG4gICAgICAgICAgYmFja2Ryb3BTY29wZS5pbmRleCA9IGN1cnJCYWNrZHJvcEluZGV4O1xuICAgICAgICAgIGJhY2tkcm9wRG9tRWwgPSBhbmd1bGFyLmVsZW1lbnQoJzxkaXYgdWliLW1vZGFsLWJhY2tkcm9wPVwibW9kYWwtYmFja2Ryb3BcIj48L2Rpdj4nKTtcbiAgICAgICAgICBiYWNrZHJvcERvbUVsLmF0dHIoe1xuICAgICAgICAgICAgJ2NsYXNzJzogJ21vZGFsLWJhY2tkcm9wJyxcbiAgICAgICAgICAgICduZy1zdHlsZSc6ICd7XFwnei1pbmRleFxcJzogMTA0MCArIChpbmRleCAmJiAxIHx8IDApICsgaW5kZXgqMTB9JyxcbiAgICAgICAgICAgICd1aWItbW9kYWwtYW5pbWF0aW9uLWNsYXNzJzogJ2ZhZGUnLFxuICAgICAgICAgICAgJ21vZGFsLWluLWNsYXNzJzogJ2luJ1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmIChtb2RhbC5iYWNrZHJvcENsYXNzKSB7XG4gICAgICAgICAgICBiYWNrZHJvcERvbUVsLmFkZENsYXNzKG1vZGFsLmJhY2tkcm9wQ2xhc3MpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChtb2RhbC5hbmltYXRpb24pIHtcbiAgICAgICAgICAgIGJhY2tkcm9wRG9tRWwuYXR0cignbW9kYWwtYW5pbWF0aW9uJywgJ3RydWUnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgJGNvbXBpbGUoYmFja2Ryb3BEb21FbCkoYmFja2Ryb3BTY29wZSk7XG4gICAgICAgICAgJGFuaW1hdGUuZW50ZXIoYmFja2Ryb3BEb21FbCwgYXBwZW5kVG9FbGVtZW50KTtcbiAgICAgICAgICBpZiAoJHVpYlBvc2l0aW9uLmlzU2Nyb2xsYWJsZShhcHBlbmRUb0VsZW1lbnQpKSB7XG4gICAgICAgICAgICBzY3JvbGxiYXJQYWRkaW5nID0gJHVpYlBvc2l0aW9uLnNjcm9sbGJhclBhZGRpbmcoYXBwZW5kVG9FbGVtZW50KTtcbiAgICAgICAgICAgIGlmIChzY3JvbGxiYXJQYWRkaW5nLmhlaWdodE92ZXJmbG93ICYmIHNjcm9sbGJhclBhZGRpbmcuc2Nyb2xsYmFyV2lkdGgpIHtcbiAgICAgICAgICAgICAgYXBwZW5kVG9FbGVtZW50LmNzcyh7cGFkZGluZ1JpZ2h0OiBzY3JvbGxiYXJQYWRkaW5nLnJpZ2h0ICsgJ3B4J30pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjb250ZW50O1xuICAgICAgICBpZiAobW9kYWwuY29tcG9uZW50KSB7XG4gICAgICAgICAgY29udGVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoc25ha2VfY2FzZShtb2RhbC5jb21wb25lbnQubmFtZSkpO1xuICAgICAgICAgIGNvbnRlbnQgPSBhbmd1bGFyLmVsZW1lbnQoY29udGVudCk7XG4gICAgICAgICAgY29udGVudC5hdHRyKHtcbiAgICAgICAgICAgIHJlc29sdmU6ICckcmVzb2x2ZScsXG4gICAgICAgICAgICAnbW9kYWwtaW5zdGFuY2UnOiAnJHVpYk1vZGFsSW5zdGFuY2UnLFxuICAgICAgICAgICAgY2xvc2U6ICckY2xvc2UoJHZhbHVlKScsXG4gICAgICAgICAgICBkaXNtaXNzOiAnJGRpc21pc3MoJHZhbHVlKSdcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb250ZW50ID0gbW9kYWwuY29udGVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNldCB0aGUgdG9wIG1vZGFsIGluZGV4IGJhc2VkIG9uIHRoZSBpbmRleCBvZiB0aGUgcHJldmlvdXMgdG9wIG1vZGFsXG4gICAgICAgIHRvcE1vZGFsSW5kZXggPSBwcmV2aW91c1RvcE9wZW5lZE1vZGFsID8gcGFyc2VJbnQocHJldmlvdXNUb3BPcGVuZWRNb2RhbC52YWx1ZS5tb2RhbERvbUVsLmF0dHIoJ2luZGV4JyksIDEwKSArIDEgOiAwO1xuICAgICAgICB2YXIgYW5ndWxhckRvbUVsID0gYW5ndWxhci5lbGVtZW50KCc8ZGl2IHVpYi1tb2RhbC13aW5kb3c9XCJtb2RhbC13aW5kb3dcIj48L2Rpdj4nKTtcbiAgICAgICAgYW5ndWxhckRvbUVsLmF0dHIoe1xuICAgICAgICAgICdjbGFzcyc6ICdtb2RhbCcsXG4gICAgICAgICAgJ3RlbXBsYXRlLXVybCc6IG1vZGFsLndpbmRvd1RlbXBsYXRlVXJsLFxuICAgICAgICAgICd3aW5kb3ctdG9wLWNsYXNzJzogbW9kYWwud2luZG93VG9wQ2xhc3MsXG4gICAgICAgICAgJ3JvbGUnOiAnZGlhbG9nJyxcbiAgICAgICAgICAnYXJpYS1sYWJlbGxlZGJ5JzogbW9kYWwuYXJpYUxhYmVsbGVkQnksXG4gICAgICAgICAgJ2FyaWEtZGVzY3JpYmVkYnknOiBtb2RhbC5hcmlhRGVzY3JpYmVkQnksXG4gICAgICAgICAgJ3NpemUnOiBtb2RhbC5zaXplLFxuICAgICAgICAgICdpbmRleCc6IHRvcE1vZGFsSW5kZXgsXG4gICAgICAgICAgJ2FuaW1hdGUnOiAnYW5pbWF0ZScsXG4gICAgICAgICAgJ25nLXN0eWxlJzogJ3tcXCd6LWluZGV4XFwnOiAxMDUwICsgJCR0b3BNb2RhbEluZGV4KjEwLCBkaXNwbGF5OiBcXCdibG9ja1xcJ30nLFxuICAgICAgICAgICd0YWJpbmRleCc6IC0xLFxuICAgICAgICAgICd1aWItbW9kYWwtYW5pbWF0aW9uLWNsYXNzJzogJ2ZhZGUnLFxuICAgICAgICAgICdtb2RhbC1pbi1jbGFzcyc6ICdpbidcbiAgICAgICAgfSkuYXBwZW5kKGNvbnRlbnQpO1xuICAgICAgICBpZiAobW9kYWwud2luZG93Q2xhc3MpIHtcbiAgICAgICAgICBhbmd1bGFyRG9tRWwuYWRkQ2xhc3MobW9kYWwud2luZG93Q2xhc3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1vZGFsLmFuaW1hdGlvbikge1xuICAgICAgICAgIGFuZ3VsYXJEb21FbC5hdHRyKCdtb2RhbC1hbmltYXRpb24nLCAndHJ1ZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgYXBwZW5kVG9FbGVtZW50LmFkZENsYXNzKG1vZGFsQm9keUNsYXNzKTtcbiAgICAgICAgaWYgKG1vZGFsLnNjb3BlKSB7XG4gICAgICAgICAgLy8gd2UgbmVlZCB0byBleHBsaWNpdGx5IGFkZCB0aGUgbW9kYWwgaW5kZXggdG8gdGhlIG1vZGFsIHNjb3BlXG4gICAgICAgICAgLy8gYmVjYXVzZSBpdCBpcyBuZWVkZWQgYnkgbmdTdHlsZSB0byBjb21wdXRlIHRoZSB6SW5kZXggcHJvcGVydHkuXG4gICAgICAgICAgbW9kYWwuc2NvcGUuJCR0b3BNb2RhbEluZGV4ID0gdG9wTW9kYWxJbmRleDtcbiAgICAgICAgfVxuICAgICAgICAkYW5pbWF0ZS5lbnRlcigkY29tcGlsZShhbmd1bGFyRG9tRWwpKG1vZGFsLnNjb3BlKSwgYXBwZW5kVG9FbGVtZW50KTtcblxuICAgICAgICBvcGVuZWRXaW5kb3dzLnRvcCgpLnZhbHVlLm1vZGFsRG9tRWwgPSBhbmd1bGFyRG9tRWw7XG4gICAgICAgIG9wZW5lZFdpbmRvd3MudG9wKCkudmFsdWUubW9kYWxPcGVuZXIgPSBtb2RhbE9wZW5lcjtcblxuICAgICAgICBhcHBseUFyaWFIaWRkZW4oYW5ndWxhckRvbUVsKTtcblxuICAgICAgICBmdW5jdGlvbiBhcHBseUFyaWFIaWRkZW4oZWwpIHtcbiAgICAgICAgICBpZiAoIWVsIHx8IGVsWzBdLnRhZ05hbWUgPT09ICdCT0RZJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGdldFNpYmxpbmdzKGVsKS5mb3JFYWNoKGZ1bmN0aW9uKHNpYmxpbmcpIHtcbiAgICAgICAgICAgIHZhciBlbGVtSXNBbHJlYWR5SGlkZGVuID0gc2libGluZy5nZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJykgPT09ICd0cnVlJyxcbiAgICAgICAgICAgICAgYXJpYUhpZGRlbkNvdW50ID0gcGFyc2VJbnQoc2libGluZy5nZXRBdHRyaWJ1dGUoQVJJQV9ISURERU5fQVRUUklCVVRFX05BTUUpLCAxMCk7XG5cbiAgICAgICAgICAgIGlmICghYXJpYUhpZGRlbkNvdW50KSB7XG4gICAgICAgICAgICAgIGFyaWFIaWRkZW5Db3VudCA9IGVsZW1Jc0FscmVhZHlIaWRkZW4gPyAxIDogMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2libGluZy5zZXRBdHRyaWJ1dGUoQVJJQV9ISURERU5fQVRUUklCVVRFX05BTUUsIGFyaWFIaWRkZW5Db3VudCArIDEpO1xuICAgICAgICAgICAgc2libGluZy5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgJ3RydWUnKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHJldHVybiBhcHBseUFyaWFIaWRkZW4oZWwucGFyZW50KCkpO1xuXG4gICAgICAgICAgZnVuY3Rpb24gZ2V0U2libGluZ3MoZWwpIHtcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IGVsLnBhcmVudCgpID8gZWwucGFyZW50KCkuY2hpbGRyZW4oKSA6IFtdO1xuXG4gICAgICAgICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmZpbHRlci5jYWxsKGNoaWxkcmVuLCBmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICAgICAgICByZXR1cm4gY2hpbGQgIT09IGVsWzBdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBmdW5jdGlvbiBicm9hZGNhc3RDbG9zaW5nKG1vZGFsV2luZG93LCByZXN1bHRPclJlYXNvbiwgY2xvc2luZykge1xuICAgICAgICByZXR1cm4gIW1vZGFsV2luZG93LnZhbHVlLm1vZGFsU2NvcGUuJGJyb2FkY2FzdCgnbW9kYWwuY2xvc2luZycsIHJlc3VsdE9yUmVhc29uLCBjbG9zaW5nKS5kZWZhdWx0UHJldmVudGVkO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiB1bmhpZGVCYWNrZ3JvdW5kRWxlbWVudHMoKSB7XG4gICAgICAgIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwoXG4gICAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnWycgKyBBUklBX0hJRERFTl9BVFRSSUJVVEVfTkFNRSArICddJyksXG4gICAgICAgICAgZnVuY3Rpb24oaGlkZGVuRWwpIHtcbiAgICAgICAgICAgIHZhciBhcmlhSGlkZGVuQ291bnQgPSBwYXJzZUludChoaWRkZW5FbC5nZXRBdHRyaWJ1dGUoQVJJQV9ISURERU5fQVRUUklCVVRFX05BTUUpLCAxMCksXG4gICAgICAgICAgICAgIG5ld0hpZGRlbkNvdW50ID0gYXJpYUhpZGRlbkNvdW50IC0gMTtcbiAgICAgICAgICAgIGhpZGRlbkVsLnNldEF0dHJpYnV0ZShBUklBX0hJRERFTl9BVFRSSUJVVEVfTkFNRSwgbmV3SGlkZGVuQ291bnQpO1xuXG4gICAgICAgICAgICBpZiAoIW5ld0hpZGRlbkNvdW50KSB7XG4gICAgICAgICAgICAgIGhpZGRlbkVsLnJlbW92ZUF0dHJpYnV0ZShBUklBX0hJRERFTl9BVFRSSUJVVEVfTkFNRSk7XG4gICAgICAgICAgICAgIGhpZGRlbkVsLnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgICRtb2RhbFN0YWNrLmNsb3NlID0gZnVuY3Rpb24obW9kYWxJbnN0YW5jZSwgcmVzdWx0KSB7XG4gICAgICAgIHZhciBtb2RhbFdpbmRvdyA9IG9wZW5lZFdpbmRvd3MuZ2V0KG1vZGFsSW5zdGFuY2UpO1xuICAgICAgICB1bmhpZGVCYWNrZ3JvdW5kRWxlbWVudHMoKTtcbiAgICAgICAgaWYgKG1vZGFsV2luZG93ICYmIGJyb2FkY2FzdENsb3NpbmcobW9kYWxXaW5kb3csIHJlc3VsdCwgdHJ1ZSkpIHtcbiAgICAgICAgICBtb2RhbFdpbmRvdy52YWx1ZS5tb2RhbFNjb3BlLiQkdWliRGVzdHJ1Y3Rpb25TY2hlZHVsZWQgPSB0cnVlO1xuICAgICAgICAgIG1vZGFsV2luZG93LnZhbHVlLmRlZmVycmVkLnJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICByZW1vdmVNb2RhbFdpbmRvdyhtb2RhbEluc3RhbmNlLCBtb2RhbFdpbmRvdy52YWx1ZS5tb2RhbE9wZW5lcik7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gIW1vZGFsV2luZG93O1xuICAgICAgfTtcblxuICAgICAgJG1vZGFsU3RhY2suZGlzbWlzcyA9IGZ1bmN0aW9uKG1vZGFsSW5zdGFuY2UsIHJlYXNvbikge1xuICAgICAgICB2YXIgbW9kYWxXaW5kb3cgPSBvcGVuZWRXaW5kb3dzLmdldChtb2RhbEluc3RhbmNlKTtcbiAgICAgICAgdW5oaWRlQmFja2dyb3VuZEVsZW1lbnRzKCk7XG4gICAgICAgIGlmIChtb2RhbFdpbmRvdyAmJiBicm9hZGNhc3RDbG9zaW5nKG1vZGFsV2luZG93LCByZWFzb24sIGZhbHNlKSkge1xuICAgICAgICAgIG1vZGFsV2luZG93LnZhbHVlLm1vZGFsU2NvcGUuJCR1aWJEZXN0cnVjdGlvblNjaGVkdWxlZCA9IHRydWU7XG4gICAgICAgICAgbW9kYWxXaW5kb3cudmFsdWUuZGVmZXJyZWQucmVqZWN0KHJlYXNvbik7XG4gICAgICAgICAgcmVtb3ZlTW9kYWxXaW5kb3cobW9kYWxJbnN0YW5jZSwgbW9kYWxXaW5kb3cudmFsdWUubW9kYWxPcGVuZXIpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAhbW9kYWxXaW5kb3c7XG4gICAgICB9O1xuXG4gICAgICAkbW9kYWxTdGFjay5kaXNtaXNzQWxsID0gZnVuY3Rpb24ocmVhc29uKSB7XG4gICAgICAgIHZhciB0b3BNb2RhbCA9IHRoaXMuZ2V0VG9wKCk7XG4gICAgICAgIHdoaWxlICh0b3BNb2RhbCAmJiB0aGlzLmRpc21pc3ModG9wTW9kYWwua2V5LCByZWFzb24pKSB7XG4gICAgICAgICAgdG9wTW9kYWwgPSB0aGlzLmdldFRvcCgpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAkbW9kYWxTdGFjay5nZXRUb3AgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG9wZW5lZFdpbmRvd3MudG9wKCk7XG4gICAgICB9O1xuXG4gICAgICAkbW9kYWxTdGFjay5tb2RhbFJlbmRlcmVkID0gZnVuY3Rpb24obW9kYWxJbnN0YW5jZSkge1xuICAgICAgICB2YXIgbW9kYWxXaW5kb3cgPSBvcGVuZWRXaW5kb3dzLmdldChtb2RhbEluc3RhbmNlKTtcbiAgICAgICAgaWYgKG1vZGFsV2luZG93KSB7XG4gICAgICAgICAgbW9kYWxXaW5kb3cudmFsdWUucmVuZGVyRGVmZXJyZWQucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAkbW9kYWxTdGFjay5mb2N1c0ZpcnN0Rm9jdXNhYmxlRWxlbWVudCA9IGZ1bmN0aW9uKGxpc3QpIHtcbiAgICAgICAgaWYgKGxpc3QubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGxpc3RbMF0uZm9jdXMoKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9O1xuXG4gICAgICAkbW9kYWxTdGFjay5mb2N1c0xhc3RGb2N1c2FibGVFbGVtZW50ID0gZnVuY3Rpb24obGlzdCkge1xuICAgICAgICBpZiAobGlzdC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgbGlzdFtsaXN0Lmxlbmd0aCAtIDFdLmZvY3VzKCk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfTtcblxuICAgICAgJG1vZGFsU3RhY2suaXNNb2RhbEZvY3VzZWQgPSBmdW5jdGlvbihldnQsIG1vZGFsV2luZG93KSB7XG4gICAgICAgIGlmIChldnQgJiYgbW9kYWxXaW5kb3cpIHtcbiAgICAgICAgICB2YXIgbW9kYWxEb21FbCA9IG1vZGFsV2luZG93LnZhbHVlLm1vZGFsRG9tRWw7XG4gICAgICAgICAgaWYgKG1vZGFsRG9tRWwgJiYgbW9kYWxEb21FbC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiAoZXZ0LnRhcmdldCB8fCBldnQuc3JjRWxlbWVudCkgPT09IG1vZGFsRG9tRWxbMF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH07XG5cbiAgICAgICRtb2RhbFN0YWNrLmlzRm9jdXNJbkZpcnN0SXRlbSA9IGZ1bmN0aW9uKGV2dCwgbGlzdCkge1xuICAgICAgICBpZiAobGlzdC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgcmV0dXJuIChldnQudGFyZ2V0IHx8IGV2dC5zcmNFbGVtZW50KSA9PT0gbGlzdFswXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9O1xuXG4gICAgICAkbW9kYWxTdGFjay5pc0ZvY3VzSW5MYXN0SXRlbSA9IGZ1bmN0aW9uKGV2dCwgbGlzdCkge1xuICAgICAgICBpZiAobGlzdC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgcmV0dXJuIChldnQudGFyZ2V0IHx8IGV2dC5zcmNFbGVtZW50KSA9PT0gbGlzdFtsaXN0Lmxlbmd0aCAtIDFdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH07XG5cbiAgICAgICRtb2RhbFN0YWNrLmxvYWRGb2N1c0VsZW1lbnRMaXN0ID0gZnVuY3Rpb24obW9kYWxXaW5kb3cpIHtcbiAgICAgICAgaWYgKG1vZGFsV2luZG93KSB7XG4gICAgICAgICAgdmFyIG1vZGFsRG9tRTEgPSBtb2RhbFdpbmRvdy52YWx1ZS5tb2RhbERvbUVsO1xuICAgICAgICAgIGlmIChtb2RhbERvbUUxICYmIG1vZGFsRG9tRTEubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgZWxlbWVudHMgPSBtb2RhbERvbUUxWzBdLnF1ZXJ5U2VsZWN0b3JBbGwodGFiYmFibGVTZWxlY3Rvcik7XG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudHMgP1xuICAgICAgICAgICAgICBBcnJheS5wcm90b3R5cGUuZmlsdGVyLmNhbGwoZWxlbWVudHMsIGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNWaXNpYmxlKGVsZW1lbnQpO1xuICAgICAgICAgICAgICB9KSA6IGVsZW1lbnRzO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgcmV0dXJuICRtb2RhbFN0YWNrO1xuICAgIH1dKVxuXG4gIC5wcm92aWRlcignJHVpYk1vZGFsJywgZnVuY3Rpb24oKSB7XG4gICAgdmFyICRtb2RhbFByb3ZpZGVyID0ge1xuICAgICAgb3B0aW9uczoge1xuICAgICAgICBhbmltYXRpb246IHRydWUsXG4gICAgICAgIGJhY2tkcm9wOiB0cnVlLCAvL2NhbiBhbHNvIGJlIGZhbHNlIG9yICdzdGF0aWMnXG4gICAgICAgIGtleWJvYXJkOiB0cnVlXG4gICAgICB9LFxuICAgICAgJGdldDogWyckcm9vdFNjb3BlJywgJyRxJywgJyRkb2N1bWVudCcsICckdGVtcGxhdGVSZXF1ZXN0JywgJyRjb250cm9sbGVyJywgJyR1aWJSZXNvbHZlJywgJyR1aWJNb2RhbFN0YWNrJyxcbiAgICAgICAgZnVuY3Rpb24gKCRyb290U2NvcGUsICRxLCAkZG9jdW1lbnQsICR0ZW1wbGF0ZVJlcXVlc3QsICRjb250cm9sbGVyLCAkdWliUmVzb2x2ZSwgJG1vZGFsU3RhY2spIHtcbiAgICAgICAgICB2YXIgJG1vZGFsID0ge307XG5cbiAgICAgICAgICBmdW5jdGlvbiBnZXRUZW1wbGF0ZVByb21pc2Uob3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMudGVtcGxhdGUgPyAkcS53aGVuKG9wdGlvbnMudGVtcGxhdGUpIDpcbiAgICAgICAgICAgICAgJHRlbXBsYXRlUmVxdWVzdChhbmd1bGFyLmlzRnVuY3Rpb24ob3B0aW9ucy50ZW1wbGF0ZVVybCkgP1xuICAgICAgICAgICAgICAgIG9wdGlvbnMudGVtcGxhdGVVcmwoKSA6IG9wdGlvbnMudGVtcGxhdGVVcmwpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBwcm9taXNlQ2hhaW4gPSBudWxsO1xuICAgICAgICAgICRtb2RhbC5nZXRQcm9taXNlQ2hhaW4gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlQ2hhaW47XG4gICAgICAgICAgfTtcblxuICAgICAgICAgICRtb2RhbC5vcGVuID0gZnVuY3Rpb24obW9kYWxPcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgbW9kYWxSZXN1bHREZWZlcnJlZCA9ICRxLmRlZmVyKCk7XG4gICAgICAgICAgICB2YXIgbW9kYWxPcGVuZWREZWZlcnJlZCA9ICRxLmRlZmVyKCk7XG4gICAgICAgICAgICB2YXIgbW9kYWxDbG9zZWREZWZlcnJlZCA9ICRxLmRlZmVyKCk7XG4gICAgICAgICAgICB2YXIgbW9kYWxSZW5kZXJEZWZlcnJlZCA9ICRxLmRlZmVyKCk7XG5cbiAgICAgICAgICAgIC8vcHJlcGFyZSBhbiBpbnN0YW5jZSBvZiBhIG1vZGFsIHRvIGJlIGluamVjdGVkIGludG8gY29udHJvbGxlcnMgYW5kIHJldHVybmVkIHRvIGEgY2FsbGVyXG4gICAgICAgICAgICB2YXIgbW9kYWxJbnN0YW5jZSA9IHtcbiAgICAgICAgICAgICAgcmVzdWx0OiBtb2RhbFJlc3VsdERlZmVycmVkLnByb21pc2UsXG4gICAgICAgICAgICAgIG9wZW5lZDogbW9kYWxPcGVuZWREZWZlcnJlZC5wcm9taXNlLFxuICAgICAgICAgICAgICBjbG9zZWQ6IG1vZGFsQ2xvc2VkRGVmZXJyZWQucHJvbWlzZSxcbiAgICAgICAgICAgICAgcmVuZGVyZWQ6IG1vZGFsUmVuZGVyRGVmZXJyZWQucHJvbWlzZSxcbiAgICAgICAgICAgICAgY2xvc2U6IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJG1vZGFsU3RhY2suY2xvc2UobW9kYWxJbnN0YW5jZSwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZGlzbWlzczogZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiAkbW9kYWxTdGFjay5kaXNtaXNzKG1vZGFsSW5zdGFuY2UsIHJlYXNvbik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vbWVyZ2UgYW5kIGNsZWFuIHVwIG9wdGlvbnNcbiAgICAgICAgICAgIG1vZGFsT3B0aW9ucyA9IGFuZ3VsYXIuZXh0ZW5kKHt9LCAkbW9kYWxQcm92aWRlci5vcHRpb25zLCBtb2RhbE9wdGlvbnMpO1xuICAgICAgICAgICAgbW9kYWxPcHRpb25zLnJlc29sdmUgPSBtb2RhbE9wdGlvbnMucmVzb2x2ZSB8fCB7fTtcbiAgICAgICAgICAgIG1vZGFsT3B0aW9ucy5hcHBlbmRUbyA9IG1vZGFsT3B0aW9ucy5hcHBlbmRUbyB8fCAkZG9jdW1lbnQuZmluZCgnYm9keScpLmVxKDApO1xuXG4gICAgICAgICAgICBpZiAoIW1vZGFsT3B0aW9ucy5hcHBlbmRUby5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhcHBlbmRUbyBlbGVtZW50IG5vdCBmb3VuZC4gTWFrZSBzdXJlIHRoYXQgdGhlIGVsZW1lbnQgcGFzc2VkIGlzIGluIERPTS4nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy92ZXJpZnkgb3B0aW9uc1xuICAgICAgICAgICAgaWYgKCFtb2RhbE9wdGlvbnMuY29tcG9uZW50ICYmICFtb2RhbE9wdGlvbnMudGVtcGxhdGUgJiYgIW1vZGFsT3B0aW9ucy50ZW1wbGF0ZVVybCkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09uZSBvZiBjb21wb25lbnQgb3IgdGVtcGxhdGUgb3IgdGVtcGxhdGVVcmwgb3B0aW9ucyBpcyByZXF1aXJlZC4nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHRlbXBsYXRlQW5kUmVzb2x2ZVByb21pc2U7XG4gICAgICAgICAgICBpZiAobW9kYWxPcHRpb25zLmNvbXBvbmVudCkge1xuICAgICAgICAgICAgICB0ZW1wbGF0ZUFuZFJlc29sdmVQcm9taXNlID0gJHEud2hlbigkdWliUmVzb2x2ZS5yZXNvbHZlKG1vZGFsT3B0aW9ucy5yZXNvbHZlLCB7fSwgbnVsbCwgbnVsbCkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGVtcGxhdGVBbmRSZXNvbHZlUHJvbWlzZSA9XG4gICAgICAgICAgICAgICAgJHEuYWxsKFtnZXRUZW1wbGF0ZVByb21pc2UobW9kYWxPcHRpb25zKSwgJHVpYlJlc29sdmUucmVzb2x2ZShtb2RhbE9wdGlvbnMucmVzb2x2ZSwge30sIG51bGwsIG51bGwpXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHJlc29sdmVXaXRoVGVtcGxhdGUoKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0ZW1wbGF0ZUFuZFJlc29sdmVQcm9taXNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBXYWl0IGZvciB0aGUgcmVzb2x1dGlvbiBvZiB0aGUgZXhpc3RpbmcgcHJvbWlzZSBjaGFpbi5cbiAgICAgICAgICAgIC8vIFRoZW4gc3dpdGNoIHRvIG91ciBvd24gY29tYmluZWQgcHJvbWlzZSBkZXBlbmRlbmN5IChyZWdhcmRsZXNzIG9mIGhvdyB0aGUgcHJldmlvdXMgbW9kYWwgZmFyZWQpLlxuICAgICAgICAgICAgLy8gVGhlbiBhZGQgdG8gJG1vZGFsU3RhY2sgYW5kIHJlc29sdmUgb3BlbmVkLlxuICAgICAgICAgICAgLy8gRmluYWxseSBjbGVhbiB1cCB0aGUgY2hhaW4gdmFyaWFibGUgaWYgbm8gc3Vic2VxdWVudCBtb2RhbCBoYXMgb3ZlcndyaXR0ZW4gaXQuXG4gICAgICAgICAgICB2YXIgc2FtZVByb21pc2U7XG4gICAgICAgICAgICBzYW1lUHJvbWlzZSA9IHByb21pc2VDaGFpbiA9ICRxLmFsbChbcHJvbWlzZUNoYWluXSlcbiAgICAgICAgICAgICAgLnRoZW4ocmVzb2x2ZVdpdGhUZW1wbGF0ZSwgcmVzb2x2ZVdpdGhUZW1wbGF0ZSlcbiAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gcmVzb2x2ZVN1Y2Nlc3ModHBsQW5kVmFycykge1xuICAgICAgICAgICAgICAgIHZhciBwcm92aWRlZFNjb3BlID0gbW9kYWxPcHRpb25zLnNjb3BlIHx8ICRyb290U2NvcGU7XG5cbiAgICAgICAgICAgICAgICB2YXIgbW9kYWxTY29wZSA9IHByb3ZpZGVkU2NvcGUuJG5ldygpO1xuICAgICAgICAgICAgICAgIG1vZGFsU2NvcGUuJGNsb3NlID0gbW9kYWxJbnN0YW5jZS5jbG9zZTtcbiAgICAgICAgICAgICAgICBtb2RhbFNjb3BlLiRkaXNtaXNzID0gbW9kYWxJbnN0YW5jZS5kaXNtaXNzO1xuXG4gICAgICAgICAgICAgICAgbW9kYWxTY29wZS4kb24oJyRkZXN0cm95JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoIW1vZGFsU2NvcGUuJCR1aWJEZXN0cnVjdGlvblNjaGVkdWxlZCkge1xuICAgICAgICAgICAgICAgICAgICBtb2RhbFNjb3BlLiRkaXNtaXNzKCckdWliVW5zY2hlZHVsZWREZXN0cnVjdGlvbicpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgdmFyIG1vZGFsID0ge1xuICAgICAgICAgICAgICAgICAgc2NvcGU6IG1vZGFsU2NvcGUsXG4gICAgICAgICAgICAgICAgICBkZWZlcnJlZDogbW9kYWxSZXN1bHREZWZlcnJlZCxcbiAgICAgICAgICAgICAgICAgIHJlbmRlckRlZmVycmVkOiBtb2RhbFJlbmRlckRlZmVycmVkLFxuICAgICAgICAgICAgICAgICAgY2xvc2VkRGVmZXJyZWQ6IG1vZGFsQ2xvc2VkRGVmZXJyZWQsXG4gICAgICAgICAgICAgICAgICBhbmltYXRpb246IG1vZGFsT3B0aW9ucy5hbmltYXRpb24sXG4gICAgICAgICAgICAgICAgICBiYWNrZHJvcDogbW9kYWxPcHRpb25zLmJhY2tkcm9wLFxuICAgICAgICAgICAgICAgICAga2V5Ym9hcmQ6IG1vZGFsT3B0aW9ucy5rZXlib2FyZCxcbiAgICAgICAgICAgICAgICAgIGJhY2tkcm9wQ2xhc3M6IG1vZGFsT3B0aW9ucy5iYWNrZHJvcENsYXNzLFxuICAgICAgICAgICAgICAgICAgd2luZG93VG9wQ2xhc3M6IG1vZGFsT3B0aW9ucy53aW5kb3dUb3BDbGFzcyxcbiAgICAgICAgICAgICAgICAgIHdpbmRvd0NsYXNzOiBtb2RhbE9wdGlvbnMud2luZG93Q2xhc3MsXG4gICAgICAgICAgICAgICAgICB3aW5kb3dUZW1wbGF0ZVVybDogbW9kYWxPcHRpb25zLndpbmRvd1RlbXBsYXRlVXJsLFxuICAgICAgICAgICAgICAgICAgYXJpYUxhYmVsbGVkQnk6IG1vZGFsT3B0aW9ucy5hcmlhTGFiZWxsZWRCeSxcbiAgICAgICAgICAgICAgICAgIGFyaWFEZXNjcmliZWRCeTogbW9kYWxPcHRpb25zLmFyaWFEZXNjcmliZWRCeSxcbiAgICAgICAgICAgICAgICAgIHNpemU6IG1vZGFsT3B0aW9ucy5zaXplLFxuICAgICAgICAgICAgICAgICAgb3BlbmVkQ2xhc3M6IG1vZGFsT3B0aW9ucy5vcGVuZWRDbGFzcyxcbiAgICAgICAgICAgICAgICAgIGFwcGVuZFRvOiBtb2RhbE9wdGlvbnMuYXBwZW5kVG9cbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgdmFyIGNvbXBvbmVudCA9IHt9O1xuICAgICAgICAgICAgICAgIHZhciBjdHJsSW5zdGFuY2UsIGN0cmxJbnN0YW50aWF0ZSwgY3RybExvY2FscyA9IHt9O1xuXG4gICAgICAgICAgICAgICAgaWYgKG1vZGFsT3B0aW9ucy5jb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0cnVjdExvY2Fscyhjb21wb25lbnQsIGZhbHNlLCB0cnVlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICBjb21wb25lbnQubmFtZSA9IG1vZGFsT3B0aW9ucy5jb21wb25lbnQ7XG4gICAgICAgICAgICAgICAgICBtb2RhbC5jb21wb25lbnQgPSBjb21wb25lbnQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChtb2RhbE9wdGlvbnMuY29udHJvbGxlcikge1xuICAgICAgICAgICAgICAgICAgY29uc3RydWN0TG9jYWxzKGN0cmxMb2NhbHMsIHRydWUsIGZhbHNlLCB0cnVlKTtcblxuICAgICAgICAgICAgICAgICAgLy8gdGhlIHRoaXJkIHBhcmFtIHdpbGwgbWFrZSB0aGUgY29udHJvbGxlciBpbnN0YW50aWF0ZSBsYXRlcixwcml2YXRlIGFwaVxuICAgICAgICAgICAgICAgICAgLy8gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyLmpzL2Jsb2IvbWFzdGVyL3NyYy9uZy9jb250cm9sbGVyLmpzI0wxMjZcbiAgICAgICAgICAgICAgICAgIGN0cmxJbnN0YW50aWF0ZSA9ICRjb250cm9sbGVyKG1vZGFsT3B0aW9ucy5jb250cm9sbGVyLCBjdHJsTG9jYWxzLCB0cnVlLCBtb2RhbE9wdGlvbnMuY29udHJvbGxlckFzKTtcbiAgICAgICAgICAgICAgICAgIGlmIChtb2RhbE9wdGlvbnMuY29udHJvbGxlckFzICYmIG1vZGFsT3B0aW9ucy5iaW5kVG9Db250cm9sbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0cmxJbnN0YW5jZSA9IGN0cmxJbnN0YW50aWF0ZS5pbnN0YW5jZTtcbiAgICAgICAgICAgICAgICAgICAgY3RybEluc3RhbmNlLiRjbG9zZSA9IG1vZGFsU2NvcGUuJGNsb3NlO1xuICAgICAgICAgICAgICAgICAgICBjdHJsSW5zdGFuY2UuJGRpc21pc3MgPSBtb2RhbFNjb3BlLiRkaXNtaXNzO1xuICAgICAgICAgICAgICAgICAgICBhbmd1bGFyLmV4dGVuZChjdHJsSW5zdGFuY2UsIHtcbiAgICAgICAgICAgICAgICAgICAgICAkcmVzb2x2ZTogY3RybExvY2Fscy4kc2NvcGUuJHJlc29sdmVcbiAgICAgICAgICAgICAgICAgICAgfSwgcHJvdmlkZWRTY29wZSk7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIGN0cmxJbnN0YW5jZSA9IGN0cmxJbnN0YW50aWF0ZSgpO1xuXG4gICAgICAgICAgICAgICAgICBpZiAoYW5ndWxhci5pc0Z1bmN0aW9uKGN0cmxJbnN0YW5jZS4kb25Jbml0KSkge1xuICAgICAgICAgICAgICAgICAgICBjdHJsSW5zdGFuY2UuJG9uSW5pdCgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghbW9kYWxPcHRpb25zLmNvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgICAgbW9kYWwuY29udGVudCA9IHRwbEFuZFZhcnNbMF07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgJG1vZGFsU3RhY2sub3Blbihtb2RhbEluc3RhbmNlLCBtb2RhbCk7XG4gICAgICAgICAgICAgICAgbW9kYWxPcGVuZWREZWZlcnJlZC5yZXNvbHZlKHRydWUpO1xuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gY29uc3RydWN0TG9jYWxzKG9iaiwgdGVtcGxhdGUsIGluc3RhbmNlT25TY29wZSwgaW5qZWN0YWJsZSkge1xuICAgICAgICAgICAgICAgICAgb2JqLiRzY29wZSA9IG1vZGFsU2NvcGU7XG4gICAgICAgICAgICAgICAgICBvYmouJHNjb3BlLiRyZXNvbHZlID0ge307XG4gICAgICAgICAgICAgICAgICBpZiAoaW5zdGFuY2VPblNjb3BlKSB7XG4gICAgICAgICAgICAgICAgICAgIG9iai4kc2NvcGUuJHVpYk1vZGFsSW5zdGFuY2UgPSBtb2RhbEluc3RhbmNlO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqLiR1aWJNb2RhbEluc3RhbmNlID0gbW9kYWxJbnN0YW5jZTtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgdmFyIHJlc29sdmVzID0gdGVtcGxhdGUgPyB0cGxBbmRWYXJzWzFdIDogdHBsQW5kVmFycztcbiAgICAgICAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChyZXNvbHZlcywgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5qZWN0YWJsZSkge1xuICAgICAgICAgICAgICAgICAgICAgIG9ialtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBvYmouJHNjb3BlLiRyZXNvbHZlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uIHJlc29sdmVFcnJvcihyZWFzb24pIHtcbiAgICAgICAgICAgICAgbW9kYWxPcGVuZWREZWZlcnJlZC5yZWplY3QocmVhc29uKTtcbiAgICAgICAgICAgICAgbW9kYWxSZXN1bHREZWZlcnJlZC5yZWplY3QocmVhc29uKTtcbiAgICAgICAgICAgIH0pWydmaW5hbGx5J10oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIGlmIChwcm9taXNlQ2hhaW4gPT09IHNhbWVQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZUNoYWluID0gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiBtb2RhbEluc3RhbmNlO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICByZXR1cm4gJG1vZGFsO1xuICAgICAgICB9XG4gICAgICBdXG4gICAgfTtcblxuICAgIHJldHVybiAkbW9kYWxQcm92aWRlcjtcbiAgfSk7XG5cbmFuZ3VsYXIubW9kdWxlKCd1aS5ib290c3RyYXAucGFnaW5nJywgW10pXG4vKipcbiAqIEhlbHBlciBpbnRlcm5hbCBzZXJ2aWNlIGZvciBnZW5lcmF0aW5nIGNvbW1vbiBjb250cm9sbGVyIGNvZGUgYmV0d2VlbiB0aGVcbiAqIHBhZ2VyIGFuZCBwYWdpbmF0aW9uIGNvbXBvbmVudHNcbiAqL1xuLmZhY3RvcnkoJ3VpYlBhZ2luZycsIFsnJHBhcnNlJywgZnVuY3Rpb24oJHBhcnNlKSB7XG4gIHJldHVybiB7XG4gICAgY3JlYXRlOiBmdW5jdGlvbihjdHJsLCAkc2NvcGUsICRhdHRycykge1xuICAgICAgY3RybC5zZXROdW1QYWdlcyA9ICRhdHRycy5udW1QYWdlcyA/ICRwYXJzZSgkYXR0cnMubnVtUGFnZXMpLmFzc2lnbiA6IGFuZ3VsYXIubm9vcDtcbiAgICAgIGN0cmwubmdNb2RlbEN0cmwgPSB7ICRzZXRWaWV3VmFsdWU6IGFuZ3VsYXIubm9vcCB9OyAvLyBudWxsTW9kZWxDdHJsXG4gICAgICBjdHJsLl93YXRjaGVycyA9IFtdO1xuXG4gICAgICBjdHJsLmluaXQgPSBmdW5jdGlvbihuZ01vZGVsQ3RybCwgY29uZmlnKSB7XG4gICAgICAgIGN0cmwubmdNb2RlbEN0cmwgPSBuZ01vZGVsQ3RybDtcbiAgICAgICAgY3RybC5jb25maWcgPSBjb25maWc7XG5cbiAgICAgICAgbmdNb2RlbEN0cmwuJHJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGN0cmwucmVuZGVyKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKCRhdHRycy5pdGVtc1BlclBhZ2UpIHtcbiAgICAgICAgICBjdHJsLl93YXRjaGVycy5wdXNoKCRzY29wZS4kcGFyZW50LiR3YXRjaCgkYXR0cnMuaXRlbXNQZXJQYWdlLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgY3RybC5pdGVtc1BlclBhZ2UgPSBwYXJzZUludCh2YWx1ZSwgMTApO1xuICAgICAgICAgICAgJHNjb3BlLnRvdGFsUGFnZXMgPSBjdHJsLmNhbGN1bGF0ZVRvdGFsUGFnZXMoKTtcbiAgICAgICAgICAgIGN0cmwudXBkYXRlUGFnZSgpO1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdHJsLml0ZW1zUGVyUGFnZSA9IGNvbmZpZy5pdGVtc1BlclBhZ2U7XG4gICAgICAgIH1cblxuICAgICAgICAkc2NvcGUuJHdhdGNoKCd0b3RhbEl0ZW1zJywgZnVuY3Rpb24obmV3VG90YWwsIG9sZFRvdGFsKSB7XG4gICAgICAgICAgaWYgKGFuZ3VsYXIuaXNEZWZpbmVkKG5ld1RvdGFsKSB8fCBuZXdUb3RhbCAhPT0gb2xkVG90YWwpIHtcbiAgICAgICAgICAgICRzY29wZS50b3RhbFBhZ2VzID0gY3RybC5jYWxjdWxhdGVUb3RhbFBhZ2VzKCk7XG4gICAgICAgICAgICBjdHJsLnVwZGF0ZVBhZ2UoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgY3RybC5jYWxjdWxhdGVUb3RhbFBhZ2VzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB0b3RhbFBhZ2VzID0gY3RybC5pdGVtc1BlclBhZ2UgPCAxID8gMSA6IE1hdGguY2VpbCgkc2NvcGUudG90YWxJdGVtcyAvIGN0cmwuaXRlbXNQZXJQYWdlKTtcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KHRvdGFsUGFnZXMgfHwgMCwgMSk7XG4gICAgICB9O1xuXG4gICAgICBjdHJsLnJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAkc2NvcGUucGFnZSA9IHBhcnNlSW50KGN0cmwubmdNb2RlbEN0cmwuJHZpZXdWYWx1ZSwgMTApIHx8IDE7XG4gICAgICB9O1xuXG4gICAgICAkc2NvcGUuc2VsZWN0UGFnZSA9IGZ1bmN0aW9uKHBhZ2UsIGV2dCkge1xuICAgICAgICBpZiAoZXZ0KSB7XG4gICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY2xpY2tBbGxvd2VkID0gISRzY29wZS5uZ0Rpc2FibGVkIHx8ICFldnQ7XG4gICAgICAgIGlmIChjbGlja0FsbG93ZWQgJiYgJHNjb3BlLnBhZ2UgIT09IHBhZ2UgJiYgcGFnZSA+IDAgJiYgcGFnZSA8PSAkc2NvcGUudG90YWxQYWdlcykge1xuICAgICAgICAgIGlmIChldnQgJiYgZXZ0LnRhcmdldCkge1xuICAgICAgICAgICAgZXZ0LnRhcmdldC5ibHVyKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGN0cmwubmdNb2RlbEN0cmwuJHNldFZpZXdWYWx1ZShwYWdlKTtcbiAgICAgICAgICBjdHJsLm5nTW9kZWxDdHJsLiRyZW5kZXIoKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgJHNjb3BlLmdldFRleHQgPSBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgcmV0dXJuICRzY29wZVtrZXkgKyAnVGV4dCddIHx8IGN0cmwuY29uZmlnW2tleSArICdUZXh0J107XG4gICAgICB9O1xuXG4gICAgICAkc2NvcGUubm9QcmV2aW91cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gJHNjb3BlLnBhZ2UgPT09IDE7XG4gICAgICB9O1xuXG4gICAgICAkc2NvcGUubm9OZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAkc2NvcGUucGFnZSA9PT0gJHNjb3BlLnRvdGFsUGFnZXM7XG4gICAgICB9O1xuXG4gICAgICBjdHJsLnVwZGF0ZVBhZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgY3RybC5zZXROdW1QYWdlcygkc2NvcGUuJHBhcmVudCwgJHNjb3BlLnRvdGFsUGFnZXMpOyAvLyBSZWFkb25seSB2YXJpYWJsZVxuXG4gICAgICAgIGlmICgkc2NvcGUucGFnZSA+ICRzY29wZS50b3RhbFBhZ2VzKSB7XG4gICAgICAgICAgJHNjb3BlLnNlbGVjdFBhZ2UoJHNjb3BlLnRvdGFsUGFnZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN0cmwubmdNb2RlbEN0cmwuJHJlbmRlcigpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAkc2NvcGUuJG9uKCckZGVzdHJveScsIGZ1bmN0aW9uKCkge1xuICAgICAgICB3aGlsZSAoY3RybC5fd2F0Y2hlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgY3RybC5fd2F0Y2hlcnMuc2hpZnQoKSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG59XSk7XG5cbmFuZ3VsYXIubW9kdWxlKCd1aS5ib290c3RyYXAucGFnZXInLCBbJ3VpLmJvb3RzdHJhcC5wYWdpbmcnLCAndWkuYm9vdHN0cmFwLnRhYmluZGV4J10pXG5cbi5jb250cm9sbGVyKCdVaWJQYWdlckNvbnRyb2xsZXInLCBbJyRzY29wZScsICckYXR0cnMnLCAndWliUGFnaW5nJywgJ3VpYlBhZ2VyQ29uZmlnJywgZnVuY3Rpb24oJHNjb3BlLCAkYXR0cnMsIHVpYlBhZ2luZywgdWliUGFnZXJDb25maWcpIHtcbiAgJHNjb3BlLmFsaWduID0gYW5ndWxhci5pc0RlZmluZWQoJGF0dHJzLmFsaWduKSA/ICRzY29wZS4kcGFyZW50LiRldmFsKCRhdHRycy5hbGlnbikgOiB1aWJQYWdlckNvbmZpZy5hbGlnbjtcblxuICB1aWJQYWdpbmcuY3JlYXRlKHRoaXMsICRzY29wZSwgJGF0dHJzKTtcbn1dKVxuXG4uY29uc3RhbnQoJ3VpYlBhZ2VyQ29uZmlnJywge1xuICBpdGVtc1BlclBhZ2U6IDEwLFxuICBwcmV2aW91c1RleHQ6ICfCqyBQcmV2aW91cycsXG4gIG5leHRUZXh0OiAnTmV4dCDCuycsXG4gIGFsaWduOiB0cnVlXG59KVxuXG4uZGlyZWN0aXZlKCd1aWJQYWdlcicsIFsndWliUGFnZXJDb25maWcnLCBmdW5jdGlvbih1aWJQYWdlckNvbmZpZykge1xuICByZXR1cm4ge1xuICAgIHNjb3BlOiB7XG4gICAgICB0b3RhbEl0ZW1zOiAnPScsXG4gICAgICBwcmV2aW91c1RleHQ6ICdAJyxcbiAgICAgIG5leHRUZXh0OiAnQCcsXG4gICAgICBuZ0Rpc2FibGVkOiAnPSdcbiAgICB9LFxuICAgIHJlcXVpcmU6IFsndWliUGFnZXInLCAnP25nTW9kZWwnXSxcbiAgICByZXN0cmljdDogJ0EnLFxuICAgIGNvbnRyb2xsZXI6ICdVaWJQYWdlckNvbnRyb2xsZXInLFxuICAgIGNvbnRyb2xsZXJBczogJ3BhZ2VyJyxcbiAgICB0ZW1wbGF0ZVVybDogZnVuY3Rpb24oZWxlbWVudCwgYXR0cnMpIHtcbiAgICAgIHJldHVybiBhdHRycy50ZW1wbGF0ZVVybCB8fCAndWliL3RlbXBsYXRlL3BhZ2VyL3BhZ2VyLmh0bWwnO1xuICAgIH0sXG4gICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHJzLCBjdHJscykge1xuICAgICAgZWxlbWVudC5hZGRDbGFzcygncGFnZXInKTtcbiAgICAgIHZhciBwYWdpbmF0aW9uQ3RybCA9IGN0cmxzWzBdLCBuZ01vZGVsQ3RybCA9IGN0cmxzWzFdO1xuXG4gICAgICBpZiAoIW5nTW9kZWxDdHJsKSB7XG4gICAgICAgIHJldHVybjsgLy8gZG8gbm90aGluZyBpZiBubyBuZy1tb2RlbFxuICAgICAgfVxuXG4gICAgICBwYWdpbmF0aW9uQ3RybC5pbml0KG5nTW9kZWxDdHJsLCB1aWJQYWdlckNvbmZpZyk7XG4gICAgfVxuICB9O1xufV0pO1xuXG5hbmd1bGFyLm1vZHVsZSgndWkuYm9vdHN0cmFwLnBhZ2luYXRpb24nLCBbJ3VpLmJvb3RzdHJhcC5wYWdpbmcnLCAndWkuYm9vdHN0cmFwLnRhYmluZGV4J10pXG4uY29udHJvbGxlcignVWliUGFnaW5hdGlvbkNvbnRyb2xsZXInLCBbJyRzY29wZScsICckYXR0cnMnLCAnJHBhcnNlJywgJ3VpYlBhZ2luZycsICd1aWJQYWdpbmF0aW9uQ29uZmlnJywgZnVuY3Rpb24oJHNjb3BlLCAkYXR0cnMsICRwYXJzZSwgdWliUGFnaW5nLCB1aWJQYWdpbmF0aW9uQ29uZmlnKSB7XG4gIHZhciBjdHJsID0gdGhpcztcbiAgLy8gU2V0dXAgY29uZmlndXJhdGlvbiBwYXJhbWV0ZXJzXG4gIHZhciBtYXhTaXplID0gYW5ndWxhci5pc0RlZmluZWQoJGF0dHJzLm1heFNpemUpID8gJHNjb3BlLiRwYXJlbnQuJGV2YWwoJGF0dHJzLm1heFNpemUpIDogdWliUGFnaW5hdGlvbkNvbmZpZy5tYXhTaXplLFxuICAgIHJvdGF0ZSA9IGFuZ3VsYXIuaXNEZWZpbmVkKCRhdHRycy5yb3RhdGUpID8gJHNjb3BlLiRwYXJlbnQuJGV2YWwoJGF0dHJzLnJvdGF0ZSkgOiB1aWJQYWdpbmF0aW9uQ29uZmlnLnJvdGF0ZSxcbiAgICBmb3JjZUVsbGlwc2VzID0gYW5ndWxhci5pc0RlZmluZWQoJGF0dHJzLmZvcmNlRWxsaXBzZXMpID8gJHNjb3BlLiRwYXJlbnQuJGV2YWwoJGF0dHJzLmZvcmNlRWxsaXBzZXMpIDogdWliUGFnaW5hdGlvbkNvbmZpZy5mb3JjZUVsbGlwc2VzLFxuICAgIGJvdW5kYXJ5TGlua051bWJlcnMgPSBhbmd1bGFyLmlzRGVmaW5lZCgkYXR0cnMuYm91bmRhcnlMaW5rTnVtYmVycykgPyAkc2NvcGUuJHBhcmVudC4kZXZhbCgkYXR0cnMuYm91bmRhcnlMaW5rTnVtYmVycykgOiB1aWJQYWdpbmF0aW9uQ29uZmlnLmJvdW5kYXJ5TGlua051bWJlcnMsXG4gICAgcGFnZUxhYmVsID0gYW5ndWxhci5pc0RlZmluZWQoJGF0dHJzLnBhZ2VMYWJlbCkgPyBmdW5jdGlvbihpZHgpIHsgcmV0dXJuICRzY29wZS4kcGFyZW50LiRldmFsKCRhdHRycy5wYWdlTGFiZWwsIHskcGFnZTogaWR4fSk7IH0gOiBhbmd1bGFyLmlkZW50aXR5O1xuICAkc2NvcGUuYm91bmRhcnlMaW5rcyA9IGFuZ3VsYXIuaXNEZWZpbmVkKCRhdHRycy5ib3VuZGFyeUxpbmtzKSA/ICRzY29wZS4kcGFyZW50LiRldmFsKCRhdHRycy5ib3VuZGFyeUxpbmtzKSA6IHVpYlBhZ2luYXRpb25Db25maWcuYm91bmRhcnlMaW5rcztcbiAgJHNjb3BlLmRpcmVjdGlvbkxpbmtzID0gYW5ndWxhci5pc0RlZmluZWQoJGF0dHJzLmRpcmVjdGlvbkxpbmtzKSA/ICRzY29wZS4kcGFyZW50LiRldmFsKCRhdHRycy5kaXJlY3Rpb25MaW5rcykgOiB1aWJQYWdpbmF0aW9uQ29uZmlnLmRpcmVjdGlvbkxpbmtzO1xuICAkYXR0cnMuJHNldCgncm9sZScsICdtZW51Jyk7XG5cbiAgdWliUGFnaW5nLmNyZWF0ZSh0aGlzLCAkc2NvcGUsICRhdHRycyk7XG5cbiAgaWYgKCRhdHRycy5tYXhTaXplKSB7XG4gICAgY3RybC5fd2F0Y2hlcnMucHVzaCgkc2NvcGUuJHBhcmVudC4kd2F0Y2goJHBhcnNlKCRhdHRycy5tYXhTaXplKSwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIG1heFNpemUgPSBwYXJzZUludCh2YWx1ZSwgMTApO1xuICAgICAgY3RybC5yZW5kZXIoKTtcbiAgICB9KSk7XG4gIH1cblxuICAvLyBDcmVhdGUgcGFnZSBvYmplY3QgdXNlZCBpbiB0ZW1wbGF0ZVxuICBmdW5jdGlvbiBtYWtlUGFnZShudW1iZXIsIHRleHQsIGlzQWN0aXZlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG51bWJlcjogbnVtYmVyLFxuICAgICAgdGV4dDogdGV4dCxcbiAgICAgIGFjdGl2ZTogaXNBY3RpdmVcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0UGFnZXMoY3VycmVudFBhZ2UsIHRvdGFsUGFnZXMpIHtcbiAgICB2YXIgcGFnZXMgPSBbXTtcblxuICAgIC8vIERlZmF1bHQgcGFnZSBsaW1pdHNcbiAgICB2YXIgc3RhcnRQYWdlID0gMSwgZW5kUGFnZSA9IHRvdGFsUGFnZXM7XG4gICAgdmFyIGlzTWF4U2l6ZWQgPSBhbmd1bGFyLmlzRGVmaW5lZChtYXhTaXplKSAmJiBtYXhTaXplIDwgdG90YWxQYWdlcztcblxuICAgIC8vIHJlY29tcHV0ZSBpZiBtYXhTaXplXG4gICAgaWYgKGlzTWF4U2l6ZWQpIHtcbiAgICAgIGlmIChyb3RhdGUpIHtcbiAgICAgICAgLy8gQ3VycmVudCBwYWdlIGlzIGRpc3BsYXllZCBpbiB0aGUgbWlkZGxlIG9mIHRoZSB2aXNpYmxlIG9uZXNcbiAgICAgICAgc3RhcnRQYWdlID0gTWF0aC5tYXgoY3VycmVudFBhZ2UgLSBNYXRoLmZsb29yKG1heFNpemUgLyAyKSwgMSk7XG4gICAgICAgIGVuZFBhZ2UgPSBzdGFydFBhZ2UgKyBtYXhTaXplIC0gMTtcblxuICAgICAgICAvLyBBZGp1c3QgaWYgbGltaXQgaXMgZXhjZWVkZWRcbiAgICAgICAgaWYgKGVuZFBhZ2UgPiB0b3RhbFBhZ2VzKSB7XG4gICAgICAgICAgZW5kUGFnZSA9IHRvdGFsUGFnZXM7XG4gICAgICAgICAgc3RhcnRQYWdlID0gZW5kUGFnZSAtIG1heFNpemUgKyAxO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBWaXNpYmxlIHBhZ2VzIGFyZSBwYWdpbmF0ZWQgd2l0aCBtYXhTaXplXG4gICAgICAgIHN0YXJ0UGFnZSA9IChNYXRoLmNlaWwoY3VycmVudFBhZ2UgLyBtYXhTaXplKSAtIDEpICogbWF4U2l6ZSArIDE7XG5cbiAgICAgICAgLy8gQWRqdXN0IGxhc3QgcGFnZSBpZiBsaW1pdCBpcyBleGNlZWRlZFxuICAgICAgICBlbmRQYWdlID0gTWF0aC5taW4oc3RhcnRQYWdlICsgbWF4U2l6ZSAtIDEsIHRvdGFsUGFnZXMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFkZCBwYWdlIG51bWJlciBsaW5rc1xuICAgIGZvciAodmFyIG51bWJlciA9IHN0YXJ0UGFnZTsgbnVtYmVyIDw9IGVuZFBhZ2U7IG51bWJlcisrKSB7XG4gICAgICB2YXIgcGFnZSA9IG1ha2VQYWdlKG51bWJlciwgcGFnZUxhYmVsKG51bWJlciksIG51bWJlciA9PT0gY3VycmVudFBhZ2UpO1xuICAgICAgcGFnZXMucHVzaChwYWdlKTtcbiAgICB9XG5cbiAgICAvLyBBZGQgbGlua3MgdG8gbW92ZSBiZXR3ZWVuIHBhZ2Ugc2V0c1xuICAgIGlmIChpc01heFNpemVkICYmIG1heFNpemUgPiAwICYmICghcm90YXRlIHx8IGZvcmNlRWxsaXBzZXMgfHwgYm91bmRhcnlMaW5rTnVtYmVycykpIHtcbiAgICAgIGlmIChzdGFydFBhZ2UgPiAxKSB7XG4gICAgICAgIGlmICghYm91bmRhcnlMaW5rTnVtYmVycyB8fCBzdGFydFBhZ2UgPiAzKSB7IC8vbmVlZCBlbGxpcHNpcyBmb3IgYWxsIG9wdGlvbnMgdW5sZXNzIHJhbmdlIGlzIHRvbyBjbG9zZSB0byBiZWdpbm5pbmdcbiAgICAgICAgdmFyIHByZXZpb3VzUGFnZVNldCA9IG1ha2VQYWdlKHN0YXJ0UGFnZSAtIDEsICcuLi4nLCBmYWxzZSk7XG4gICAgICAgIHBhZ2VzLnVuc2hpZnQocHJldmlvdXNQYWdlU2V0KTtcbiAgICAgIH1cbiAgICAgICAgaWYgKGJvdW5kYXJ5TGlua051bWJlcnMpIHtcbiAgICAgICAgICBpZiAoc3RhcnRQYWdlID09PSAzKSB7IC8vbmVlZCB0byByZXBsYWNlIGVsbGlwc2lzIHdoZW4gdGhlIGJ1dHRvbnMgd291bGQgYmUgc2VxdWVudGlhbFxuICAgICAgICAgICAgdmFyIHNlY29uZFBhZ2VMaW5rID0gbWFrZVBhZ2UoMiwgJzInLCBmYWxzZSk7XG4gICAgICAgICAgICBwYWdlcy51bnNoaWZ0KHNlY29uZFBhZ2VMaW5rKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy9hZGQgdGhlIGZpcnN0IHBhZ2VcbiAgICAgICAgICB2YXIgZmlyc3RQYWdlTGluayA9IG1ha2VQYWdlKDEsICcxJywgZmFsc2UpO1xuICAgICAgICAgIHBhZ2VzLnVuc2hpZnQoZmlyc3RQYWdlTGluayk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGVuZFBhZ2UgPCB0b3RhbFBhZ2VzKSB7XG4gICAgICAgIGlmICghYm91bmRhcnlMaW5rTnVtYmVycyB8fCBlbmRQYWdlIDwgdG90YWxQYWdlcyAtIDIpIHsgLy9uZWVkIGVsbGlwc2lzIGZvciBhbGwgb3B0aW9ucyB1bmxlc3MgcmFuZ2UgaXMgdG9vIGNsb3NlIHRvIGVuZFxuICAgICAgICB2YXIgbmV4dFBhZ2VTZXQgPSBtYWtlUGFnZShlbmRQYWdlICsgMSwgJy4uLicsIGZhbHNlKTtcbiAgICAgICAgcGFnZXMucHVzaChuZXh0UGFnZVNldCk7XG4gICAgICB9XG4gICAgICAgIGlmIChib3VuZGFyeUxpbmtOdW1iZXJzKSB7XG4gICAgICAgICAgaWYgKGVuZFBhZ2UgPT09IHRvdGFsUGFnZXMgLSAyKSB7IC8vbmVlZCB0byByZXBsYWNlIGVsbGlwc2lzIHdoZW4gdGhlIGJ1dHRvbnMgd291bGQgYmUgc2VxdWVudGlhbFxuICAgICAgICAgICAgdmFyIHNlY29uZFRvTGFzdFBhZ2VMaW5rID0gbWFrZVBhZ2UodG90YWxQYWdlcyAtIDEsIHRvdGFsUGFnZXMgLSAxLCBmYWxzZSk7XG4gICAgICAgICAgICBwYWdlcy5wdXNoKHNlY29uZFRvTGFzdFBhZ2VMaW5rKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy9hZGQgdGhlIGxhc3QgcGFnZVxuICAgICAgICAgIHZhciBsYXN0UGFnZUxpbmsgPSBtYWtlUGFnZSh0b3RhbFBhZ2VzLCB0b3RhbFBhZ2VzLCBmYWxzZSk7XG4gICAgICAgICAgcGFnZXMucHVzaChsYXN0UGFnZUxpbmspO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwYWdlcztcbiAgfVxuXG4gIHZhciBvcmlnaW5hbFJlbmRlciA9IHRoaXMucmVuZGVyO1xuICB0aGlzLnJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICAgIG9yaWdpbmFsUmVuZGVyKCk7XG4gICAgaWYgKCRzY29wZS5wYWdlID4gMCAmJiAkc2NvcGUucGFnZSA8PSAkc2NvcGUudG90YWxQYWdlcykge1xuICAgICAgJHNjb3BlLnBhZ2VzID0gZ2V0UGFnZXMoJHNjb3BlLnBhZ2UsICRzY29wZS50b3RhbFBhZ2VzKTtcbiAgICB9XG4gIH07XG59XSlcblxuLmNvbnN0YW50KCd1aWJQYWdpbmF0aW9uQ29uZmlnJywge1xuICBpdGVtc1BlclBhZ2U6IDEwLFxuICBib3VuZGFyeUxpbmtzOiBmYWxzZSxcbiAgYm91bmRhcnlMaW5rTnVtYmVyczogZmFsc2UsXG4gIGRpcmVjdGlvbkxpbmtzOiB0cnVlLFxuICBmaXJzdFRleHQ6ICdGaXJzdCcsXG4gIHByZXZpb3VzVGV4dDogJ1ByZXZpb3VzJyxcbiAgbmV4dFRleHQ6ICdOZXh0JyxcbiAgbGFzdFRleHQ6ICdMYXN0JyxcbiAgcm90YXRlOiB0cnVlLFxuICBmb3JjZUVsbGlwc2VzOiBmYWxzZVxufSlcblxuLmRpcmVjdGl2ZSgndWliUGFnaW5hdGlvbicsIFsnJHBhcnNlJywgJ3VpYlBhZ2luYXRpb25Db25maWcnLCBmdW5jdGlvbigkcGFyc2UsIHVpYlBhZ2luYXRpb25Db25maWcpIHtcbiAgcmV0dXJuIHtcbiAgICBzY29wZToge1xuICAgICAgdG90YWxJdGVtczogJz0nLFxuICAgICAgZmlyc3RUZXh0OiAnQCcsXG4gICAgICBwcmV2aW91c1RleHQ6ICdAJyxcbiAgICAgIG5leHRUZXh0OiAnQCcsXG4gICAgICBsYXN0VGV4dDogJ0AnLFxuICAgICAgbmdEaXNhYmxlZDonPSdcbiAgICB9LFxuICAgIHJlcXVpcmU6IFsndWliUGFnaW5hdGlvbicsICc/bmdNb2RlbCddLFxuICAgIHJlc3RyaWN0OiAnQScsXG4gICAgY29udHJvbGxlcjogJ1VpYlBhZ2luYXRpb25Db250cm9sbGVyJyxcbiAgICBjb250cm9sbGVyQXM6ICdwYWdpbmF0aW9uJyxcbiAgICB0ZW1wbGF0ZVVybDogZnVuY3Rpb24oZWxlbWVudCwgYXR0cnMpIHtcbiAgICAgIHJldHVybiBhdHRycy50ZW1wbGF0ZVVybCB8fCAndWliL3RlbXBsYXRlL3BhZ2luYXRpb24vcGFnaW5hdGlvbi5odG1sJztcbiAgICB9LFxuICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRycywgY3RybHMpIHtcbiAgICAgIGVsZW1lbnQuYWRkQ2xhc3MoJ3BhZ2luYXRpb24nKTtcbiAgICAgIHZhciBwYWdpbmF0aW9uQ3RybCA9IGN0cmxzWzBdLCBuZ01vZGVsQ3RybCA9IGN0cmxzWzFdO1xuXG4gICAgICBpZiAoIW5nTW9kZWxDdHJsKSB7XG4gICAgICAgICByZXR1cm47IC8vIGRvIG5vdGhpbmcgaWYgbm8gbmctbW9kZWxcbiAgICAgIH1cblxuICAgICAgcGFnaW5hdGlvbkN0cmwuaW5pdChuZ01vZGVsQ3RybCwgdWliUGFnaW5hdGlvbkNvbmZpZyk7XG4gICAgfVxuICB9O1xufV0pO1xuXG4vKipcbiAqIFRoZSBmb2xsb3dpbmcgZmVhdHVyZXMgYXJlIHN0aWxsIG91dHN0YW5kaW5nOiBhbmltYXRpb24gYXMgYVxuICogZnVuY3Rpb24sIHBsYWNlbWVudCBhcyBhIGZ1bmN0aW9uLCBpbnNpZGUsIHN1cHBvcnQgZm9yIG1vcmUgdHJpZ2dlcnMgdGhhblxuICoganVzdCBtb3VzZSBlbnRlci9sZWF2ZSwgaHRtbCB0b29sdGlwcywgYW5kIHNlbGVjdG9yIGRlbGVnYXRpb24uXG4gKi9cbmFuZ3VsYXIubW9kdWxlKCd1aS5ib290c3RyYXAudG9vbHRpcCcsIFsndWkuYm9vdHN0cmFwLnBvc2l0aW9uJywgJ3VpLmJvb3RzdHJhcC5zdGFja2VkTWFwJ10pXG5cbi8qKlxuICogVGhlICR0b29sdGlwIHNlcnZpY2UgY3JlYXRlcyB0b29sdGlwLSBhbmQgcG9wb3Zlci1saWtlIGRpcmVjdGl2ZXMgYXMgd2VsbCBhc1xuICogaG91c2VzIGdsb2JhbCBvcHRpb25zIGZvciB0aGVtLlxuICovXG4ucHJvdmlkZXIoJyR1aWJUb29sdGlwJywgZnVuY3Rpb24oKSB7XG4gIC8vIFRoZSBkZWZhdWx0IG9wdGlvbnMgdG9vbHRpcCBhbmQgcG9wb3Zlci5cbiAgdmFyIGRlZmF1bHRPcHRpb25zID0ge1xuICAgIHBsYWNlbWVudDogJ3RvcCcsXG4gICAgcGxhY2VtZW50Q2xhc3NQcmVmaXg6ICcnLFxuICAgIGFuaW1hdGlvbjogdHJ1ZSxcbiAgICBwb3B1cERlbGF5OiAwLFxuICAgIHBvcHVwQ2xvc2VEZWxheTogMCxcbiAgICB1c2VDb250ZW50RXhwOiBmYWxzZVxuICB9O1xuXG4gIC8vIERlZmF1bHQgaGlkZSB0cmlnZ2VycyBmb3IgZWFjaCBzaG93IHRyaWdnZXJcbiAgdmFyIHRyaWdnZXJNYXAgPSB7XG4gICAgJ21vdXNlZW50ZXInOiAnbW91c2VsZWF2ZScsXG4gICAgJ2NsaWNrJzogJ2NsaWNrJyxcbiAgICAnb3V0c2lkZUNsaWNrJzogJ291dHNpZGVDbGljaycsXG4gICAgJ2ZvY3VzJzogJ2JsdXInLFxuICAgICdub25lJzogJydcbiAgfTtcblxuICAvLyBUaGUgb3B0aW9ucyBzcGVjaWZpZWQgdG8gdGhlIHByb3ZpZGVyIGdsb2JhbGx5LlxuICB2YXIgZ2xvYmFsT3B0aW9ucyA9IHt9O1xuXG4gIC8qKlxuICAgKiBgb3B0aW9ucyh7fSlgIGFsbG93cyBnbG9iYWwgY29uZmlndXJhdGlvbiBvZiBhbGwgdG9vbHRpcHMgaW4gdGhlXG4gICAqIGFwcGxpY2F0aW9uLlxuICAgKlxuICAgKiAgIHZhciBhcHAgPSBhbmd1bGFyLm1vZHVsZSggJ0FwcCcsIFsndWkuYm9vdHN0cmFwLnRvb2x0aXAnXSwgZnVuY3Rpb24oICR0b29sdGlwUHJvdmlkZXIgKSB7XG4gICAqICAgICAvLyBwbGFjZSB0b29sdGlwcyBsZWZ0IGluc3RlYWQgb2YgdG9wIGJ5IGRlZmF1bHRcbiAgICogICAgICR0b29sdGlwUHJvdmlkZXIub3B0aW9ucyggeyBwbGFjZW1lbnQ6ICdsZWZ0JyB9ICk7XG4gICAqICAgfSk7XG4gICAqL1xuXHR0aGlzLm9wdGlvbnMgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdGFuZ3VsYXIuZXh0ZW5kKGdsb2JhbE9wdGlvbnMsIHZhbHVlKTtcblx0fTtcblxuICAvKipcbiAgICogVGhpcyBhbGxvd3MgeW91IHRvIGV4dGVuZCB0aGUgc2V0IG9mIHRyaWdnZXIgbWFwcGluZ3MgYXZhaWxhYmxlLiBFLmcuOlxuICAgKlxuICAgKiAgICR0b29sdGlwUHJvdmlkZXIuc2V0VHJpZ2dlcnMoIHsgJ29wZW5UcmlnZ2VyJzogJ2Nsb3NlVHJpZ2dlcicgfSApO1xuICAgKi9cbiAgdGhpcy5zZXRUcmlnZ2VycyA9IGZ1bmN0aW9uIHNldFRyaWdnZXJzKHRyaWdnZXJzKSB7XG4gICAgYW5ndWxhci5leHRlbmQodHJpZ2dlck1hcCwgdHJpZ2dlcnMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIGlzIGEgaGVscGVyIGZ1bmN0aW9uIGZvciB0cmFuc2xhdGluZyBjYW1lbC1jYXNlIHRvIHNuYWtlX2Nhc2UuXG4gICAqL1xuICBmdW5jdGlvbiBzbmFrZV9jYXNlKG5hbWUpIHtcbiAgICB2YXIgcmVnZXhwID0gL1tBLVpdL2c7XG4gICAgdmFyIHNlcGFyYXRvciA9ICctJztcbiAgICByZXR1cm4gbmFtZS5yZXBsYWNlKHJlZ2V4cCwgZnVuY3Rpb24obGV0dGVyLCBwb3MpIHtcbiAgICAgIHJldHVybiAocG9zID8gc2VwYXJhdG9yIDogJycpICsgbGV0dGVyLnRvTG93ZXJDYXNlKCk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYWN0dWFsIGluc3RhbmNlIG9mIHRoZSAkdG9vbHRpcCBzZXJ2aWNlLlxuICAgKiBUT0RPIHN1cHBvcnQgbXVsdGlwbGUgdHJpZ2dlcnNcbiAgICovXG4gIHRoaXMuJGdldCA9IFsnJHdpbmRvdycsICckY29tcGlsZScsICckdGltZW91dCcsICckZG9jdW1lbnQnLCAnJHVpYlBvc2l0aW9uJywgJyRpbnRlcnBvbGF0ZScsICckcm9vdFNjb3BlJywgJyRwYXJzZScsICckJHN0YWNrZWRNYXAnLCBmdW5jdGlvbigkd2luZG93LCAkY29tcGlsZSwgJHRpbWVvdXQsICRkb2N1bWVudCwgJHBvc2l0aW9uLCAkaW50ZXJwb2xhdGUsICRyb290U2NvcGUsICRwYXJzZSwgJCRzdGFja2VkTWFwKSB7XG4gICAgdmFyIG9wZW5lZFRvb2x0aXBzID0gJCRzdGFja2VkTWFwLmNyZWF0ZU5ldygpO1xuICAgICRkb2N1bWVudC5vbigna2V5dXAnLCBrZXlwcmVzc0xpc3RlbmVyKTtcblxuICAgICRyb290U2NvcGUuJG9uKCckZGVzdHJveScsIGZ1bmN0aW9uKCkge1xuICAgICAgJGRvY3VtZW50Lm9mZigna2V5dXAnLCBrZXlwcmVzc0xpc3RlbmVyKTtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGtleXByZXNzTGlzdGVuZXIoZSkge1xuICAgICAgaWYgKGUud2hpY2ggPT09IDI3KSB7XG4gICAgICAgIHZhciBsYXN0ID0gb3BlbmVkVG9vbHRpcHMudG9wKCk7XG4gICAgICAgIGlmIChsYXN0KSB7XG4gICAgICAgICAgbGFzdC52YWx1ZS5jbG9zZSgpO1xuICAgICAgICAgIGxhc3QgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICR0b29sdGlwKHR0VHlwZSwgcHJlZml4LCBkZWZhdWx0VHJpZ2dlclNob3csIG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBhbmd1bGFyLmV4dGVuZCh7fSwgZGVmYXVsdE9wdGlvbnMsIGdsb2JhbE9wdGlvbnMsIG9wdGlvbnMpO1xuXG4gICAgICAvKipcbiAgICAgICAqIFJldHVybnMgYW4gb2JqZWN0IG9mIHNob3cgYW5kIGhpZGUgdHJpZ2dlcnMuXG4gICAgICAgKlxuICAgICAgICogSWYgYSB0cmlnZ2VyIGlzIHN1cHBsaWVkLFxuICAgICAgICogaXQgaXMgdXNlZCB0byBzaG93IHRoZSB0b29sdGlwOyBvdGhlcndpc2UsIGl0IHdpbGwgdXNlIHRoZSBgdHJpZ2dlcmBcbiAgICAgICAqIG9wdGlvbiBwYXNzZWQgdG8gdGhlIGAkdG9vbHRpcFByb3ZpZGVyLm9wdGlvbnNgIG1ldGhvZDsgZWxzZSBpdCB3aWxsXG4gICAgICAgKiBkZWZhdWx0IHRvIHRoZSB0cmlnZ2VyIHN1cHBsaWVkIHRvIHRoaXMgZGlyZWN0aXZlIGZhY3RvcnkuXG4gICAgICAgKlxuICAgICAgICogVGhlIGhpZGUgdHJpZ2dlciBpcyBiYXNlZCBvbiB0aGUgc2hvdyB0cmlnZ2VyLiBJZiB0aGUgYHRyaWdnZXJgIG9wdGlvblxuICAgICAgICogd2FzIHBhc3NlZCB0byB0aGUgYCR0b29sdGlwUHJvdmlkZXIub3B0aW9uc2AgbWV0aG9kLCBpdCB3aWxsIHVzZSB0aGVcbiAgICAgICAqIG1hcHBlZCB0cmlnZ2VyIGZyb20gYHRyaWdnZXJNYXBgIG9yIHRoZSBwYXNzZWQgdHJpZ2dlciBpZiB0aGUgbWFwIGlzXG4gICAgICAgKiB1bmRlZmluZWQ7IG90aGVyd2lzZSwgaXQgdXNlcyB0aGUgYHRyaWdnZXJNYXBgIHZhbHVlIG9mIHRoZSBzaG93XG4gICAgICAgKiB0cmlnZ2VyOyBlbHNlIGl0IHdpbGwganVzdCB1c2UgdGhlIHNob3cgdHJpZ2dlci5cbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24gZ2V0VHJpZ2dlcnModHJpZ2dlcikge1xuICAgICAgICB2YXIgc2hvdyA9ICh0cmlnZ2VyIHx8IG9wdGlvbnMudHJpZ2dlciB8fCBkZWZhdWx0VHJpZ2dlclNob3cpLnNwbGl0KCcgJyk7XG4gICAgICAgIHZhciBoaWRlID0gc2hvdy5tYXAoZnVuY3Rpb24odHJpZ2dlcikge1xuICAgICAgICAgIHJldHVybiB0cmlnZ2VyTWFwW3RyaWdnZXJdIHx8IHRyaWdnZXI7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHNob3c6IHNob3csXG4gICAgICAgICAgaGlkZTogaGlkZVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICB2YXIgZGlyZWN0aXZlTmFtZSA9IHNuYWtlX2Nhc2UodHRUeXBlKTtcblxuICAgICAgdmFyIHN0YXJ0U3ltID0gJGludGVycG9sYXRlLnN0YXJ0U3ltYm9sKCk7XG4gICAgICB2YXIgZW5kU3ltID0gJGludGVycG9sYXRlLmVuZFN5bWJvbCgpO1xuICAgICAgdmFyIHRlbXBsYXRlID1cbiAgICAgICAgJzxkaXYgJysgZGlyZWN0aXZlTmFtZSArICctcG9wdXAgJyArXG4gICAgICAgICAgJ3VpYi10aXRsZT1cIicgKyBzdGFydFN5bSArICd0aXRsZScgKyBlbmRTeW0gKyAnXCIgJyArXG4gICAgICAgICAgKG9wdGlvbnMudXNlQ29udGVudEV4cCA/XG4gICAgICAgICAgICAnY29udGVudC1leHA9XCJjb250ZW50RXhwKClcIiAnIDpcbiAgICAgICAgICAgICdjb250ZW50PVwiJyArIHN0YXJ0U3ltICsgJ2NvbnRlbnQnICsgZW5kU3ltICsgJ1wiICcpICtcbiAgICAgICAgICAnb3JpZ2luLXNjb3BlPVwib3JpZ1Njb3BlXCIgJyArXG4gICAgICAgICAgJ2NsYXNzPVwidWliLXBvc2l0aW9uLW1lYXN1cmUgJyArIHByZWZpeCArICdcIiAnICtcbiAgICAgICAgICAndG9vbHRpcC1hbmltYXRpb24tY2xhc3M9XCJmYWRlXCInICtcbiAgICAgICAgICAndWliLXRvb2x0aXAtY2xhc3NlcyAnICtcbiAgICAgICAgICAnbmctY2xhc3M9XCJ7IGluOiBpc09wZW4gfVwiICcgK1xuICAgICAgICAgICc+JyArXG4gICAgICAgICc8L2Rpdj4nO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBjb21waWxlOiBmdW5jdGlvbih0RWxlbSwgdEF0dHJzKSB7XG4gICAgICAgICAgdmFyIHRvb2x0aXBMaW5rZXIgPSAkY29tcGlsZSh0ZW1wbGF0ZSk7XG5cbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gbGluayhzY29wZSwgZWxlbWVudCwgYXR0cnMsIHRvb2x0aXBDdHJsKSB7XG4gICAgICAgICAgICB2YXIgdG9vbHRpcDtcbiAgICAgICAgICAgIHZhciB0b29sdGlwTGlua2VkU2NvcGU7XG4gICAgICAgICAgICB2YXIgdHJhbnNpdGlvblRpbWVvdXQ7XG4gICAgICAgICAgICB2YXIgc2hvd1RpbWVvdXQ7XG4gICAgICAgICAgICB2YXIgaGlkZVRpbWVvdXQ7XG4gICAgICAgICAgICB2YXIgcG9zaXRpb25UaW1lb3V0O1xuICAgICAgICAgICAgdmFyIGFkanVzdG1lbnRUaW1lb3V0O1xuICAgICAgICAgICAgdmFyIGFwcGVuZFRvQm9keSA9IGFuZ3VsYXIuaXNEZWZpbmVkKG9wdGlvbnMuYXBwZW5kVG9Cb2R5KSA/IG9wdGlvbnMuYXBwZW5kVG9Cb2R5IDogZmFsc2U7XG4gICAgICAgICAgICB2YXIgdHJpZ2dlcnMgPSBnZXRUcmlnZ2Vycyh1bmRlZmluZWQpO1xuICAgICAgICAgICAgdmFyIGhhc0VuYWJsZUV4cCA9IGFuZ3VsYXIuaXNEZWZpbmVkKGF0dHJzW3ByZWZpeCArICdFbmFibGUnXSk7XG4gICAgICAgICAgICB2YXIgdHRTY29wZSA9IHNjb3BlLiRuZXcodHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcmVwb3NpdGlvblNjaGVkdWxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIGlzT3BlblBhcnNlID0gYW5ndWxhci5pc0RlZmluZWQoYXR0cnNbcHJlZml4ICsgJ0lzT3BlbiddKSA/ICRwYXJzZShhdHRyc1twcmVmaXggKyAnSXNPcGVuJ10pIDogZmFsc2U7XG4gICAgICAgICAgICB2YXIgY29udGVudFBhcnNlID0gb3B0aW9ucy51c2VDb250ZW50RXhwID8gJHBhcnNlKGF0dHJzW3R0VHlwZV0pIDogZmFsc2U7XG4gICAgICAgICAgICB2YXIgb2JzZXJ2ZXJzID0gW107XG4gICAgICAgICAgICB2YXIgbGFzdFBsYWNlbWVudDtcblxuICAgICAgICAgICAgdmFyIHBvc2l0aW9uVG9vbHRpcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAvLyBjaGVjayBpZiB0b29sdGlwIGV4aXN0cyBhbmQgaXMgbm90IGVtcHR5XG4gICAgICAgICAgICAgIGlmICghdG9vbHRpcCB8fCAhdG9vbHRpcC5odG1sKCkpIHsgcmV0dXJuOyB9XG5cbiAgICAgICAgICAgICAgaWYgKCFwb3NpdGlvblRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvblRpbWVvdXQgPSAkdGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgIHZhciB0dFBvc2l0aW9uID0gJHBvc2l0aW9uLnBvc2l0aW9uRWxlbWVudHMoZWxlbWVudCwgdG9vbHRpcCwgdHRTY29wZS5wbGFjZW1lbnQsIGFwcGVuZFRvQm9keSk7XG4gICAgICAgICAgICAgICAgICB2YXIgaW5pdGlhbEhlaWdodCA9IGFuZ3VsYXIuaXNEZWZpbmVkKHRvb2x0aXAub2Zmc2V0SGVpZ2h0KSA/IHRvb2x0aXAub2Zmc2V0SGVpZ2h0IDogdG9vbHRpcC5wcm9wKCdvZmZzZXRIZWlnaHQnKTtcbiAgICAgICAgICAgICAgICAgIHZhciBlbGVtZW50UG9zID0gYXBwZW5kVG9Cb2R5ID8gJHBvc2l0aW9uLm9mZnNldChlbGVtZW50KSA6ICRwb3NpdGlvbi5wb3NpdGlvbihlbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgIHRvb2x0aXAuY3NzKHsgdG9wOiB0dFBvc2l0aW9uLnRvcCArICdweCcsIGxlZnQ6IHR0UG9zaXRpb24ubGVmdCArICdweCcgfSk7XG4gICAgICAgICAgICAgICAgICB2YXIgcGxhY2VtZW50Q2xhc3NlcyA9IHR0UG9zaXRpb24ucGxhY2VtZW50LnNwbGl0KCctJyk7XG5cbiAgICAgICAgICAgICAgICAgIGlmICghdG9vbHRpcC5oYXNDbGFzcyhwbGFjZW1lbnRDbGFzc2VzWzBdKSkge1xuICAgICAgICAgICAgICAgICAgICB0b29sdGlwLnJlbW92ZUNsYXNzKGxhc3RQbGFjZW1lbnQuc3BsaXQoJy0nKVswXSk7XG4gICAgICAgICAgICAgICAgICAgIHRvb2x0aXAuYWRkQ2xhc3MocGxhY2VtZW50Q2xhc3Nlc1swXSk7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIGlmICghdG9vbHRpcC5oYXNDbGFzcyhvcHRpb25zLnBsYWNlbWVudENsYXNzUHJlZml4ICsgdHRQb3NpdGlvbi5wbGFjZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvb2x0aXAucmVtb3ZlQ2xhc3Mob3B0aW9ucy5wbGFjZW1lbnRDbGFzc1ByZWZpeCArIGxhc3RQbGFjZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICB0b29sdGlwLmFkZENsYXNzKG9wdGlvbnMucGxhY2VtZW50Q2xhc3NQcmVmaXggKyB0dFBvc2l0aW9uLnBsYWNlbWVudCk7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIGFkanVzdG1lbnRUaW1lb3V0ID0gJHRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjdXJyZW50SGVpZ2h0ID0gYW5ndWxhci5pc0RlZmluZWQodG9vbHRpcC5vZmZzZXRIZWlnaHQpID8gdG9vbHRpcC5vZmZzZXRIZWlnaHQgOiB0b29sdGlwLnByb3AoJ29mZnNldEhlaWdodCcpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYWRqdXN0bWVudCA9ICRwb3NpdGlvbi5hZGp1c3RUb3AocGxhY2VtZW50Q2xhc3NlcywgZWxlbWVudFBvcywgaW5pdGlhbEhlaWdodCwgY3VycmVudEhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhZGp1c3RtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgdG9vbHRpcC5jc3MoYWRqdXN0bWVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYWRqdXN0bWVudFRpbWVvdXQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgfSwgMCwgZmFsc2UpO1xuXG4gICAgICAgICAgICAgICAgICAvLyBmaXJzdCB0aW1lIHRocm91Z2ggdHQgZWxlbWVudCB3aWxsIGhhdmUgdGhlXG4gICAgICAgICAgICAgICAgICAvLyB1aWItcG9zaXRpb24tbWVhc3VyZSBjbGFzcyBvciBpZiB0aGUgcGxhY2VtZW50XG4gICAgICAgICAgICAgICAgICAvLyBoYXMgY2hhbmdlZCB3ZSBuZWVkIHRvIHBvc2l0aW9uIHRoZSBhcnJvdy5cbiAgICAgICAgICAgICAgICAgIGlmICh0b29sdGlwLmhhc0NsYXNzKCd1aWItcG9zaXRpb24tbWVhc3VyZScpKSB7XG4gICAgICAgICAgICAgICAgICAgICRwb3NpdGlvbi5wb3NpdGlvbkFycm93KHRvb2x0aXAsIHR0UG9zaXRpb24ucGxhY2VtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgdG9vbHRpcC5yZW1vdmVDbGFzcygndWliLXBvc2l0aW9uLW1lYXN1cmUnKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobGFzdFBsYWNlbWVudCAhPT0gdHRQb3NpdGlvbi5wbGFjZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgJHBvc2l0aW9uLnBvc2l0aW9uQXJyb3codG9vbHRpcCwgdHRQb3NpdGlvbi5wbGFjZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgbGFzdFBsYWNlbWVudCA9IHR0UG9zaXRpb24ucGxhY2VtZW50O1xuXG4gICAgICAgICAgICAgICAgICBwb3NpdGlvblRpbWVvdXQgPSBudWxsO1xuICAgICAgICAgICAgICAgIH0sIDAsIGZhbHNlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gU2V0IHVwIHRoZSBjb3JyZWN0IHNjb3BlIHRvIGFsbG93IHRyYW5zY2x1c2lvbiBsYXRlclxuICAgICAgICAgICAgdHRTY29wZS5vcmlnU2NvcGUgPSBzY29wZTtcblxuICAgICAgICAgICAgLy8gQnkgZGVmYXVsdCwgdGhlIHRvb2x0aXAgaXMgbm90IG9wZW4uXG4gICAgICAgICAgICAvLyBUT0RPIGFkZCBhYmlsaXR5IHRvIHN0YXJ0IHRvb2x0aXAgb3BlbmVkXG4gICAgICAgICAgICB0dFNjb3BlLmlzT3BlbiA9IGZhbHNlO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiB0b2dnbGVUb29sdGlwQmluZCgpIHtcbiAgICAgICAgICAgICAgaWYgKCF0dFNjb3BlLmlzT3Blbikge1xuICAgICAgICAgICAgICAgIHNob3dUb29sdGlwQmluZCgpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGhpZGVUb29sdGlwQmluZCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFNob3cgdGhlIHRvb2x0aXAgd2l0aCBkZWxheSBpZiBzcGVjaWZpZWQsIG90aGVyd2lzZSBzaG93IGl0IGltbWVkaWF0ZWx5XG4gICAgICAgICAgICBmdW5jdGlvbiBzaG93VG9vbHRpcEJpbmQoKSB7XG4gICAgICAgICAgICAgIGlmIChoYXNFbmFibGVFeHAgJiYgIXNjb3BlLiRldmFsKGF0dHJzW3ByZWZpeCArICdFbmFibGUnXSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBjYW5jZWxIaWRlKCk7XG4gICAgICAgICAgICAgIHByZXBhcmVUb29sdGlwKCk7XG5cbiAgICAgICAgICAgICAgaWYgKHR0U2NvcGUucG9wdXBEZWxheSkge1xuICAgICAgICAgICAgICAgIC8vIERvIG5vdGhpbmcgaWYgdGhlIHRvb2x0aXAgd2FzIGFscmVhZHkgc2NoZWR1bGVkIHRvIHBvcC11cC5cbiAgICAgICAgICAgICAgICAvLyBUaGlzIGhhcHBlbnMgaWYgc2hvdyBpcyB0cmlnZ2VyZWQgbXVsdGlwbGUgdGltZXMgYmVmb3JlIGFueSBoaWRlIGlzIHRyaWdnZXJlZC5cbiAgICAgICAgICAgICAgICBpZiAoIXNob3dUaW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgICBzaG93VGltZW91dCA9ICR0aW1lb3V0KHNob3csIHR0U2NvcGUucG9wdXBEZWxheSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzaG93KCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gaGlkZVRvb2x0aXBCaW5kKCkge1xuICAgICAgICAgICAgICBjYW5jZWxTaG93KCk7XG5cbiAgICAgICAgICAgICAgaWYgKHR0U2NvcGUucG9wdXBDbG9zZURlbGF5KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFoaWRlVGltZW91dCkge1xuICAgICAgICAgICAgICAgICAgaGlkZVRpbWVvdXQgPSAkdGltZW91dChoaWRlLCB0dFNjb3BlLnBvcHVwQ2xvc2VEZWxheSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBoaWRlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU2hvdyB0aGUgdG9vbHRpcCBwb3B1cCBlbGVtZW50LlxuICAgICAgICAgICAgZnVuY3Rpb24gc2hvdygpIHtcbiAgICAgICAgICAgICAgY2FuY2VsU2hvdygpO1xuICAgICAgICAgICAgICBjYW5jZWxIaWRlKCk7XG5cbiAgICAgICAgICAgICAgLy8gRG9uJ3Qgc2hvdyBlbXB0eSB0b29sdGlwcy5cbiAgICAgICAgICAgICAgaWYgKCF0dFNjb3BlLmNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYW5ndWxhci5ub29wO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgY3JlYXRlVG9vbHRpcCgpO1xuXG4gICAgICAgICAgICAgIC8vIEFuZCBzaG93IHRoZSB0b29sdGlwLlxuICAgICAgICAgICAgICB0dFNjb3BlLiRldmFsQXN5bmMoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdHRTY29wZS5pc09wZW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgIGFzc2lnbklzT3Blbih0cnVlKTtcbiAgICAgICAgICAgICAgICBwb3NpdGlvblRvb2x0aXAoKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGNhbmNlbFNob3coKSB7XG4gICAgICAgICAgICAgIGlmIChzaG93VGltZW91dCkge1xuICAgICAgICAgICAgICAgICR0aW1lb3V0LmNhbmNlbChzaG93VGltZW91dCk7XG4gICAgICAgICAgICAgICAgc2hvd1RpbWVvdXQgPSBudWxsO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uVGltZW91dCkge1xuICAgICAgICAgICAgICAgICR0aW1lb3V0LmNhbmNlbChwb3NpdGlvblRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uVGltZW91dCA9IG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSGlkZSB0aGUgdG9vbHRpcCBwb3B1cCBlbGVtZW50LlxuICAgICAgICAgICAgZnVuY3Rpb24gaGlkZSgpIHtcbiAgICAgICAgICAgICAgaWYgKCF0dFNjb3BlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gRmlyc3QgdGhpbmdzIGZpcnN0OiB3ZSBkb24ndCBzaG93IGl0IGFueW1vcmUuXG4gICAgICAgICAgICAgIHR0U2NvcGUuJGV2YWxBc3luYyhmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAodHRTY29wZSkge1xuICAgICAgICAgICAgICAgICAgdHRTY29wZS5pc09wZW4gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgIGFzc2lnbklzT3BlbihmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAvLyBBbmQgbm93IHdlIHJlbW92ZSBpdCBmcm9tIHRoZSBET00uIEhvd2V2ZXIsIGlmIHdlIGhhdmUgYW5pbWF0aW9uLCB3ZVxuICAgICAgICAgICAgICAgICAgLy8gbmVlZCB0byB3YWl0IGZvciBpdCB0byBleHBpcmUgYmVmb3JlaGFuZC5cbiAgICAgICAgICAgICAgICAgIC8vIEZJWE1FOiB0aGlzIGlzIGEgcGxhY2Vob2xkZXIgZm9yIGEgcG9ydCBvZiB0aGUgdHJhbnNpdGlvbnMgbGlicmFyeS5cbiAgICAgICAgICAgICAgICAgIC8vIFRoZSBmYWRlIHRyYW5zaXRpb24gaW4gVFdCUyBpcyAxNTBtcy5cbiAgICAgICAgICAgICAgICAgIGlmICh0dFNjb3BlLmFuaW1hdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRyYW5zaXRpb25UaW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvblRpbWVvdXQgPSAkdGltZW91dChyZW1vdmVUb29sdGlwLCAxNTAsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlVG9vbHRpcCgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGNhbmNlbEhpZGUoKSB7XG4gICAgICAgICAgICAgIGlmIChoaWRlVGltZW91dCkge1xuICAgICAgICAgICAgICAgICR0aW1lb3V0LmNhbmNlbChoaWRlVGltZW91dCk7XG4gICAgICAgICAgICAgICAgaGlkZVRpbWVvdXQgPSBudWxsO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKHRyYW5zaXRpb25UaW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgJHRpbWVvdXQuY2FuY2VsKHRyYW5zaXRpb25UaW1lb3V0KTtcbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uVGltZW91dCA9IG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gY3JlYXRlVG9vbHRpcCgpIHtcbiAgICAgICAgICAgICAgLy8gVGhlcmUgY2FuIG9ubHkgYmUgb25lIHRvb2x0aXAgZWxlbWVudCBwZXIgZGlyZWN0aXZlIHNob3duIGF0IG9uY2UuXG4gICAgICAgICAgICAgIGlmICh0b29sdGlwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdG9vbHRpcExpbmtlZFNjb3BlID0gdHRTY29wZS4kbmV3KCk7XG4gICAgICAgICAgICAgIHRvb2x0aXAgPSB0b29sdGlwTGlua2VyKHRvb2x0aXBMaW5rZWRTY29wZSwgZnVuY3Rpb24odG9vbHRpcCkge1xuICAgICAgICAgICAgICAgIGlmIChhcHBlbmRUb0JvZHkpIHtcbiAgICAgICAgICAgICAgICAgICRkb2N1bWVudC5maW5kKCdib2R5JykuYXBwZW5kKHRvb2x0aXApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBlbGVtZW50LmFmdGVyKHRvb2x0aXApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgb3BlbmVkVG9vbHRpcHMuYWRkKHR0U2NvcGUsIHtcbiAgICAgICAgICAgICAgICBjbG9zZTogaGlkZVxuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBwcmVwT2JzZXJ2ZXJzKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHJlbW92ZVRvb2x0aXAoKSB7XG4gICAgICAgICAgICAgIGNhbmNlbFNob3coKTtcbiAgICAgICAgICAgICAgY2FuY2VsSGlkZSgpO1xuICAgICAgICAgICAgICB1bnJlZ2lzdGVyT2JzZXJ2ZXJzKCk7XG5cbiAgICAgICAgICAgICAgaWYgKHRvb2x0aXApIHtcbiAgICAgICAgICAgICAgICB0b29sdGlwLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHRvb2x0aXAgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChhZGp1c3RtZW50VGltZW91dCkge1xuICAgICAgICAgICAgICAgICAgJHRpbWVvdXQuY2FuY2VsKGFkanVzdG1lbnRUaW1lb3V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBvcGVuZWRUb29sdGlwcy5yZW1vdmUodHRTY29wZSk7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICBpZiAodG9vbHRpcExpbmtlZFNjb3BlKSB7XG4gICAgICAgICAgICAgICAgdG9vbHRpcExpbmtlZFNjb3BlLiRkZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgdG9vbHRpcExpbmtlZFNjb3BlID0gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFNldCB0aGUgaW5pdGlhbCBzY29wZSB2YWx1ZXMuIE9uY2VcbiAgICAgICAgICAgICAqIHRoZSB0b29sdGlwIGlzIGNyZWF0ZWQsIHRoZSBvYnNlcnZlcnNcbiAgICAgICAgICAgICAqIHdpbGwgYmUgYWRkZWQgdG8ga2VlcCB0aGluZ3MgaW4gc3luYy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gcHJlcGFyZVRvb2x0aXAoKSB7XG4gICAgICAgICAgICAgIHR0U2NvcGUudGl0bGUgPSBhdHRyc1twcmVmaXggKyAnVGl0bGUnXTtcbiAgICAgICAgICAgICAgaWYgKGNvbnRlbnRQYXJzZSkge1xuICAgICAgICAgICAgICAgIHR0U2NvcGUuY29udGVudCA9IGNvbnRlbnRQYXJzZShzY29wZSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdHRTY29wZS5jb250ZW50ID0gYXR0cnNbdHRUeXBlXTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHR0U2NvcGUucG9wdXBDbGFzcyA9IGF0dHJzW3ByZWZpeCArICdDbGFzcyddO1xuICAgICAgICAgICAgICB0dFNjb3BlLnBsYWNlbWVudCA9IGFuZ3VsYXIuaXNEZWZpbmVkKGF0dHJzW3ByZWZpeCArICdQbGFjZW1lbnQnXSkgPyBhdHRyc1twcmVmaXggKyAnUGxhY2VtZW50J10gOiBvcHRpb25zLnBsYWNlbWVudDtcbiAgICAgICAgICAgICAgdmFyIHBsYWNlbWVudCA9ICRwb3NpdGlvbi5wYXJzZVBsYWNlbWVudCh0dFNjb3BlLnBsYWNlbWVudCk7XG4gICAgICAgICAgICAgIGxhc3RQbGFjZW1lbnQgPSBwbGFjZW1lbnRbMV0gPyBwbGFjZW1lbnRbMF0gKyAnLScgKyBwbGFjZW1lbnRbMV0gOiBwbGFjZW1lbnRbMF07XG5cbiAgICAgICAgICAgICAgdmFyIGRlbGF5ID0gcGFyc2VJbnQoYXR0cnNbcHJlZml4ICsgJ1BvcHVwRGVsYXknXSwgMTApO1xuICAgICAgICAgICAgICB2YXIgY2xvc2VEZWxheSA9IHBhcnNlSW50KGF0dHJzW3ByZWZpeCArICdQb3B1cENsb3NlRGVsYXknXSwgMTApO1xuICAgICAgICAgICAgICB0dFNjb3BlLnBvcHVwRGVsYXkgPSAhaXNOYU4oZGVsYXkpID8gZGVsYXkgOiBvcHRpb25zLnBvcHVwRGVsYXk7XG4gICAgICAgICAgICAgIHR0U2NvcGUucG9wdXBDbG9zZURlbGF5ID0gIWlzTmFOKGNsb3NlRGVsYXkpID8gY2xvc2VEZWxheSA6IG9wdGlvbnMucG9wdXBDbG9zZURlbGF5O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBhc3NpZ25Jc09wZW4oaXNPcGVuKSB7XG4gICAgICAgICAgICAgIGlmIChpc09wZW5QYXJzZSAmJiBhbmd1bGFyLmlzRnVuY3Rpb24oaXNPcGVuUGFyc2UuYXNzaWduKSkge1xuICAgICAgICAgICAgICAgIGlzT3BlblBhcnNlLmFzc2lnbihzY29wZSwgaXNPcGVuKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0dFNjb3BlLmNvbnRlbnRFeHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHR0U2NvcGUuY29udGVudDtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogT2JzZXJ2ZSB0aGUgcmVsZXZhbnQgYXR0cmlidXRlcy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgYXR0cnMuJG9ic2VydmUoJ2Rpc2FibGVkJywgZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICAgIGlmICh2YWwpIHtcbiAgICAgICAgICAgICAgICBjYW5jZWxTaG93KCk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAodmFsICYmIHR0U2NvcGUuaXNPcGVuKSB7XG4gICAgICAgICAgICAgICAgaGlkZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKGlzT3BlblBhcnNlKSB7XG4gICAgICAgICAgICAgIHNjb3BlLiR3YXRjaChpc09wZW5QYXJzZSwgZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR0U2NvcGUgJiYgIXZhbCA9PT0gdHRTY29wZS5pc09wZW4pIHtcbiAgICAgICAgICAgICAgICAgIHRvZ2dsZVRvb2x0aXBCaW5kKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gcHJlcE9ic2VydmVycygpIHtcbiAgICAgICAgICAgICAgb2JzZXJ2ZXJzLmxlbmd0aCA9IDA7XG5cbiAgICAgICAgICAgICAgaWYgKGNvbnRlbnRQYXJzZSkge1xuICAgICAgICAgICAgICAgIG9ic2VydmVycy5wdXNoKFxuICAgICAgICAgICAgICAgICAgc2NvcGUuJHdhdGNoKGNvbnRlbnRQYXJzZSwgZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHR0U2NvcGUuY29udGVudCA9IHZhbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF2YWwgJiYgdHRTY29wZS5pc09wZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICBoaWRlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIG9ic2VydmVycy5wdXNoKFxuICAgICAgICAgICAgICAgICAgdG9vbHRpcExpbmtlZFNjb3BlLiR3YXRjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXBvc2l0aW9uU2NoZWR1bGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmVwb3NpdGlvblNjaGVkdWxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgdG9vbHRpcExpbmtlZFNjb3BlLiQkcG9zdERpZ2VzdChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcG9zaXRpb25TY2hlZHVsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0dFNjb3BlICYmIHR0U2NvcGUuaXNPcGVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uVG9vbHRpcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXJzLnB1c2goXG4gICAgICAgICAgICAgICAgICBhdHRycy4kb2JzZXJ2ZSh0dFR5cGUsIGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICAgICAgICAgICAgICB0dFNjb3BlLmNvbnRlbnQgPSB2YWw7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdmFsICYmIHR0U2NvcGUuaXNPcGVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaGlkZSgpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uVG9vbHRpcCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBvYnNlcnZlcnMucHVzaChcbiAgICAgICAgICAgICAgICBhdHRycy4kb2JzZXJ2ZShwcmVmaXggKyAnVGl0bGUnLCBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICAgICAgICAgIHR0U2NvcGUudGl0bGUgPSB2YWw7XG4gICAgICAgICAgICAgICAgICBpZiAodHRTY29wZS5pc09wZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25Ub29sdGlwKCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICBvYnNlcnZlcnMucHVzaChcbiAgICAgICAgICAgICAgICBhdHRycy4kb2JzZXJ2ZShwcmVmaXggKyAnUGxhY2VtZW50JywgZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICAgICAgICB0dFNjb3BlLnBsYWNlbWVudCA9IHZhbCA/IHZhbCA6IG9wdGlvbnMucGxhY2VtZW50O1xuICAgICAgICAgICAgICAgICAgaWYgKHR0U2NvcGUuaXNPcGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uVG9vbHRpcCgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHVucmVnaXN0ZXJPYnNlcnZlcnMoKSB7XG4gICAgICAgICAgICAgIGlmIChvYnNlcnZlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKG9ic2VydmVycywgZnVuY3Rpb24ob2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgICAgICAgIG9ic2VydmVyKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXJzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaGlkZSB0b29sdGlwcy9wb3BvdmVycyBmb3Igb3V0c2lkZUNsaWNrIHRyaWdnZXJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGJvZHlIaWRlVG9vbHRpcEJpbmQoZSkge1xuICAgICAgICAgICAgICBpZiAoIXR0U2NvcGUgfHwgIXR0U2NvcGUuaXNPcGVuIHx8ICF0b29sdGlwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSB0aGUgdG9vbHRpcC9wb3BvdmVyIGxpbmsgb3IgdG9vbCB0b29sdGlwL3BvcG92ZXIgaXRzZWxmIHdlcmUgbm90IGNsaWNrZWRcbiAgICAgICAgICAgICAgaWYgKCFlbGVtZW50WzBdLmNvbnRhaW5zKGUudGFyZ2V0KSAmJiAhdG9vbHRpcFswXS5jb250YWlucyhlLnRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICBoaWRlVG9vbHRpcEJpbmQoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBLZXlib2FyZEV2ZW50IGhhbmRsZXIgdG8gaGlkZSB0aGUgdG9vbHRpcCBvbiBFc2NhcGUga2V5IHByZXNzXG4gICAgICAgICAgICBmdW5jdGlvbiBoaWRlT25Fc2NhcGVLZXkoZSkge1xuICAgICAgICAgICAgICBpZiAoZS53aGljaCA9PT0gMjcpIHtcbiAgICAgICAgICAgICAgICBoaWRlVG9vbHRpcEJpbmQoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdW5yZWdpc3RlclRyaWdnZXJzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHRyaWdnZXJzLnNob3cuZm9yRWFjaChmdW5jdGlvbih0cmlnZ2VyKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRyaWdnZXIgPT09ICdvdXRzaWRlQ2xpY2snKSB7XG4gICAgICAgICAgICAgICAgICBlbGVtZW50Lm9mZignY2xpY2snLCB0b2dnbGVUb29sdGlwQmluZCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGVsZW1lbnQub2ZmKHRyaWdnZXIsIHNob3dUb29sdGlwQmluZCk7XG4gICAgICAgICAgICAgICAgICBlbGVtZW50Lm9mZih0cmlnZ2VyLCB0b2dnbGVUb29sdGlwQmluZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsZW1lbnQub2ZmKCdrZXlwcmVzcycsIGhpZGVPbkVzY2FwZUtleSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB0cmlnZ2Vycy5oaWRlLmZvckVhY2goZnVuY3Rpb24odHJpZ2dlcikge1xuICAgICAgICAgICAgICAgIGlmICh0cmlnZ2VyID09PSAnb3V0c2lkZUNsaWNrJykge1xuICAgICAgICAgICAgICAgICAgJGRvY3VtZW50Lm9mZignY2xpY2snLCBib2R5SGlkZVRvb2x0aXBCaW5kKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgZWxlbWVudC5vZmYodHJpZ2dlciwgaGlkZVRvb2x0aXBCaW5kKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gcHJlcFRyaWdnZXJzKCkge1xuICAgICAgICAgICAgICB2YXIgc2hvd1RyaWdnZXJzID0gW10sIGhpZGVUcmlnZ2VycyA9IFtdO1xuICAgICAgICAgICAgICB2YXIgdmFsID0gc2NvcGUuJGV2YWwoYXR0cnNbcHJlZml4ICsgJ1RyaWdnZXInXSk7XG4gICAgICAgICAgICAgIHVucmVnaXN0ZXJUcmlnZ2VycygpO1xuXG4gICAgICAgICAgICAgIGlmIChhbmd1bGFyLmlzT2JqZWN0KHZhbCkpIHtcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyh2YWwpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgICBzaG93VHJpZ2dlcnMucHVzaChrZXkpO1xuICAgICAgICAgICAgICAgICAgaGlkZVRyaWdnZXJzLnB1c2godmFsW2tleV0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRyaWdnZXJzID0ge1xuICAgICAgICAgICAgICAgICAgc2hvdzogc2hvd1RyaWdnZXJzLFxuICAgICAgICAgICAgICAgICAgaGlkZTogaGlkZVRyaWdnZXJzXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0cmlnZ2VycyA9IGdldFRyaWdnZXJzKHZhbCk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAodHJpZ2dlcnMuc2hvdyAhPT0gJ25vbmUnKSB7XG4gICAgICAgICAgICAgICAgdHJpZ2dlcnMuc2hvdy5mb3JFYWNoKGZ1bmN0aW9uKHRyaWdnZXIsIGlkeCkge1xuICAgICAgICAgICAgICAgICAgaWYgKHRyaWdnZXIgPT09ICdvdXRzaWRlQ2xpY2snKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQub24oJ2NsaWNrJywgdG9nZ2xlVG9vbHRpcEJpbmQpO1xuICAgICAgICAgICAgICAgICAgICAkZG9jdW1lbnQub24oJ2NsaWNrJywgYm9keUhpZGVUb29sdGlwQmluZCk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRyaWdnZXIgPT09IHRyaWdnZXJzLmhpZGVbaWR4XSkge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50Lm9uKHRyaWdnZXIsIHRvZ2dsZVRvb2x0aXBCaW5kKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHJpZ2dlcikge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50Lm9uKHRyaWdnZXIsIHNob3dUb29sdGlwQmluZCk7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQub24odHJpZ2dlcnMuaGlkZVtpZHhdLCBoaWRlVG9vbHRpcEJpbmQpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZWxlbWVudC5vbigna2V5cHJlc3MnLCBoaWRlT25Fc2NhcGVLZXkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHByZXBUcmlnZ2VycygpO1xuXG4gICAgICAgICAgICB2YXIgYW5pbWF0aW9uID0gc2NvcGUuJGV2YWwoYXR0cnNbcHJlZml4ICsgJ0FuaW1hdGlvbiddKTtcbiAgICAgICAgICAgIHR0U2NvcGUuYW5pbWF0aW9uID0gYW5ndWxhci5pc0RlZmluZWQoYW5pbWF0aW9uKSA/ICEhYW5pbWF0aW9uIDogb3B0aW9ucy5hbmltYXRpb247XG5cbiAgICAgICAgICAgIHZhciBhcHBlbmRUb0JvZHlWYWw7XG4gICAgICAgICAgICB2YXIgYXBwZW5kS2V5ID0gcHJlZml4ICsgJ0FwcGVuZFRvQm9keSc7XG4gICAgICAgICAgICBpZiAoYXBwZW5kS2V5IGluIGF0dHJzICYmIGF0dHJzW2FwcGVuZEtleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBhcHBlbmRUb0JvZHlWYWwgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYXBwZW5kVG9Cb2R5VmFsID0gc2NvcGUuJGV2YWwoYXR0cnNbYXBwZW5kS2V5XSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGFwcGVuZFRvQm9keSA9IGFuZ3VsYXIuaXNEZWZpbmVkKGFwcGVuZFRvQm9keVZhbCkgPyBhcHBlbmRUb0JvZHlWYWwgOiBhcHBlbmRUb0JvZHk7XG5cbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0b29sdGlwIGlzIGRlc3Ryb3llZCBhbmQgcmVtb3ZlZC5cbiAgICAgICAgICAgIHNjb3BlLiRvbignJGRlc3Ryb3knLCBmdW5jdGlvbiBvbkRlc3Ryb3lUb29sdGlwKCkge1xuICAgICAgICAgICAgICB1bnJlZ2lzdGVyVHJpZ2dlcnMoKTtcbiAgICAgICAgICAgICAgcmVtb3ZlVG9vbHRpcCgpO1xuICAgICAgICAgICAgICB0dFNjb3BlID0gbnVsbDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfTtcbiAgfV07XG59KVxuXG4vLyBUaGlzIGlzIG1vc3RseSBuZ0luY2x1ZGUgY29kZSBidXQgd2l0aCBhIGN1c3RvbSBzY29wZVxuLmRpcmVjdGl2ZSgndWliVG9vbHRpcFRlbXBsYXRlVHJhbnNjbHVkZScsIFtcbiAgICAgICAgICckYW5pbWF0ZScsICckc2NlJywgJyRjb21waWxlJywgJyR0ZW1wbGF0ZVJlcXVlc3QnLFxuZnVuY3Rpb24gKCRhbmltYXRlLCAkc2NlLCAkY29tcGlsZSwgJHRlbXBsYXRlUmVxdWVzdCkge1xuICByZXR1cm4ge1xuICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtLCBhdHRycykge1xuICAgICAgdmFyIG9yaWdTY29wZSA9IHNjb3BlLiRldmFsKGF0dHJzLnRvb2x0aXBUZW1wbGF0ZVRyYW5zY2x1ZGVTY29wZSk7XG5cbiAgICAgIHZhciBjaGFuZ2VDb3VudGVyID0gMCxcbiAgICAgICAgY3VycmVudFNjb3BlLFxuICAgICAgICBwcmV2aW91c0VsZW1lbnQsXG4gICAgICAgIGN1cnJlbnRFbGVtZW50O1xuXG4gICAgICB2YXIgY2xlYW51cExhc3RJbmNsdWRlQ29udGVudCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAocHJldmlvdXNFbGVtZW50KSB7XG4gICAgICAgICAgcHJldmlvdXNFbGVtZW50LnJlbW92ZSgpO1xuICAgICAgICAgIHByZXZpb3VzRWxlbWVudCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY3VycmVudFNjb3BlKSB7XG4gICAgICAgICAgY3VycmVudFNjb3BlLiRkZXN0cm95KCk7XG4gICAgICAgICAgY3VycmVudFNjb3BlID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjdXJyZW50RWxlbWVudCkge1xuICAgICAgICAgICRhbmltYXRlLmxlYXZlKGN1cnJlbnRFbGVtZW50KS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcHJldmlvdXNFbGVtZW50ID0gbnVsbDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBwcmV2aW91c0VsZW1lbnQgPSBjdXJyZW50RWxlbWVudDtcbiAgICAgICAgICBjdXJyZW50RWxlbWVudCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHNjb3BlLiR3YXRjaCgkc2NlLnBhcnNlQXNSZXNvdXJjZVVybChhdHRycy51aWJUb29sdGlwVGVtcGxhdGVUcmFuc2NsdWRlKSwgZnVuY3Rpb24oc3JjKSB7XG4gICAgICAgIHZhciB0aGlzQ2hhbmdlSWQgPSArK2NoYW5nZUNvdW50ZXI7XG5cbiAgICAgICAgaWYgKHNyYykge1xuICAgICAgICAgIC8vc2V0IHRoZSAybmQgcGFyYW0gdG8gdHJ1ZSB0byBpZ25vcmUgdGhlIHRlbXBsYXRlIHJlcXVlc3QgZXJyb3Igc28gdGhhdCB0aGUgaW5uZXJcbiAgICAgICAgICAvL2NvbnRlbnRzIGFuZCBzY29wZSBjYW4gYmUgY2xlYW5lZCB1cC5cbiAgICAgICAgICAkdGVtcGxhdGVSZXF1ZXN0KHNyYywgdHJ1ZSkudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAgICAgaWYgKHRoaXNDaGFuZ2VJZCAhPT0gY2hhbmdlQ291bnRlcikgeyByZXR1cm47IH1cbiAgICAgICAgICAgIHZhciBuZXdTY29wZSA9IG9yaWdTY29wZS4kbmV3KCk7XG4gICAgICAgICAgICB2YXIgdGVtcGxhdGUgPSByZXNwb25zZTtcblxuICAgICAgICAgICAgdmFyIGNsb25lID0gJGNvbXBpbGUodGVtcGxhdGUpKG5ld1Njb3BlLCBmdW5jdGlvbihjbG9uZSkge1xuICAgICAgICAgICAgICBjbGVhbnVwTGFzdEluY2x1ZGVDb250ZW50KCk7XG4gICAgICAgICAgICAgICRhbmltYXRlLmVudGVyKGNsb25lLCBlbGVtKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjdXJyZW50U2NvcGUgPSBuZXdTY29wZTtcbiAgICAgICAgICAgIGN1cnJlbnRFbGVtZW50ID0gY2xvbmU7XG5cbiAgICAgICAgICAgIGN1cnJlbnRTY29wZS4kZW1pdCgnJGluY2x1ZGVDb250ZW50TG9hZGVkJywgc3JjKTtcbiAgICAgICAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICh0aGlzQ2hhbmdlSWQgPT09IGNoYW5nZUNvdW50ZXIpIHtcbiAgICAgICAgICAgICAgY2xlYW51cExhc3RJbmNsdWRlQ29udGVudCgpO1xuICAgICAgICAgICAgICBzY29wZS4kZW1pdCgnJGluY2x1ZGVDb250ZW50RXJyb3InLCBzcmMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHNjb3BlLiRlbWl0KCckaW5jbHVkZUNvbnRlbnRSZXF1ZXN0ZWQnLCBzcmMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNsZWFudXBMYXN0SW5jbHVkZUNvbnRlbnQoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHNjb3BlLiRvbignJGRlc3Ryb3knLCBjbGVhbnVwTGFzdEluY2x1ZGVDb250ZW50KTtcbiAgICB9XG4gIH07XG59XSlcblxuLyoqXG4gKiBOb3RlIHRoYXQgaXQncyBpbnRlbnRpb25hbCB0aGF0IHRoZXNlIGNsYXNzZXMgYXJlICpub3QqIGFwcGxpZWQgdGhyb3VnaCAkYW5pbWF0ZS5cbiAqIFRoZXkgbXVzdCBub3QgYmUgYW5pbWF0ZWQgYXMgdGhleSdyZSBleHBlY3RlZCB0byBiZSBwcmVzZW50IG9uIHRoZSB0b29sdGlwIG9uXG4gKiBpbml0aWFsaXphdGlvbi5cbiAqL1xuLmRpcmVjdGl2ZSgndWliVG9vbHRpcENsYXNzZXMnLCBbJyR1aWJQb3NpdGlvbicsIGZ1bmN0aW9uKCR1aWJQb3NpdGlvbikge1xuICByZXR1cm4ge1xuICAgIHJlc3RyaWN0OiAnQScsXG4gICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHJzKSB7XG4gICAgICAvLyBuZWVkIHRvIHNldCB0aGUgcHJpbWFyeSBwb3NpdGlvbiBzbyB0aGVcbiAgICAgIC8vIGFycm93IGhhcyBzcGFjZSBkdXJpbmcgcG9zaXRpb24gbWVhc3VyZS5cbiAgICAgIC8vIHRvb2x0aXAucG9zaXRpb25Ub29sdGlwKClcbiAgICAgIGlmIChzY29wZS5wbGFjZW1lbnQpIHtcbiAgICAgICAgLy8gLy8gVGhlcmUgYXJlIG5vIHRvcC1sZWZ0IGV0Yy4uLiBjbGFzc2VzXG4gICAgICAgIC8vIC8vIGluIFRXQlMsIHNvIHdlIG5lZWQgdGhlIHByaW1hcnkgcG9zaXRpb24uXG4gICAgICAgIHZhciBwb3NpdGlvbiA9ICR1aWJQb3NpdGlvbi5wYXJzZVBsYWNlbWVudChzY29wZS5wbGFjZW1lbnQpO1xuICAgICAgICBlbGVtZW50LmFkZENsYXNzKHBvc2l0aW9uWzBdKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNjb3BlLnBvcHVwQ2xhc3MpIHtcbiAgICAgICAgZWxlbWVudC5hZGRDbGFzcyhzY29wZS5wb3B1cENsYXNzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNjb3BlLmFuaW1hdGlvbikge1xuICAgICAgICBlbGVtZW50LmFkZENsYXNzKGF0dHJzLnRvb2x0aXBBbmltYXRpb25DbGFzcyk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufV0pXG5cbi5kaXJlY3RpdmUoJ3VpYlRvb2x0aXBQb3B1cCcsIGZ1bmN0aW9uKCkge1xuICByZXR1cm4ge1xuICAgIHJlc3RyaWN0OiAnQScsXG4gICAgc2NvcGU6IHsgY29udGVudDogJ0AnIH0sXG4gICAgdGVtcGxhdGVVcmw6ICd1aWIvdGVtcGxhdGUvdG9vbHRpcC90b29sdGlwLXBvcHVwLmh0bWwnXG4gIH07XG59KVxuXG4uZGlyZWN0aXZlKCd1aWJUb29sdGlwJywgWyAnJHVpYlRvb2x0aXAnLCBmdW5jdGlvbigkdWliVG9vbHRpcCkge1xuICByZXR1cm4gJHVpYlRvb2x0aXAoJ3VpYlRvb2x0aXAnLCAndG9vbHRpcCcsICdtb3VzZWVudGVyJyk7XG59XSlcblxuLmRpcmVjdGl2ZSgndWliVG9vbHRpcFRlbXBsYXRlUG9wdXAnLCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHtcbiAgICByZXN0cmljdDogJ0EnLFxuICAgIHNjb3BlOiB7IGNvbnRlbnRFeHA6ICcmJywgb3JpZ2luU2NvcGU6ICcmJyB9LFxuICAgIHRlbXBsYXRlVXJsOiAndWliL3RlbXBsYXRlL3Rvb2x0aXAvdG9vbHRpcC10ZW1wbGF0ZS1wb3B1cC5odG1sJ1xuICB9O1xufSlcblxuLmRpcmVjdGl2ZSgndWliVG9vbHRpcFRlbXBsYXRlJywgWyckdWliVG9vbHRpcCcsIGZ1bmN0aW9uKCR1aWJUb29sdGlwKSB7XG4gIHJldHVybiAkdWliVG9vbHRpcCgndWliVG9vbHRpcFRlbXBsYXRlJywgJ3Rvb2x0aXAnLCAnbW91c2VlbnRlcicsIHtcbiAgICB1c2VDb250ZW50RXhwOiB0cnVlXG4gIH0pO1xufV0pXG5cbi5kaXJlY3RpdmUoJ3VpYlRvb2x0aXBIdG1sUG9wdXAnLCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHtcbiAgICByZXN0cmljdDogJ0EnLFxuICAgIHNjb3BlOiB7IGNvbnRlbnRFeHA6ICcmJyB9LFxuICAgIHRlbXBsYXRlVXJsOiAndWliL3RlbXBsYXRlL3Rvb2x0aXAvdG9vbHRpcC1odG1sLXBvcHVwLmh0bWwnXG4gIH07XG59KVxuXG4uZGlyZWN0aXZlKCd1aWJUb29sdGlwSHRtbCcsIFsnJHVpYlRvb2x0aXAnLCBmdW5jdGlvbigkdWliVG9vbHRpcCkge1xuICByZXR1cm4gJHVpYlRvb2x0aXAoJ3VpYlRvb2x0aXBIdG1sJywgJ3Rvb2x0aXAnLCAnbW91c2VlbnRlcicsIHtcbiAgICB1c2VDb250ZW50RXhwOiB0cnVlXG4gIH0pO1xufV0pO1xuXG4vKipcbiAqIFRoZSBmb2xsb3dpbmcgZmVhdHVyZXMgYXJlIHN0aWxsIG91dHN0YW5kaW5nOiBwb3B1cCBkZWxheSwgYW5pbWF0aW9uIGFzIGFcbiAqIGZ1bmN0aW9uLCBwbGFjZW1lbnQgYXMgYSBmdW5jdGlvbiwgaW5zaWRlLCBzdXBwb3J0IGZvciBtb3JlIHRyaWdnZXJzIHRoYW5cbiAqIGp1c3QgbW91c2UgZW50ZXIvbGVhdmUsIGFuZCBzZWxlY3RvciBkZWxlZ2F0YXRpb24uXG4gKi9cbmFuZ3VsYXIubW9kdWxlKCd1aS5ib290c3RyYXAucG9wb3ZlcicsIFsndWkuYm9vdHN0cmFwLnRvb2x0aXAnXSlcblxuLmRpcmVjdGl2ZSgndWliUG9wb3ZlclRlbXBsYXRlUG9wdXAnLCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHtcbiAgICByZXN0cmljdDogJ0EnLFxuICAgIHNjb3BlOiB7IHVpYlRpdGxlOiAnQCcsIGNvbnRlbnRFeHA6ICcmJywgb3JpZ2luU2NvcGU6ICcmJyB9LFxuICAgIHRlbXBsYXRlVXJsOiAndWliL3RlbXBsYXRlL3BvcG92ZXIvcG9wb3Zlci10ZW1wbGF0ZS5odG1sJ1xuICB9O1xufSlcblxuLmRpcmVjdGl2ZSgndWliUG9wb3ZlclRlbXBsYXRlJywgWyckdWliVG9vbHRpcCcsIGZ1bmN0aW9uKCR1aWJUb29sdGlwKSB7XG4gIHJldHVybiAkdWliVG9vbHRpcCgndWliUG9wb3ZlclRlbXBsYXRlJywgJ3BvcG92ZXInLCAnY2xpY2snLCB7XG4gICAgdXNlQ29udGVudEV4cDogdHJ1ZVxuICB9KTtcbn1dKVxuXG4uZGlyZWN0aXZlKCd1aWJQb3BvdmVySHRtbFBvcHVwJywgZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7XG4gICAgcmVzdHJpY3Q6ICdBJyxcbiAgICBzY29wZTogeyBjb250ZW50RXhwOiAnJicsIHVpYlRpdGxlOiAnQCcgfSxcbiAgICB0ZW1wbGF0ZVVybDogJ3VpYi90ZW1wbGF0ZS9wb3BvdmVyL3BvcG92ZXItaHRtbC5odG1sJ1xuICB9O1xufSlcblxuLmRpcmVjdGl2ZSgndWliUG9wb3Zlckh0bWwnLCBbJyR1aWJUb29sdGlwJywgZnVuY3Rpb24oJHVpYlRvb2x0aXApIHtcbiAgcmV0dXJuICR1aWJUb29sdGlwKCd1aWJQb3BvdmVySHRtbCcsICdwb3BvdmVyJywgJ2NsaWNrJywge1xuICAgIHVzZUNvbnRlbnRFeHA6IHRydWVcbiAgfSk7XG59XSlcblxuLmRpcmVjdGl2ZSgndWliUG9wb3ZlclBvcHVwJywgZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7XG4gICAgcmVzdHJpY3Q6ICdBJyxcbiAgICBzY29wZTogeyB1aWJUaXRsZTogJ0AnLCBjb250ZW50OiAnQCcgfSxcbiAgICB0ZW1wbGF0ZVVybDogJ3VpYi90ZW1wbGF0ZS9wb3BvdmVyL3BvcG92ZXIuaHRtbCdcbiAgfTtcbn0pXG5cbi5kaXJlY3RpdmUoJ3VpYlBvcG92ZXInLCBbJyR1aWJUb29sdGlwJywgZnVuY3Rpb24oJHVpYlRvb2x0aXApIHtcbiAgcmV0dXJuICR1aWJUb29sdGlwKCd1aWJQb3BvdmVyJywgJ3BvcG92ZXInLCAnY2xpY2snKTtcbn1dKTtcblxuYW5ndWxhci5tb2R1bGUoJ3VpLmJvb3RzdHJhcC5wcm9ncmVzc2JhcicsIFtdKVxuXG4uY29uc3RhbnQoJ3VpYlByb2dyZXNzQ29uZmlnJywge1xuICBhbmltYXRlOiB0cnVlLFxuICBtYXg6IDEwMFxufSlcblxuLmNvbnRyb2xsZXIoJ1VpYlByb2dyZXNzQ29udHJvbGxlcicsIFsnJHNjb3BlJywgJyRhdHRycycsICd1aWJQcm9ncmVzc0NvbmZpZycsIGZ1bmN0aW9uKCRzY29wZSwgJGF0dHJzLCBwcm9ncmVzc0NvbmZpZykge1xuICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICBhbmltYXRlID0gYW5ndWxhci5pc0RlZmluZWQoJGF0dHJzLmFuaW1hdGUpID8gJHNjb3BlLiRwYXJlbnQuJGV2YWwoJGF0dHJzLmFuaW1hdGUpIDogcHJvZ3Jlc3NDb25maWcuYW5pbWF0ZTtcblxuICB0aGlzLmJhcnMgPSBbXTtcbiAgJHNjb3BlLm1heCA9IGdldE1heE9yRGVmYXVsdCgpO1xuXG4gIHRoaXMuYWRkQmFyID0gZnVuY3Rpb24oYmFyLCBlbGVtZW50LCBhdHRycykge1xuICAgIGlmICghYW5pbWF0ZSkge1xuICAgICAgZWxlbWVudC5jc3Moeyd0cmFuc2l0aW9uJzogJ25vbmUnfSk7XG4gICAgfVxuXG4gICAgdGhpcy5iYXJzLnB1c2goYmFyKTtcblxuICAgIGJhci5tYXggPSBnZXRNYXhPckRlZmF1bHQoKTtcbiAgICBiYXIudGl0bGUgPSBhdHRycyAmJiBhbmd1bGFyLmlzRGVmaW5lZChhdHRycy50aXRsZSkgPyBhdHRycy50aXRsZSA6ICdwcm9ncmVzc2Jhcic7XG5cbiAgICBiYXIuJHdhdGNoKCd2YWx1ZScsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICBiYXIucmVjYWxjdWxhdGVQZXJjZW50YWdlKCk7XG4gICAgfSk7XG5cbiAgICBiYXIucmVjYWxjdWxhdGVQZXJjZW50YWdlID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdG90YWxQZXJjZW50YWdlID0gc2VsZi5iYXJzLnJlZHVjZShmdW5jdGlvbih0b3RhbCwgYmFyKSB7XG4gICAgICAgIGJhci5wZXJjZW50ID0gKygxMDAgKiBiYXIudmFsdWUgLyBiYXIubWF4KS50b0ZpeGVkKDIpO1xuICAgICAgICByZXR1cm4gdG90YWwgKyBiYXIucGVyY2VudDtcbiAgICAgIH0sIDApO1xuXG4gICAgICBpZiAodG90YWxQZXJjZW50YWdlID4gMTAwKSB7XG4gICAgICAgIGJhci5wZXJjZW50IC09IHRvdGFsUGVyY2VudGFnZSAtIDEwMDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgYmFyLiRvbignJGRlc3Ryb3knLCBmdW5jdGlvbigpIHtcbiAgICAgIGVsZW1lbnQgPSBudWxsO1xuICAgICAgc2VsZi5yZW1vdmVCYXIoYmFyKTtcbiAgICB9KTtcbiAgfTtcblxuICB0aGlzLnJlbW92ZUJhciA9IGZ1bmN0aW9uKGJhcikge1xuICAgIHRoaXMuYmFycy5zcGxpY2UodGhpcy5iYXJzLmluZGV4T2YoYmFyKSwgMSk7XG4gICAgdGhpcy5iYXJzLmZvckVhY2goZnVuY3Rpb24gKGJhcikge1xuICAgICAgYmFyLnJlY2FsY3VsYXRlUGVyY2VudGFnZSgpO1xuICAgIH0pO1xuICB9O1xuXG4gIC8vJGF0dHJzLiRvYnNlcnZlKCdtYXhQYXJhbScsIGZ1bmN0aW9uKG1heFBhcmFtKSB7XG4gICRzY29wZS4kd2F0Y2goJ21heFBhcmFtJywgZnVuY3Rpb24obWF4UGFyYW0pIHtcbiAgICBzZWxmLmJhcnMuZm9yRWFjaChmdW5jdGlvbihiYXIpIHtcbiAgICAgIGJhci5tYXggPSBnZXRNYXhPckRlZmF1bHQoKTtcbiAgICAgIGJhci5yZWNhbGN1bGF0ZVBlcmNlbnRhZ2UoKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZnVuY3Rpb24gZ2V0TWF4T3JEZWZhdWx0ICgpIHtcbiAgICByZXR1cm4gYW5ndWxhci5pc0RlZmluZWQoJHNjb3BlLm1heFBhcmFtKSA/ICRzY29wZS5tYXhQYXJhbSA6IHByb2dyZXNzQ29uZmlnLm1heDtcbiAgfVxufV0pXG5cbi5kaXJlY3RpdmUoJ3VpYlByb2dyZXNzJywgZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7XG4gICAgcmVwbGFjZTogdHJ1ZSxcbiAgICB0cmFuc2NsdWRlOiB0cnVlLFxuICAgIGNvbnRyb2xsZXI6ICdVaWJQcm9ncmVzc0NvbnRyb2xsZXInLFxuICAgIHJlcXVpcmU6ICd1aWJQcm9ncmVzcycsXG4gICAgc2NvcGU6IHtcbiAgICAgIG1heFBhcmFtOiAnPT9tYXgnXG4gICAgfSxcbiAgICB0ZW1wbGF0ZVVybDogJ3VpYi90ZW1wbGF0ZS9wcm9ncmVzc2Jhci9wcm9ncmVzcy5odG1sJ1xuICB9O1xufSlcblxuLmRpcmVjdGl2ZSgndWliQmFyJywgZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7XG4gICAgcmVwbGFjZTogdHJ1ZSxcbiAgICB0cmFuc2NsdWRlOiB0cnVlLFxuICAgIHJlcXVpcmU6ICdedWliUHJvZ3Jlc3MnLFxuICAgIHNjb3BlOiB7XG4gICAgICB2YWx1ZTogJz0nLFxuICAgICAgdHlwZTogJ0AnXG4gICAgfSxcbiAgICB0ZW1wbGF0ZVVybDogJ3VpYi90ZW1wbGF0ZS9wcm9ncmVzc2Jhci9iYXIuaHRtbCcsXG4gICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHJzLCBwcm9ncmVzc0N0cmwpIHtcbiAgICAgIHByb2dyZXNzQ3RybC5hZGRCYXIoc2NvcGUsIGVsZW1lbnQsIGF0dHJzKTtcbiAgICB9XG4gIH07XG59KVxuXG4uZGlyZWN0aXZlKCd1aWJQcm9ncmVzc2JhcicsIGZ1bmN0aW9uKCkge1xuICByZXR1cm4ge1xuICAgIHJlcGxhY2U6IHRydWUsXG4gICAgdHJhbnNjbHVkZTogdHJ1ZSxcbiAgICBjb250cm9sbGVyOiAnVWliUHJvZ3Jlc3NDb250cm9sbGVyJyxcbiAgICBzY29wZToge1xuICAgICAgdmFsdWU6ICc9JyxcbiAgICAgIG1heFBhcmFtOiAnPT9tYXgnLFxuICAgICAgdHlwZTogJ0AnXG4gICAgfSxcbiAgICB0ZW1wbGF0ZVVybDogJ3VpYi90ZW1wbGF0ZS9wcm9ncmVzc2Jhci9wcm9ncmVzc2Jhci5odG1sJyxcbiAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cnMsIHByb2dyZXNzQ3RybCkge1xuICAgICAgcHJvZ3Jlc3NDdHJsLmFkZEJhcihzY29wZSwgYW5ndWxhci5lbGVtZW50KGVsZW1lbnQuY2hpbGRyZW4oKVswXSksIHt0aXRsZTogYXR0cnMudGl0bGV9KTtcbiAgICB9XG4gIH07XG59KTtcblxuYW5ndWxhci5tb2R1bGUoJ3VpLmJvb3RzdHJhcC5yYXRpbmcnLCBbXSlcblxuLmNvbnN0YW50KCd1aWJSYXRpbmdDb25maWcnLCB7XG4gIG1heDogNSxcbiAgc3RhdGVPbjogbnVsbCxcbiAgc3RhdGVPZmY6IG51bGwsXG4gIGVuYWJsZVJlc2V0OiB0cnVlLFxuICB0aXRsZXM6IFsnb25lJywgJ3R3bycsICd0aHJlZScsICdmb3VyJywgJ2ZpdmUnXVxufSlcblxuLmNvbnRyb2xsZXIoJ1VpYlJhdGluZ0NvbnRyb2xsZXInLCBbJyRzY29wZScsICckYXR0cnMnLCAndWliUmF0aW5nQ29uZmlnJywgZnVuY3Rpb24oJHNjb3BlLCAkYXR0cnMsIHJhdGluZ0NvbmZpZykge1xuICB2YXIgbmdNb2RlbEN0cmwgPSB7ICRzZXRWaWV3VmFsdWU6IGFuZ3VsYXIubm9vcCB9LFxuICAgIHNlbGYgPSB0aGlzO1xuXG4gIHRoaXMuaW5pdCA9IGZ1bmN0aW9uKG5nTW9kZWxDdHJsXykge1xuICAgIG5nTW9kZWxDdHJsID0gbmdNb2RlbEN0cmxfO1xuICAgIG5nTW9kZWxDdHJsLiRyZW5kZXIgPSB0aGlzLnJlbmRlcjtcblxuICAgIG5nTW9kZWxDdHJsLiRmb3JtYXR0ZXJzLnB1c2goZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIGlmIChhbmd1bGFyLmlzTnVtYmVyKHZhbHVlKSAmJiB2YWx1ZSA8PCAwICE9PSB2YWx1ZSkge1xuICAgICAgICB2YWx1ZSA9IE1hdGgucm91bmQodmFsdWUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSk7XG5cbiAgICB0aGlzLnN0YXRlT24gPSBhbmd1bGFyLmlzRGVmaW5lZCgkYXR0cnMuc3RhdGVPbikgPyAkc2NvcGUuJHBhcmVudC4kZXZhbCgkYXR0cnMuc3RhdGVPbikgOiByYXRpbmdDb25maWcuc3RhdGVPbjtcbiAgICB0aGlzLnN0YXRlT2ZmID0gYW5ndWxhci5pc0RlZmluZWQoJGF0dHJzLnN0YXRlT2ZmKSA/ICRzY29wZS4kcGFyZW50LiRldmFsKCRhdHRycy5zdGF0ZU9mZikgOiByYXRpbmdDb25maWcuc3RhdGVPZmY7XG4gICAgdGhpcy5lbmFibGVSZXNldCA9IGFuZ3VsYXIuaXNEZWZpbmVkKCRhdHRycy5lbmFibGVSZXNldCkgP1xuICAgICAgJHNjb3BlLiRwYXJlbnQuJGV2YWwoJGF0dHJzLmVuYWJsZVJlc2V0KSA6IHJhdGluZ0NvbmZpZy5lbmFibGVSZXNldDtcbiAgICB2YXIgdG1wVGl0bGVzID0gYW5ndWxhci5pc0RlZmluZWQoJGF0dHJzLnRpdGxlcykgPyAkc2NvcGUuJHBhcmVudC4kZXZhbCgkYXR0cnMudGl0bGVzKSA6IHJhdGluZ0NvbmZpZy50aXRsZXM7XG4gICAgdGhpcy50aXRsZXMgPSBhbmd1bGFyLmlzQXJyYXkodG1wVGl0bGVzKSAmJiB0bXBUaXRsZXMubGVuZ3RoID4gMCA/XG4gICAgICB0bXBUaXRsZXMgOiByYXRpbmdDb25maWcudGl0bGVzO1xuXG4gICAgdmFyIHJhdGluZ1N0YXRlcyA9IGFuZ3VsYXIuaXNEZWZpbmVkKCRhdHRycy5yYXRpbmdTdGF0ZXMpID9cbiAgICAgICRzY29wZS4kcGFyZW50LiRldmFsKCRhdHRycy5yYXRpbmdTdGF0ZXMpIDpcbiAgICAgIG5ldyBBcnJheShhbmd1bGFyLmlzRGVmaW5lZCgkYXR0cnMubWF4KSA/ICRzY29wZS4kcGFyZW50LiRldmFsKCRhdHRycy5tYXgpIDogcmF0aW5nQ29uZmlnLm1heCk7XG4gICAgJHNjb3BlLnJhbmdlID0gdGhpcy5idWlsZFRlbXBsYXRlT2JqZWN0cyhyYXRpbmdTdGF0ZXMpO1xuICB9O1xuXG4gIHRoaXMuYnVpbGRUZW1wbGF0ZU9iamVjdHMgPSBmdW5jdGlvbihzdGF0ZXMpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbiA9IHN0YXRlcy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgIHN0YXRlc1tpXSA9IGFuZ3VsYXIuZXh0ZW5kKHsgaW5kZXg6IGkgfSwgeyBzdGF0ZU9uOiB0aGlzLnN0YXRlT24sIHN0YXRlT2ZmOiB0aGlzLnN0YXRlT2ZmLCB0aXRsZTogdGhpcy5nZXRUaXRsZShpKSB9LCBzdGF0ZXNbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gc3RhdGVzO1xuICB9O1xuXG4gIHRoaXMuZ2V0VGl0bGUgPSBmdW5jdGlvbihpbmRleCkge1xuICAgIGlmIChpbmRleCA+PSB0aGlzLnRpdGxlcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBpbmRleCArIDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMudGl0bGVzW2luZGV4XTtcbiAgfTtcblxuICAkc2NvcGUucmF0ZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgaWYgKCEkc2NvcGUucmVhZG9ubHkgJiYgdmFsdWUgPj0gMCAmJiB2YWx1ZSA8PSAkc2NvcGUucmFuZ2UubGVuZ3RoKSB7XG4gICAgICB2YXIgbmV3Vmlld1ZhbHVlID0gc2VsZi5lbmFibGVSZXNldCAmJiBuZ01vZGVsQ3RybC4kdmlld1ZhbHVlID09PSB2YWx1ZSA/IDAgOiB2YWx1ZTtcbiAgICAgIG5nTW9kZWxDdHJsLiRzZXRWaWV3VmFsdWUobmV3Vmlld1ZhbHVlKTtcbiAgICAgIG5nTW9kZWxDdHJsLiRyZW5kZXIoKTtcbiAgICB9XG4gIH07XG5cbiAgJHNjb3BlLmVudGVyID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICBpZiAoISRzY29wZS5yZWFkb25seSkge1xuICAgICAgJHNjb3BlLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgICRzY29wZS5vbkhvdmVyKHt2YWx1ZTogdmFsdWV9KTtcbiAgfTtcblxuICAkc2NvcGUucmVzZXQgPSBmdW5jdGlvbigpIHtcbiAgICAkc2NvcGUudmFsdWUgPSBuZ01vZGVsQ3RybC4kdmlld1ZhbHVlO1xuICAgICRzY29wZS5vbkxlYXZlKCk7XG4gIH07XG5cbiAgJHNjb3BlLm9uS2V5ZG93biA9IGZ1bmN0aW9uKGV2dCkge1xuICAgIGlmICgvKDM3fDM4fDM5fDQwKS8udGVzdChldnQud2hpY2gpKSB7XG4gICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICRzY29wZS5yYXRlKCRzY29wZS52YWx1ZSArIChldnQud2hpY2ggPT09IDM4IHx8IGV2dC53aGljaCA9PT0gMzkgPyAxIDogLTEpKTtcbiAgICB9XG4gIH07XG5cbiAgdGhpcy5yZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgICAkc2NvcGUudmFsdWUgPSBuZ01vZGVsQ3RybC4kdmlld1ZhbHVlO1xuICAgICRzY29wZS50aXRsZSA9IHNlbGYuZ2V0VGl0bGUoJHNjb3BlLnZhbHVlIC0gMSk7XG4gIH07XG59XSlcblxuLmRpcmVjdGl2ZSgndWliUmF0aW5nJywgZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7XG4gICAgcmVxdWlyZTogWyd1aWJSYXRpbmcnLCAnbmdNb2RlbCddLFxuICAgIHJlc3RyaWN0OiAnQScsXG4gICAgc2NvcGU6IHtcbiAgICAgIHJlYWRvbmx5OiAnPT9yZWFkT25seScsXG4gICAgICBvbkhvdmVyOiAnJicsXG4gICAgICBvbkxlYXZlOiAnJidcbiAgICB9LFxuICAgIGNvbnRyb2xsZXI6ICdVaWJSYXRpbmdDb250cm9sbGVyJyxcbiAgICB0ZW1wbGF0ZVVybDogJ3VpYi90ZW1wbGF0ZS9yYXRpbmcvcmF0aW5nLmh0bWwnLFxuICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRycywgY3RybHMpIHtcbiAgICAgIHZhciByYXRpbmdDdHJsID0gY3RybHNbMF0sIG5nTW9kZWxDdHJsID0gY3RybHNbMV07XG4gICAgICByYXRpbmdDdHJsLmluaXQobmdNb2RlbEN0cmwpO1xuICAgIH1cbiAgfTtcbn0pO1xuXG5hbmd1bGFyLm1vZHVsZSgndWkuYm9vdHN0cmFwLnRhYnMnLCBbXSlcblxuLmNvbnRyb2xsZXIoJ1VpYlRhYnNldENvbnRyb2xsZXInLCBbJyRzY29wZScsIGZ1bmN0aW9uICgkc2NvcGUpIHtcbiAgdmFyIGN0cmwgPSB0aGlzLFxuICAgIG9sZEluZGV4O1xuICBjdHJsLnRhYnMgPSBbXTtcblxuICBjdHJsLnNlbGVjdCA9IGZ1bmN0aW9uKGluZGV4LCBldnQpIHtcbiAgICBpZiAoIWRlc3Ryb3llZCkge1xuICAgICAgdmFyIHByZXZpb3VzSW5kZXggPSBmaW5kVGFiSW5kZXgob2xkSW5kZXgpO1xuICAgICAgdmFyIHByZXZpb3VzU2VsZWN0ZWQgPSBjdHJsLnRhYnNbcHJldmlvdXNJbmRleF07XG4gICAgICBpZiAocHJldmlvdXNTZWxlY3RlZCkge1xuICAgICAgICBwcmV2aW91c1NlbGVjdGVkLnRhYi5vbkRlc2VsZWN0KHtcbiAgICAgICAgICAkZXZlbnQ6IGV2dCxcbiAgICAgICAgICAkc2VsZWN0ZWRJbmRleDogaW5kZXhcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChldnQgJiYgZXZ0LmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHByZXZpb3VzU2VsZWN0ZWQudGFiLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB2YXIgc2VsZWN0ZWQgPSBjdHJsLnRhYnNbaW5kZXhdO1xuICAgICAgaWYgKHNlbGVjdGVkKSB7XG4gICAgICAgIHNlbGVjdGVkLnRhYi5vblNlbGVjdCh7XG4gICAgICAgICAgJGV2ZW50OiBldnRcbiAgICAgICAgfSk7XG4gICAgICAgIHNlbGVjdGVkLnRhYi5hY3RpdmUgPSB0cnVlO1xuICAgICAgICBjdHJsLmFjdGl2ZSA9IHNlbGVjdGVkLmluZGV4O1xuICAgICAgICBvbGRJbmRleCA9IHNlbGVjdGVkLmluZGV4O1xuICAgICAgfSBlbHNlIGlmICghc2VsZWN0ZWQgJiYgYW5ndWxhci5pc0RlZmluZWQob2xkSW5kZXgpKSB7XG4gICAgICAgIGN0cmwuYWN0aXZlID0gbnVsbDtcbiAgICAgICAgb2xkSW5kZXggPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBjdHJsLmFkZFRhYiA9IGZ1bmN0aW9uIGFkZFRhYih0YWIpIHtcbiAgICBjdHJsLnRhYnMucHVzaCh7XG4gICAgICB0YWI6IHRhYixcbiAgICAgIGluZGV4OiB0YWIuaW5kZXhcbiAgICB9KTtcbiAgICBjdHJsLnRhYnMuc29ydChmdW5jdGlvbih0MSwgdDIpIHtcbiAgICAgIGlmICh0MS5pbmRleCA+IHQyLmluZGV4KSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuXG4gICAgICBpZiAodDEuaW5kZXggPCB0Mi5pbmRleCkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAwO1xuICAgIH0pO1xuXG4gICAgaWYgKHRhYi5pbmRleCA9PT0gY3RybC5hY3RpdmUgfHwgIWFuZ3VsYXIuaXNEZWZpbmVkKGN0cmwuYWN0aXZlKSAmJiBjdHJsLnRhYnMubGVuZ3RoID09PSAxKSB7XG4gICAgICB2YXIgbmV3QWN0aXZlSW5kZXggPSBmaW5kVGFiSW5kZXgodGFiLmluZGV4KTtcbiAgICAgIGN0cmwuc2VsZWN0KG5ld0FjdGl2ZUluZGV4KTtcbiAgICB9XG4gIH07XG5cbiAgY3RybC5yZW1vdmVUYWIgPSBmdW5jdGlvbiByZW1vdmVUYWIodGFiKSB7XG4gICAgdmFyIGluZGV4O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY3RybC50YWJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoY3RybC50YWJzW2ldLnRhYiA9PT0gdGFiKSB7XG4gICAgICAgIGluZGV4ID0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGN0cmwudGFic1tpbmRleF0uaW5kZXggPT09IGN0cmwuYWN0aXZlKSB7XG4gICAgICB2YXIgbmV3QWN0aXZlVGFiSW5kZXggPSBpbmRleCA9PT0gY3RybC50YWJzLmxlbmd0aCAtIDEgP1xuICAgICAgICBpbmRleCAtIDEgOiBpbmRleCArIDEgJSBjdHJsLnRhYnMubGVuZ3RoO1xuICAgICAgY3RybC5zZWxlY3QobmV3QWN0aXZlVGFiSW5kZXgpO1xuICAgIH1cblxuICAgIGN0cmwudGFicy5zcGxpY2UoaW5kZXgsIDEpO1xuICB9O1xuXG4gICRzY29wZS4kd2F0Y2goJ3RhYnNldC5hY3RpdmUnLCBmdW5jdGlvbih2YWwpIHtcbiAgICBpZiAoYW5ndWxhci5pc0RlZmluZWQodmFsKSAmJiB2YWwgIT09IG9sZEluZGV4KSB7XG4gICAgICBjdHJsLnNlbGVjdChmaW5kVGFiSW5kZXgodmFsKSk7XG4gICAgfVxuICB9KTtcblxuICB2YXIgZGVzdHJveWVkO1xuICAkc2NvcGUuJG9uKCckZGVzdHJveScsIGZ1bmN0aW9uKCkge1xuICAgIGRlc3Ryb3llZCA9IHRydWU7XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIGZpbmRUYWJJbmRleChpbmRleCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY3RybC50YWJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoY3RybC50YWJzW2ldLmluZGV4ID09PSBpbmRleCkge1xuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1dKVxuXG4uZGlyZWN0aXZlKCd1aWJUYWJzZXQnLCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHtcbiAgICB0cmFuc2NsdWRlOiB0cnVlLFxuICAgIHJlcGxhY2U6IHRydWUsXG4gICAgc2NvcGU6IHt9LFxuICAgIGJpbmRUb0NvbnRyb2xsZXI6IHtcbiAgICAgIGFjdGl2ZTogJz0/JyxcbiAgICAgIHR5cGU6ICdAJ1xuICAgIH0sXG4gICAgY29udHJvbGxlcjogJ1VpYlRhYnNldENvbnRyb2xsZXInLFxuICAgIGNvbnRyb2xsZXJBczogJ3RhYnNldCcsXG4gICAgdGVtcGxhdGVVcmw6IGZ1bmN0aW9uKGVsZW1lbnQsIGF0dHJzKSB7XG4gICAgICByZXR1cm4gYXR0cnMudGVtcGxhdGVVcmwgfHwgJ3VpYi90ZW1wbGF0ZS90YWJzL3RhYnNldC5odG1sJztcbiAgICB9LFxuICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRycykge1xuICAgICAgc2NvcGUudmVydGljYWwgPSBhbmd1bGFyLmlzRGVmaW5lZChhdHRycy52ZXJ0aWNhbCkgP1xuICAgICAgICBzY29wZS4kcGFyZW50LiRldmFsKGF0dHJzLnZlcnRpY2FsKSA6IGZhbHNlO1xuICAgICAgc2NvcGUuanVzdGlmaWVkID0gYW5ndWxhci5pc0RlZmluZWQoYXR0cnMuanVzdGlmaWVkKSA/XG4gICAgICAgIHNjb3BlLiRwYXJlbnQuJGV2YWwoYXR0cnMuanVzdGlmaWVkKSA6IGZhbHNlO1xuICAgIH1cbiAgfTtcbn0pXG5cbi5kaXJlY3RpdmUoJ3VpYlRhYicsIFsnJHBhcnNlJywgZnVuY3Rpb24oJHBhcnNlKSB7XG4gIHJldHVybiB7XG4gICAgcmVxdWlyZTogJ151aWJUYWJzZXQnLFxuICAgIHJlcGxhY2U6IHRydWUsXG4gICAgdGVtcGxhdGVVcmw6IGZ1bmN0aW9uKGVsZW1lbnQsIGF0dHJzKSB7XG4gICAgICByZXR1cm4gYXR0cnMudGVtcGxhdGVVcmwgfHwgJ3VpYi90ZW1wbGF0ZS90YWJzL3RhYi5odG1sJztcbiAgICB9LFxuICAgIHRyYW5zY2x1ZGU6IHRydWUsXG4gICAgc2NvcGU6IHtcbiAgICAgIGhlYWRpbmc6ICdAJyxcbiAgICAgIGluZGV4OiAnPT8nLFxuICAgICAgY2xhc3NlczogJ0A/JyxcbiAgICAgIG9uU2VsZWN0OiAnJnNlbGVjdCcsIC8vVGhpcyBjYWxsYmFjayBpcyBjYWxsZWQgaW4gY29udGVudEhlYWRpbmdUcmFuc2NsdWRlXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vb25jZSBpdCBpbnNlcnRzIHRoZSB0YWIncyBjb250ZW50IGludG8gdGhlIGRvbVxuICAgICAgb25EZXNlbGVjdDogJyZkZXNlbGVjdCdcbiAgICB9LFxuICAgIGNvbnRyb2xsZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgLy9FbXB0eSBjb250cm9sbGVyIHNvIG90aGVyIGRpcmVjdGl2ZXMgY2FuIHJlcXVpcmUgYmVpbmcgJ3VuZGVyJyBhIHRhYlxuICAgIH0sXG4gICAgY29udHJvbGxlckFzOiAndGFiJyxcbiAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxtLCBhdHRycywgdGFic2V0Q3RybCwgdHJhbnNjbHVkZSkge1xuICAgICAgc2NvcGUuZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgIGlmIChhdHRycy5kaXNhYmxlKSB7XG4gICAgICAgIHNjb3BlLiRwYXJlbnQuJHdhdGNoKCRwYXJzZShhdHRycy5kaXNhYmxlKSwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICBzY29wZS5kaXNhYmxlZCA9ICEhIHZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFuZ3VsYXIuaXNVbmRlZmluZWQoYXR0cnMuaW5kZXgpKSB7XG4gICAgICAgIGlmICh0YWJzZXRDdHJsLnRhYnMgJiYgdGFic2V0Q3RybC50YWJzLmxlbmd0aCkge1xuICAgICAgICAgIHNjb3BlLmluZGV4ID0gTWF0aC5tYXguYXBwbHkobnVsbCwgdGFic2V0Q3RybC50YWJzLm1hcChmdW5jdGlvbih0KSB7IHJldHVybiB0LmluZGV4OyB9KSkgKyAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNjb3BlLmluZGV4ID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoYW5ndWxhci5pc1VuZGVmaW5lZChhdHRycy5jbGFzc2VzKSkge1xuICAgICAgICBzY29wZS5jbGFzc2VzID0gJyc7XG4gICAgICB9XG5cbiAgICAgIHNjb3BlLnNlbGVjdCA9IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICBpZiAoIXNjb3BlLmRpc2FibGVkKSB7XG4gICAgICAgICAgdmFyIGluZGV4O1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGFic2V0Q3RybC50YWJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGFic2V0Q3RybC50YWJzW2ldLnRhYiA9PT0gc2NvcGUpIHtcbiAgICAgICAgICAgICAgaW5kZXggPSBpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0YWJzZXRDdHJsLnNlbGVjdChpbmRleCwgZXZ0KTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgdGFic2V0Q3RybC5hZGRUYWIoc2NvcGUpO1xuICAgICAgc2NvcGUuJG9uKCckZGVzdHJveScsIGZ1bmN0aW9uKCkge1xuICAgICAgICB0YWJzZXRDdHJsLnJlbW92ZVRhYihzY29wZSk7XG4gICAgICB9KTtcblxuICAgICAgLy9XZSBuZWVkIHRvIHRyYW5zY2x1ZGUgbGF0ZXIsIG9uY2UgdGhlIGNvbnRlbnQgY29udGFpbmVyIGlzIHJlYWR5LlxuICAgICAgLy93aGVuIHRoaXMgbGluayBoYXBwZW5zLCB3ZSdyZSBpbnNpZGUgYSB0YWIgaGVhZGluZy5cbiAgICAgIHNjb3BlLiR0cmFuc2NsdWRlRm4gPSB0cmFuc2NsdWRlO1xuICAgIH1cbiAgfTtcbn1dKVxuXG4uZGlyZWN0aXZlKCd1aWJUYWJIZWFkaW5nVHJhbnNjbHVkZScsIGZ1bmN0aW9uKCkge1xuICByZXR1cm4ge1xuICAgIHJlc3RyaWN0OiAnQScsXG4gICAgcmVxdWlyZTogJ151aWJUYWInLFxuICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbG0pIHtcbiAgICAgIHNjb3BlLiR3YXRjaCgnaGVhZGluZ0VsZW1lbnQnLCBmdW5jdGlvbiB1cGRhdGVIZWFkaW5nRWxlbWVudChoZWFkaW5nKSB7XG4gICAgICAgIGlmIChoZWFkaW5nKSB7XG4gICAgICAgICAgZWxtLmh0bWwoJycpO1xuICAgICAgICAgIGVsbS5hcHBlbmQoaGVhZGluZyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbn0pXG5cbi5kaXJlY3RpdmUoJ3VpYlRhYkNvbnRlbnRUcmFuc2NsdWRlJywgZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7XG4gICAgcmVzdHJpY3Q6ICdBJyxcbiAgICByZXF1aXJlOiAnXnVpYlRhYnNldCcsXG4gICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsbSwgYXR0cnMpIHtcbiAgICAgIHZhciB0YWIgPSBzY29wZS4kZXZhbChhdHRycy51aWJUYWJDb250ZW50VHJhbnNjbHVkZSkudGFiO1xuXG4gICAgICAvL05vdyBvdXIgdGFiIGlzIHJlYWR5IHRvIGJlIHRyYW5zY2x1ZGVkOiBib3RoIHRoZSB0YWIgaGVhZGluZyBhcmVhXG4gICAgICAvL2FuZCB0aGUgdGFiIGNvbnRlbnQgYXJlYSBhcmUgbG9hZGVkLiAgVHJhbnNjbHVkZSAnZW0gYm90aC5cbiAgICAgIHRhYi4kdHJhbnNjbHVkZUZuKHRhYi4kcGFyZW50LCBmdW5jdGlvbihjb250ZW50cykge1xuICAgICAgICBhbmd1bGFyLmZvckVhY2goY29udGVudHMsIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICBpZiAoaXNUYWJIZWFkaW5nKG5vZGUpKSB7XG4gICAgICAgICAgICAvL0xldCB0YWJIZWFkaW5nVHJhbnNjbHVkZSBrbm93LlxuICAgICAgICAgICAgdGFiLmhlYWRpbmdFbGVtZW50ID0gbm9kZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWxtLmFwcGVuZChub2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIGlzVGFiSGVhZGluZyhub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUudGFnTmFtZSAmJiAoXG4gICAgICBub2RlLmhhc0F0dHJpYnV0ZSgndWliLXRhYi1oZWFkaW5nJykgfHxcbiAgICAgIG5vZGUuaGFzQXR0cmlidXRlKCdkYXRhLXVpYi10YWItaGVhZGluZycpIHx8XG4gICAgICBub2RlLmhhc0F0dHJpYnV0ZSgneC11aWItdGFiLWhlYWRpbmcnKSB8fFxuICAgICAgbm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICd1aWItdGFiLWhlYWRpbmcnIHx8XG4gICAgICBub2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2RhdGEtdWliLXRhYi1oZWFkaW5nJyB8fFxuICAgICAgbm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICd4LXVpYi10YWItaGVhZGluZycgfHxcbiAgICAgIG5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAndWliOnRhYi1oZWFkaW5nJ1xuICAgICk7XG4gIH1cbn0pO1xuXG5hbmd1bGFyLm1vZHVsZSgndWkuYm9vdHN0cmFwLnRpbWVwaWNrZXInLCBbXSlcblxuLmNvbnN0YW50KCd1aWJUaW1lcGlja2VyQ29uZmlnJywge1xuICBob3VyU3RlcDogMSxcbiAgbWludXRlU3RlcDogMSxcbiAgc2Vjb25kU3RlcDogMSxcbiAgc2hvd01lcmlkaWFuOiB0cnVlLFxuICBzaG93U2Vjb25kczogZmFsc2UsXG4gIG1lcmlkaWFuczogbnVsbCxcbiAgcmVhZG9ubHlJbnB1dDogZmFsc2UsXG4gIG1vdXNld2hlZWw6IHRydWUsXG4gIGFycm93a2V5czogdHJ1ZSxcbiAgc2hvd1NwaW5uZXJzOiB0cnVlLFxuICB0ZW1wbGF0ZVVybDogJ3VpYi90ZW1wbGF0ZS90aW1lcGlja2VyL3RpbWVwaWNrZXIuaHRtbCdcbn0pXG5cbi5jb250cm9sbGVyKCdVaWJUaW1lcGlja2VyQ29udHJvbGxlcicsIFsnJHNjb3BlJywgJyRlbGVtZW50JywgJyRhdHRycycsICckcGFyc2UnLCAnJGxvZycsICckbG9jYWxlJywgJ3VpYlRpbWVwaWNrZXJDb25maWcnLCBmdW5jdGlvbigkc2NvcGUsICRlbGVtZW50LCAkYXR0cnMsICRwYXJzZSwgJGxvZywgJGxvY2FsZSwgdGltZXBpY2tlckNvbmZpZykge1xuICB2YXIgaG91cnNNb2RlbEN0cmwsIG1pbnV0ZXNNb2RlbEN0cmwsIHNlY29uZHNNb2RlbEN0cmw7XG4gIHZhciBzZWxlY3RlZCA9IG5ldyBEYXRlKCksXG4gICAgd2F0Y2hlcnMgPSBbXSxcbiAgICBuZ01vZGVsQ3RybCA9IHsgJHNldFZpZXdWYWx1ZTogYW5ndWxhci5ub29wIH0sIC8vIG51bGxNb2RlbEN0cmxcbiAgICBtZXJpZGlhbnMgPSBhbmd1bGFyLmlzRGVmaW5lZCgkYXR0cnMubWVyaWRpYW5zKSA/ICRzY29wZS4kcGFyZW50LiRldmFsKCRhdHRycy5tZXJpZGlhbnMpIDogdGltZXBpY2tlckNvbmZpZy5tZXJpZGlhbnMgfHwgJGxvY2FsZS5EQVRFVElNRV9GT1JNQVRTLkFNUE1TLFxuICAgIHBhZEhvdXJzID0gYW5ndWxhci5pc0RlZmluZWQoJGF0dHJzLnBhZEhvdXJzKSA/ICRzY29wZS4kcGFyZW50LiRldmFsKCRhdHRycy5wYWRIb3VycykgOiB0cnVlO1xuXG4gICRzY29wZS50YWJpbmRleCA9IGFuZ3VsYXIuaXNEZWZpbmVkKCRhdHRycy50YWJpbmRleCkgPyAkYXR0cnMudGFiaW5kZXggOiAwO1xuICAkZWxlbWVudC5yZW1vdmVBdHRyKCd0YWJpbmRleCcpO1xuXG4gIHRoaXMuaW5pdCA9IGZ1bmN0aW9uKG5nTW9kZWxDdHJsXywgaW5wdXRzKSB7XG4gICAgbmdNb2RlbEN0cmwgPSBuZ01vZGVsQ3RybF87XG4gICAgbmdNb2RlbEN0cmwuJHJlbmRlciA9IHRoaXMucmVuZGVyO1xuXG4gICAgbmdNb2RlbEN0cmwuJGZvcm1hdHRlcnMudW5zaGlmdChmdW5jdGlvbihtb2RlbFZhbHVlKSB7XG4gICAgICByZXR1cm4gbW9kZWxWYWx1ZSA/IG5ldyBEYXRlKG1vZGVsVmFsdWUpIDogbnVsbDtcbiAgICB9KTtcblxuICAgIHZhciBob3Vyc0lucHV0RWwgPSBpbnB1dHMuZXEoMCksXG4gICAgICAgIG1pbnV0ZXNJbnB1dEVsID0gaW5wdXRzLmVxKDEpLFxuICAgICAgICBzZWNvbmRzSW5wdXRFbCA9IGlucHV0cy5lcSgyKTtcblxuICAgIGhvdXJzTW9kZWxDdHJsID0gaG91cnNJbnB1dEVsLmNvbnRyb2xsZXIoJ25nTW9kZWwnKTtcbiAgICBtaW51dGVzTW9kZWxDdHJsID0gbWludXRlc0lucHV0RWwuY29udHJvbGxlcignbmdNb2RlbCcpO1xuICAgIHNlY29uZHNNb2RlbEN0cmwgPSBzZWNvbmRzSW5wdXRFbC5jb250cm9sbGVyKCduZ01vZGVsJyk7XG5cbiAgICB2YXIgbW91c2V3aGVlbCA9IGFuZ3VsYXIuaXNEZWZpbmVkKCRhdHRycy5tb3VzZXdoZWVsKSA/ICRzY29wZS4kcGFyZW50LiRldmFsKCRhdHRycy5tb3VzZXdoZWVsKSA6IHRpbWVwaWNrZXJDb25maWcubW91c2V3aGVlbDtcblxuICAgIGlmIChtb3VzZXdoZWVsKSB7XG4gICAgICB0aGlzLnNldHVwTW91c2V3aGVlbEV2ZW50cyhob3Vyc0lucHV0RWwsIG1pbnV0ZXNJbnB1dEVsLCBzZWNvbmRzSW5wdXRFbCk7XG4gICAgfVxuXG4gICAgdmFyIGFycm93a2V5cyA9IGFuZ3VsYXIuaXNEZWZpbmVkKCRhdHRycy5hcnJvd2tleXMpID8gJHNjb3BlLiRwYXJlbnQuJGV2YWwoJGF0dHJzLmFycm93a2V5cykgOiB0aW1lcGlja2VyQ29uZmlnLmFycm93a2V5cztcbiAgICBpZiAoYXJyb3drZXlzKSB7XG4gICAgICB0aGlzLnNldHVwQXJyb3drZXlFdmVudHMoaG91cnNJbnB1dEVsLCBtaW51dGVzSW5wdXRFbCwgc2Vjb25kc0lucHV0RWwpO1xuICAgIH1cblxuICAgICRzY29wZS5yZWFkb25seUlucHV0ID0gYW5ndWxhci5pc0RlZmluZWQoJGF0dHJzLnJlYWRvbmx5SW5wdXQpID8gJHNjb3BlLiRwYXJlbnQuJGV2YWwoJGF0dHJzLnJlYWRvbmx5SW5wdXQpIDogdGltZXBpY2tlckNvbmZpZy5yZWFkb25seUlucHV0O1xuICAgIHRoaXMuc2V0dXBJbnB1dEV2ZW50cyhob3Vyc0lucHV0RWwsIG1pbnV0ZXNJbnB1dEVsLCBzZWNvbmRzSW5wdXRFbCk7XG4gIH07XG5cbiAgdmFyIGhvdXJTdGVwID0gdGltZXBpY2tlckNvbmZpZy5ob3VyU3RlcDtcbiAgaWYgKCRhdHRycy5ob3VyU3RlcCkge1xuICAgIHdhdGNoZXJzLnB1c2goJHNjb3BlLiRwYXJlbnQuJHdhdGNoKCRwYXJzZSgkYXR0cnMuaG91clN0ZXApLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgaG91clN0ZXAgPSArdmFsdWU7XG4gICAgfSkpO1xuICB9XG5cbiAgdmFyIG1pbnV0ZVN0ZXAgPSB0aW1lcGlja2VyQ29uZmlnLm1pbnV0ZVN0ZXA7XG4gIGlmICgkYXR0cnMubWludXRlU3RlcCkge1xuICAgIHdhdGNoZXJzLnB1c2goJHNjb3BlLiRwYXJlbnQuJHdhdGNoKCRwYXJzZSgkYXR0cnMubWludXRlU3RlcCksIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICBtaW51dGVTdGVwID0gK3ZhbHVlO1xuICAgIH0pKTtcbiAgfVxuXG4gIHZhciBtaW47XG4gIHdhdGNoZXJzLnB1c2goJHNjb3BlLiRwYXJlbnQuJHdhdGNoKCRwYXJzZSgkYXR0cnMubWluKSwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICB2YXIgZHQgPSBuZXcgRGF0ZSh2YWx1ZSk7XG4gICAgbWluID0gaXNOYU4oZHQpID8gdW5kZWZpbmVkIDogZHQ7XG4gIH0pKTtcblxuICB2YXIgbWF4O1xuICB3YXRjaGVycy5wdXNoKCRzY29wZS4kcGFyZW50LiR3YXRjaCgkcGFyc2UoJGF0dHJzLm1heCksIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdmFyIGR0ID0gbmV3IERhdGUodmFsdWUpO1xuICAgIG1heCA9IGlzTmFOKGR0KSA/IHVuZGVmaW5lZCA6IGR0O1xuICB9KSk7XG5cbiAgdmFyIGRpc2FibGVkID0gZmFsc2U7XG4gIGlmICgkYXR0cnMubmdEaXNhYmxlZCkge1xuICAgIHdhdGNoZXJzLnB1c2goJHNjb3BlLiRwYXJlbnQuJHdhdGNoKCRwYXJzZSgkYXR0cnMubmdEaXNhYmxlZCksIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICBkaXNhYmxlZCA9IHZhbHVlO1xuICAgIH0pKTtcbiAgfVxuXG4gICRzY29wZS5ub0luY3JlbWVudEhvdXJzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGluY3JlbWVudGVkU2VsZWN0ZWQgPSBhZGRNaW51dGVzKHNlbGVjdGVkLCBob3VyU3RlcCAqIDYwKTtcbiAgICByZXR1cm4gZGlzYWJsZWQgfHwgaW5jcmVtZW50ZWRTZWxlY3RlZCA+IG1heCB8fFxuICAgICAgaW5jcmVtZW50ZWRTZWxlY3RlZCA8IHNlbGVjdGVkICYmIGluY3JlbWVudGVkU2VsZWN0ZWQgPCBtaW47XG4gIH07XG5cbiAgJHNjb3BlLm5vRGVjcmVtZW50SG91cnMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZGVjcmVtZW50ZWRTZWxlY3RlZCA9IGFkZE1pbnV0ZXMoc2VsZWN0ZWQsIC1ob3VyU3RlcCAqIDYwKTtcbiAgICByZXR1cm4gZGlzYWJsZWQgfHwgZGVjcmVtZW50ZWRTZWxlY3RlZCA8IG1pbiB8fFxuICAgICAgZGVjcmVtZW50ZWRTZWxlY3RlZCA+IHNlbGVjdGVkICYmIGRlY3JlbWVudGVkU2VsZWN0ZWQgPiBtYXg7XG4gIH07XG5cbiAgJHNjb3BlLm5vSW5jcmVtZW50TWludXRlcyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpbmNyZW1lbnRlZFNlbGVjdGVkID0gYWRkTWludXRlcyhzZWxlY3RlZCwgbWludXRlU3RlcCk7XG4gICAgcmV0dXJuIGRpc2FibGVkIHx8IGluY3JlbWVudGVkU2VsZWN0ZWQgPiBtYXggfHxcbiAgICAgIGluY3JlbWVudGVkU2VsZWN0ZWQgPCBzZWxlY3RlZCAmJiBpbmNyZW1lbnRlZFNlbGVjdGVkIDwgbWluO1xuICB9O1xuXG4gICRzY29wZS5ub0RlY3JlbWVudE1pbnV0ZXMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZGVjcmVtZW50ZWRTZWxlY3RlZCA9IGFkZE1pbnV0ZXMoc2VsZWN0ZWQsIC1taW51dGVTdGVwKTtcbiAgICByZXR1cm4gZGlzYWJsZWQgfHwgZGVjcmVtZW50ZWRTZWxlY3RlZCA8IG1pbiB8fFxuICAgICAgZGVjcmVtZW50ZWRTZWxlY3RlZCA+IHNlbGVjdGVkICYmIGRlY3JlbWVudGVkU2VsZWN0ZWQgPiBtYXg7XG4gIH07XG5cbiAgJHNjb3BlLm5vSW5jcmVtZW50U2Vjb25kcyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpbmNyZW1lbnRlZFNlbGVjdGVkID0gYWRkU2Vjb25kcyhzZWxlY3RlZCwgc2Vjb25kU3RlcCk7XG4gICAgcmV0dXJuIGRpc2FibGVkIHx8IGluY3JlbWVudGVkU2VsZWN0ZWQgPiBtYXggfHxcbiAgICAgIGluY3JlbWVudGVkU2VsZWN0ZWQgPCBzZWxlY3RlZCAmJiBpbmNyZW1lbnRlZFNlbGVjdGVkIDwgbWluO1xuICB9O1xuXG4gICRzY29wZS5ub0RlY3JlbWVudFNlY29uZHMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZGVjcmVtZW50ZWRTZWxlY3RlZCA9IGFkZFNlY29uZHMoc2VsZWN0ZWQsIC1zZWNvbmRTdGVwKTtcbiAgICByZXR1cm4gZGlzYWJsZWQgfHwgZGVjcmVtZW50ZWRTZWxlY3RlZCA8IG1pbiB8fFxuICAgICAgZGVjcmVtZW50ZWRTZWxlY3RlZCA+IHNlbGVjdGVkICYmIGRlY3JlbWVudGVkU2VsZWN0ZWQgPiBtYXg7XG4gIH07XG5cbiAgJHNjb3BlLm5vVG9nZ2xlTWVyaWRpYW4gPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoc2VsZWN0ZWQuZ2V0SG91cnMoKSA8IDEyKSB7XG4gICAgICByZXR1cm4gZGlzYWJsZWQgfHwgYWRkTWludXRlcyhzZWxlY3RlZCwgMTIgKiA2MCkgPiBtYXg7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRpc2FibGVkIHx8IGFkZE1pbnV0ZXMoc2VsZWN0ZWQsIC0xMiAqIDYwKSA8IG1pbjtcbiAgfTtcblxuICB2YXIgc2Vjb25kU3RlcCA9IHRpbWVwaWNrZXJDb25maWcuc2Vjb25kU3RlcDtcbiAgaWYgKCRhdHRycy5zZWNvbmRTdGVwKSB7XG4gICAgd2F0Y2hlcnMucHVzaCgkc2NvcGUuJHBhcmVudC4kd2F0Y2goJHBhcnNlKCRhdHRycy5zZWNvbmRTdGVwKSwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHNlY29uZFN0ZXAgPSArdmFsdWU7XG4gICAgfSkpO1xuICB9XG5cbiAgJHNjb3BlLnNob3dTZWNvbmRzID0gdGltZXBpY2tlckNvbmZpZy5zaG93U2Vjb25kcztcbiAgaWYgKCRhdHRycy5zaG93U2Vjb25kcykge1xuICAgIHdhdGNoZXJzLnB1c2goJHNjb3BlLiRwYXJlbnQuJHdhdGNoKCRwYXJzZSgkYXR0cnMuc2hvd1NlY29uZHMpLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgJHNjb3BlLnNob3dTZWNvbmRzID0gISF2YWx1ZTtcbiAgICB9KSk7XG4gIH1cblxuICAvLyAxMkggLyAyNEggbW9kZVxuICAkc2NvcGUuc2hvd01lcmlkaWFuID0gdGltZXBpY2tlckNvbmZpZy5zaG93TWVyaWRpYW47XG4gIGlmICgkYXR0cnMuc2hvd01lcmlkaWFuKSB7XG4gICAgd2F0Y2hlcnMucHVzaCgkc2NvcGUuJHBhcmVudC4kd2F0Y2goJHBhcnNlKCRhdHRycy5zaG93TWVyaWRpYW4pLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgJHNjb3BlLnNob3dNZXJpZGlhbiA9ICEhdmFsdWU7XG5cbiAgICAgIGlmIChuZ01vZGVsQ3RybC4kZXJyb3IudGltZSkge1xuICAgICAgICAvLyBFdmFsdWF0ZSBmcm9tIHRlbXBsYXRlXG4gICAgICAgIHZhciBob3VycyA9IGdldEhvdXJzRnJvbVRlbXBsYXRlKCksIG1pbnV0ZXMgPSBnZXRNaW51dGVzRnJvbVRlbXBsYXRlKCk7XG4gICAgICAgIGlmIChhbmd1bGFyLmlzRGVmaW5lZChob3VycykgJiYgYW5ndWxhci5pc0RlZmluZWQobWludXRlcykpIHtcbiAgICAgICAgICBzZWxlY3RlZC5zZXRIb3Vycyhob3Vycyk7XG4gICAgICAgICAgcmVmcmVzaCgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1cGRhdGVUZW1wbGF0ZSgpO1xuICAgICAgfVxuICAgIH0pKTtcbiAgfVxuXG4gIC8vIEdldCAkc2NvcGUuaG91cnMgaW4gMjRIIG1vZGUgaWYgdmFsaWRcbiAgZnVuY3Rpb24gZ2V0SG91cnNGcm9tVGVtcGxhdGUoKSB7XG4gICAgdmFyIGhvdXJzID0gKyRzY29wZS5ob3VycztcbiAgICB2YXIgdmFsaWQgPSAkc2NvcGUuc2hvd01lcmlkaWFuID8gaG91cnMgPiAwICYmIGhvdXJzIDwgMTMgOlxuICAgICAgaG91cnMgPj0gMCAmJiBob3VycyA8IDI0O1xuICAgIGlmICghdmFsaWQgfHwgJHNjb3BlLmhvdXJzID09PSAnJykge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBpZiAoJHNjb3BlLnNob3dNZXJpZGlhbikge1xuICAgICAgaWYgKGhvdXJzID09PSAxMikge1xuICAgICAgICBob3VycyA9IDA7XG4gICAgICB9XG4gICAgICBpZiAoJHNjb3BlLm1lcmlkaWFuID09PSBtZXJpZGlhbnNbMV0pIHtcbiAgICAgICAgaG91cnMgPSBob3VycyArIDEyO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaG91cnM7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRNaW51dGVzRnJvbVRlbXBsYXRlKCkge1xuICAgIHZhciBtaW51dGVzID0gKyRzY29wZS5taW51dGVzO1xuICAgIHZhciB2YWxpZCA9IG1pbnV0ZXMgPj0gMCAmJiBtaW51dGVzIDwgNjA7XG4gICAgaWYgKCF2YWxpZCB8fCAkc2NvcGUubWludXRlcyA9PT0gJycpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiBtaW51dGVzO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0U2Vjb25kc0Zyb21UZW1wbGF0ZSgpIHtcbiAgICB2YXIgc2Vjb25kcyA9ICskc2NvcGUuc2Vjb25kcztcbiAgICByZXR1cm4gc2Vjb25kcyA+PSAwICYmIHNlY29uZHMgPCA2MCA/IHNlY29uZHMgOiB1bmRlZmluZWQ7XG4gIH1cblxuICBmdW5jdGlvbiBwYWQodmFsdWUsIG5vUGFkKSB7XG4gICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFuZ3VsYXIuaXNEZWZpbmVkKHZhbHVlKSAmJiB2YWx1ZS50b1N0cmluZygpLmxlbmd0aCA8IDIgJiYgIW5vUGFkID9cbiAgICAgICcwJyArIHZhbHVlIDogdmFsdWUudG9TdHJpbmcoKTtcbiAgfVxuXG4gIC8vIFJlc3BvbmQgb24gbW91c2V3aGVlbCBzcGluXG4gIHRoaXMuc2V0dXBNb3VzZXdoZWVsRXZlbnRzID0gZnVuY3Rpb24oaG91cnNJbnB1dEVsLCBtaW51dGVzSW5wdXRFbCwgc2Vjb25kc0lucHV0RWwpIHtcbiAgICB2YXIgaXNTY3JvbGxpbmdVcCA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgIGlmIChlLm9yaWdpbmFsRXZlbnQpIHtcbiAgICAgICAgZSA9IGUub3JpZ2luYWxFdmVudDtcbiAgICAgIH1cbiAgICAgIC8vcGljayBjb3JyZWN0IGRlbHRhIHZhcmlhYmxlIGRlcGVuZGluZyBvbiBldmVudFxuICAgICAgdmFyIGRlbHRhID0gZS53aGVlbERlbHRhID8gZS53aGVlbERlbHRhIDogLWUuZGVsdGFZO1xuICAgICAgcmV0dXJuIGUuZGV0YWlsIHx8IGRlbHRhID4gMDtcbiAgICB9O1xuXG4gICAgaG91cnNJbnB1dEVsLm9uKCdtb3VzZXdoZWVsIHdoZWVsJywgZnVuY3Rpb24oZSkge1xuICAgICAgaWYgKCFkaXNhYmxlZCkge1xuICAgICAgICAkc2NvcGUuJGFwcGx5KGlzU2Nyb2xsaW5nVXAoZSkgPyAkc2NvcGUuaW5jcmVtZW50SG91cnMoKSA6ICRzY29wZS5kZWNyZW1lbnRIb3VycygpKTtcbiAgICAgIH1cbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB9KTtcblxuICAgIG1pbnV0ZXNJbnB1dEVsLm9uKCdtb3VzZXdoZWVsIHdoZWVsJywgZnVuY3Rpb24oZSkge1xuICAgICAgaWYgKCFkaXNhYmxlZCkge1xuICAgICAgICAkc2NvcGUuJGFwcGx5KGlzU2Nyb2xsaW5nVXAoZSkgPyAkc2NvcGUuaW5jcmVtZW50TWludXRlcygpIDogJHNjb3BlLmRlY3JlbWVudE1pbnV0ZXMoKSk7XG4gICAgICB9XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfSk7XG5cbiAgICAgc2Vjb25kc0lucHV0RWwub24oJ21vdXNld2hlZWwgd2hlZWwnLCBmdW5jdGlvbihlKSB7XG4gICAgICBpZiAoIWRpc2FibGVkKSB7XG4gICAgICAgICRzY29wZS4kYXBwbHkoaXNTY3JvbGxpbmdVcChlKSA/ICRzY29wZS5pbmNyZW1lbnRTZWNvbmRzKCkgOiAkc2NvcGUuZGVjcmVtZW50U2Vjb25kcygpKTtcbiAgICAgIH1cbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB9KTtcbiAgfTtcblxuICAvLyBSZXNwb25kIG9uIHVwL2Rvd24gYXJyb3drZXlzXG4gIHRoaXMuc2V0dXBBcnJvd2tleUV2ZW50cyA9IGZ1bmN0aW9uKGhvdXJzSW5wdXRFbCwgbWludXRlc0lucHV0RWwsIHNlY29uZHNJbnB1dEVsKSB7XG4gICAgaG91cnNJbnB1dEVsLm9uKCdrZXlkb3duJywgZnVuY3Rpb24oZSkge1xuICAgICAgaWYgKCFkaXNhYmxlZCkge1xuICAgICAgICBpZiAoZS53aGljaCA9PT0gMzgpIHsgLy8gdXBcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgJHNjb3BlLmluY3JlbWVudEhvdXJzKCk7XG4gICAgICAgICAgJHNjb3BlLiRhcHBseSgpO1xuICAgICAgICB9IGVsc2UgaWYgKGUud2hpY2ggPT09IDQwKSB7IC8vIGRvd25cbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgJHNjb3BlLmRlY3JlbWVudEhvdXJzKCk7XG4gICAgICAgICAgJHNjb3BlLiRhcHBseSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBtaW51dGVzSW5wdXRFbC5vbigna2V5ZG93bicsIGZ1bmN0aW9uKGUpIHtcbiAgICAgIGlmICghZGlzYWJsZWQpIHtcbiAgICAgICAgaWYgKGUud2hpY2ggPT09IDM4KSB7IC8vIHVwXG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICRzY29wZS5pbmNyZW1lbnRNaW51dGVzKCk7XG4gICAgICAgICAgJHNjb3BlLiRhcHBseSgpO1xuICAgICAgICB9IGVsc2UgaWYgKGUud2hpY2ggPT09IDQwKSB7IC8vIGRvd25cbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgJHNjb3BlLmRlY3JlbWVudE1pbnV0ZXMoKTtcbiAgICAgICAgICAkc2NvcGUuJGFwcGx5KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHNlY29uZHNJbnB1dEVsLm9uKCdrZXlkb3duJywgZnVuY3Rpb24oZSkge1xuICAgICAgaWYgKCFkaXNhYmxlZCkge1xuICAgICAgICBpZiAoZS53aGljaCA9PT0gMzgpIHsgLy8gdXBcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgJHNjb3BlLmluY3JlbWVudFNlY29uZHMoKTtcbiAgICAgICAgICAkc2NvcGUuJGFwcGx5KCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZS53aGljaCA9PT0gNDApIHsgLy8gZG93blxuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAkc2NvcGUuZGVjcmVtZW50U2Vjb25kcygpO1xuICAgICAgICAgICRzY29wZS4kYXBwbHkoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIHRoaXMuc2V0dXBJbnB1dEV2ZW50cyA9IGZ1bmN0aW9uKGhvdXJzSW5wdXRFbCwgbWludXRlc0lucHV0RWwsIHNlY29uZHNJbnB1dEVsKSB7XG4gICAgaWYgKCRzY29wZS5yZWFkb25seUlucHV0KSB7XG4gICAgICAkc2NvcGUudXBkYXRlSG91cnMgPSBhbmd1bGFyLm5vb3A7XG4gICAgICAkc2NvcGUudXBkYXRlTWludXRlcyA9IGFuZ3VsYXIubm9vcDtcbiAgICAgICRzY29wZS51cGRhdGVTZWNvbmRzID0gYW5ndWxhci5ub29wO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBpbnZhbGlkYXRlID0gZnVuY3Rpb24oaW52YWxpZEhvdXJzLCBpbnZhbGlkTWludXRlcywgaW52YWxpZFNlY29uZHMpIHtcbiAgICAgIG5nTW9kZWxDdHJsLiRzZXRWaWV3VmFsdWUobnVsbCk7XG4gICAgICBuZ01vZGVsQ3RybC4kc2V0VmFsaWRpdHkoJ3RpbWUnLCBmYWxzZSk7XG4gICAgICBpZiAoYW5ndWxhci5pc0RlZmluZWQoaW52YWxpZEhvdXJzKSkge1xuICAgICAgICAkc2NvcGUuaW52YWxpZEhvdXJzID0gaW52YWxpZEhvdXJzO1xuICAgICAgICBpZiAoaG91cnNNb2RlbEN0cmwpIHtcbiAgICAgICAgICBob3Vyc01vZGVsQ3RybC4kc2V0VmFsaWRpdHkoJ2hvdXJzJywgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChhbmd1bGFyLmlzRGVmaW5lZChpbnZhbGlkTWludXRlcykpIHtcbiAgICAgICAgJHNjb3BlLmludmFsaWRNaW51dGVzID0gaW52YWxpZE1pbnV0ZXM7XG4gICAgICAgIGlmIChtaW51dGVzTW9kZWxDdHJsKSB7XG4gICAgICAgICAgbWludXRlc01vZGVsQ3RybC4kc2V0VmFsaWRpdHkoJ21pbnV0ZXMnLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGFuZ3VsYXIuaXNEZWZpbmVkKGludmFsaWRTZWNvbmRzKSkge1xuICAgICAgICAkc2NvcGUuaW52YWxpZFNlY29uZHMgPSBpbnZhbGlkU2Vjb25kcztcbiAgICAgICAgaWYgKHNlY29uZHNNb2RlbEN0cmwpIHtcbiAgICAgICAgICBzZWNvbmRzTW9kZWxDdHJsLiRzZXRWYWxpZGl0eSgnc2Vjb25kcycsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICAkc2NvcGUudXBkYXRlSG91cnMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBob3VycyA9IGdldEhvdXJzRnJvbVRlbXBsYXRlKCksXG4gICAgICAgIG1pbnV0ZXMgPSBnZXRNaW51dGVzRnJvbVRlbXBsYXRlKCk7XG5cbiAgICAgIG5nTW9kZWxDdHJsLiRzZXREaXJ0eSgpO1xuXG4gICAgICBpZiAoYW5ndWxhci5pc0RlZmluZWQoaG91cnMpICYmIGFuZ3VsYXIuaXNEZWZpbmVkKG1pbnV0ZXMpKSB7XG4gICAgICAgIHNlbGVjdGVkLnNldEhvdXJzKGhvdXJzKTtcbiAgICAgICAgc2VsZWN0ZWQuc2V0TWludXRlcyhtaW51dGVzKTtcbiAgICAgICAgaWYgKHNlbGVjdGVkIDwgbWluIHx8IHNlbGVjdGVkID4gbWF4KSB7XG4gICAgICAgICAgaW52YWxpZGF0ZSh0cnVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWZyZXNoKCdoJyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGludmFsaWRhdGUodHJ1ZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGhvdXJzSW5wdXRFbC5vbignYmx1cicsIGZ1bmN0aW9uKGUpIHtcbiAgICAgIG5nTW9kZWxDdHJsLiRzZXRUb3VjaGVkKCk7XG4gICAgICBpZiAobW9kZWxJc0VtcHR5KCkpIHtcbiAgICAgICAgbWFrZVZhbGlkKCk7XG4gICAgICB9IGVsc2UgaWYgKCRzY29wZS5ob3VycyA9PT0gbnVsbCB8fCAkc2NvcGUuaG91cnMgPT09ICcnKSB7XG4gICAgICAgIGludmFsaWRhdGUodHJ1ZSk7XG4gICAgICB9IGVsc2UgaWYgKCEkc2NvcGUuaW52YWxpZEhvdXJzICYmICRzY29wZS5ob3VycyA8IDEwKSB7XG4gICAgICAgICRzY29wZS4kYXBwbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgJHNjb3BlLmhvdXJzID0gcGFkKCRzY29wZS5ob3VycywgIXBhZEhvdXJzKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAkc2NvcGUudXBkYXRlTWludXRlcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG1pbnV0ZXMgPSBnZXRNaW51dGVzRnJvbVRlbXBsYXRlKCksXG4gICAgICAgIGhvdXJzID0gZ2V0SG91cnNGcm9tVGVtcGxhdGUoKTtcblxuICAgICAgbmdNb2RlbEN0cmwuJHNldERpcnR5KCk7XG5cbiAgICAgIGlmIChhbmd1bGFyLmlzRGVmaW5lZChtaW51dGVzKSAmJiBhbmd1bGFyLmlzRGVmaW5lZChob3VycykpIHtcbiAgICAgICAgc2VsZWN0ZWQuc2V0SG91cnMoaG91cnMpO1xuICAgICAgICBzZWxlY3RlZC5zZXRNaW51dGVzKG1pbnV0ZXMpO1xuICAgICAgICBpZiAoc2VsZWN0ZWQgPCBtaW4gfHwgc2VsZWN0ZWQgPiBtYXgpIHtcbiAgICAgICAgICBpbnZhbGlkYXRlKHVuZGVmaW5lZCwgdHJ1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVmcmVzaCgnbScpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnZhbGlkYXRlKHVuZGVmaW5lZCwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIG1pbnV0ZXNJbnB1dEVsLm9uKCdibHVyJywgZnVuY3Rpb24oZSkge1xuICAgICAgbmdNb2RlbEN0cmwuJHNldFRvdWNoZWQoKTtcbiAgICAgIGlmIChtb2RlbElzRW1wdHkoKSkge1xuICAgICAgICBtYWtlVmFsaWQoKTtcbiAgICAgIH0gZWxzZSBpZiAoJHNjb3BlLm1pbnV0ZXMgPT09IG51bGwpIHtcbiAgICAgICAgaW52YWxpZGF0ZSh1bmRlZmluZWQsIHRydWUpO1xuICAgICAgfSBlbHNlIGlmICghJHNjb3BlLmludmFsaWRNaW51dGVzICYmICRzY29wZS5taW51dGVzIDwgMTApIHtcbiAgICAgICAgJHNjb3BlLiRhcHBseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAkc2NvcGUubWludXRlcyA9IHBhZCgkc2NvcGUubWludXRlcyk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgJHNjb3BlLnVwZGF0ZVNlY29uZHMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzZWNvbmRzID0gZ2V0U2Vjb25kc0Zyb21UZW1wbGF0ZSgpO1xuXG4gICAgICBuZ01vZGVsQ3RybC4kc2V0RGlydHkoKTtcblxuICAgICAgaWYgKGFuZ3VsYXIuaXNEZWZpbmVkKHNlY29uZHMpKSB7XG4gICAgICAgIHNlbGVjdGVkLnNldFNlY29uZHMoc2Vjb25kcyk7XG4gICAgICAgIHJlZnJlc2goJ3MnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGludmFsaWRhdGUodW5kZWZpbmVkLCB1bmRlZmluZWQsIHRydWUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBzZWNvbmRzSW5wdXRFbC5vbignYmx1cicsIGZ1bmN0aW9uKGUpIHtcbiAgICAgIGlmIChtb2RlbElzRW1wdHkoKSkge1xuICAgICAgICBtYWtlVmFsaWQoKTtcbiAgICAgIH0gZWxzZSBpZiAoISRzY29wZS5pbnZhbGlkU2Vjb25kcyAmJiAkc2NvcGUuc2Vjb25kcyA8IDEwKSB7XG4gICAgICAgICRzY29wZS4kYXBwbHkoIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICRzY29wZS5zZWNvbmRzID0gcGFkKCRzY29wZS5zZWNvbmRzKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgfTtcblxuICB0aGlzLnJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBkYXRlID0gbmdNb2RlbEN0cmwuJHZpZXdWYWx1ZTtcblxuICAgIGlmIChpc05hTihkYXRlKSkge1xuICAgICAgbmdNb2RlbEN0cmwuJHNldFZhbGlkaXR5KCd0aW1lJywgZmFsc2UpO1xuICAgICAgJGxvZy5lcnJvcignVGltZXBpY2tlciBkaXJlY3RpdmU6IFwibmctbW9kZWxcIiB2YWx1ZSBtdXN0IGJlIGEgRGF0ZSBvYmplY3QsIGEgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBzaW5jZSAwMS4wMS4xOTcwIG9yIGEgc3RyaW5nIHJlcHJlc2VudGluZyBhbiBSRkMyODIyIG9yIElTTyA4NjAxIGRhdGUuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChkYXRlKSB7XG4gICAgICAgIHNlbGVjdGVkID0gZGF0ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNlbGVjdGVkIDwgbWluIHx8IHNlbGVjdGVkID4gbWF4KSB7XG4gICAgICAgIG5nTW9kZWxDdHJsLiRzZXRWYWxpZGl0eSgndGltZScsIGZhbHNlKTtcbiAgICAgICAgJHNjb3BlLmludmFsaWRIb3VycyA9IHRydWU7XG4gICAgICAgICRzY29wZS5pbnZhbGlkTWludXRlcyA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYWtlVmFsaWQoKTtcbiAgICAgIH1cbiAgICAgIHVwZGF0ZVRlbXBsYXRlKCk7XG4gICAgfVxuICB9O1xuXG4gIC8vIENhbGwgaW50ZXJuYWxseSB3aGVuIHdlIGtub3cgdGhhdCBtb2RlbCBpcyB2YWxpZC5cbiAgZnVuY3Rpb24gcmVmcmVzaChrZXlib2FyZENoYW5nZSkge1xuICAgIG1ha2VWYWxpZCgpO1xuICAgIG5nTW9kZWxDdHJsLiRzZXRWaWV3VmFsdWUobmV3IERhdGUoc2VsZWN0ZWQpKTtcbiAgICB1cGRhdGVUZW1wbGF0ZShrZXlib2FyZENoYW5nZSk7XG4gIH1cblxuICBmdW5jdGlvbiBtYWtlVmFsaWQoKSB7XG4gICAgaWYgKGhvdXJzTW9kZWxDdHJsKSB7XG4gICAgICBob3Vyc01vZGVsQ3RybC4kc2V0VmFsaWRpdHkoJ2hvdXJzJywgdHJ1ZSk7XG4gICAgfVxuXG4gICAgaWYgKG1pbnV0ZXNNb2RlbEN0cmwpIHtcbiAgICAgIG1pbnV0ZXNNb2RlbEN0cmwuJHNldFZhbGlkaXR5KCdtaW51dGVzJywgdHJ1ZSk7XG4gICAgfVxuXG4gICAgaWYgKHNlY29uZHNNb2RlbEN0cmwpIHtcbiAgICAgIHNlY29uZHNNb2RlbEN0cmwuJHNldFZhbGlkaXR5KCdzZWNvbmRzJywgdHJ1ZSk7XG4gICAgfVxuXG4gICAgbmdNb2RlbEN0cmwuJHNldFZhbGlkaXR5KCd0aW1lJywgdHJ1ZSk7XG4gICAgJHNjb3BlLmludmFsaWRIb3VycyA9IGZhbHNlO1xuICAgICRzY29wZS5pbnZhbGlkTWludXRlcyA9IGZhbHNlO1xuICAgICRzY29wZS5pbnZhbGlkU2Vjb25kcyA9IGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlVGVtcGxhdGUoa2V5Ym9hcmRDaGFuZ2UpIHtcbiAgICBpZiAoIW5nTW9kZWxDdHJsLiRtb2RlbFZhbHVlKSB7XG4gICAgICAkc2NvcGUuaG91cnMgPSBudWxsO1xuICAgICAgJHNjb3BlLm1pbnV0ZXMgPSBudWxsO1xuICAgICAgJHNjb3BlLnNlY29uZHMgPSBudWxsO1xuICAgICAgJHNjb3BlLm1lcmlkaWFuID0gbWVyaWRpYW5zWzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaG91cnMgPSBzZWxlY3RlZC5nZXRIb3VycygpLFxuICAgICAgICBtaW51dGVzID0gc2VsZWN0ZWQuZ2V0TWludXRlcygpLFxuICAgICAgICBzZWNvbmRzID0gc2VsZWN0ZWQuZ2V0U2Vjb25kcygpO1xuXG4gICAgICBpZiAoJHNjb3BlLnNob3dNZXJpZGlhbikge1xuICAgICAgICBob3VycyA9IGhvdXJzID09PSAwIHx8IGhvdXJzID09PSAxMiA/IDEyIDogaG91cnMgJSAxMjsgLy8gQ29udmVydCAyNCB0byAxMiBob3VyIHN5c3RlbVxuICAgICAgfVxuXG4gICAgICAkc2NvcGUuaG91cnMgPSBrZXlib2FyZENoYW5nZSA9PT0gJ2gnID8gaG91cnMgOiBwYWQoaG91cnMsICFwYWRIb3Vycyk7XG4gICAgICBpZiAoa2V5Ym9hcmRDaGFuZ2UgIT09ICdtJykge1xuICAgICAgICAkc2NvcGUubWludXRlcyA9IHBhZChtaW51dGVzKTtcbiAgICAgIH1cbiAgICAgICRzY29wZS5tZXJpZGlhbiA9IHNlbGVjdGVkLmdldEhvdXJzKCkgPCAxMiA/IG1lcmlkaWFuc1swXSA6IG1lcmlkaWFuc1sxXTtcblxuICAgICAgaWYgKGtleWJvYXJkQ2hhbmdlICE9PSAncycpIHtcbiAgICAgICAgJHNjb3BlLnNlY29uZHMgPSBwYWQoc2Vjb25kcyk7XG4gICAgICB9XG4gICAgICAkc2NvcGUubWVyaWRpYW4gPSBzZWxlY3RlZC5nZXRIb3VycygpIDwgMTIgPyBtZXJpZGlhbnNbMF0gOiBtZXJpZGlhbnNbMV07XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYWRkU2Vjb25kc1RvU2VsZWN0ZWQoc2Vjb25kcykge1xuICAgIHNlbGVjdGVkID0gYWRkU2Vjb25kcyhzZWxlY3RlZCwgc2Vjb25kcyk7XG4gICAgcmVmcmVzaCgpO1xuICB9XG5cbiAgZnVuY3Rpb24gYWRkTWludXRlcyhzZWxlY3RlZCwgbWludXRlcykge1xuICAgIHJldHVybiBhZGRTZWNvbmRzKHNlbGVjdGVkLCBtaW51dGVzKjYwKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZFNlY29uZHMoZGF0ZSwgc2Vjb25kcykge1xuICAgIHZhciBkdCA9IG5ldyBEYXRlKGRhdGUuZ2V0VGltZSgpICsgc2Vjb25kcyAqIDEwMDApO1xuICAgIHZhciBuZXdEYXRlID0gbmV3IERhdGUoZGF0ZSk7XG4gICAgbmV3RGF0ZS5zZXRIb3VycyhkdC5nZXRIb3VycygpLCBkdC5nZXRNaW51dGVzKCksIGR0LmdldFNlY29uZHMoKSk7XG4gICAgcmV0dXJuIG5ld0RhdGU7XG4gIH1cblxuICBmdW5jdGlvbiBtb2RlbElzRW1wdHkoKSB7XG4gICAgcmV0dXJuICgkc2NvcGUuaG91cnMgPT09IG51bGwgfHwgJHNjb3BlLmhvdXJzID09PSAnJykgJiZcbiAgICAgICgkc2NvcGUubWludXRlcyA9PT0gbnVsbCB8fCAkc2NvcGUubWludXRlcyA9PT0gJycpICYmXG4gICAgICAoISRzY29wZS5zaG93U2Vjb25kcyB8fCAkc2NvcGUuc2hvd1NlY29uZHMgJiYgKCRzY29wZS5zZWNvbmRzID09PSBudWxsIHx8ICRzY29wZS5zZWNvbmRzID09PSAnJykpO1xuICB9XG5cbiAgJHNjb3BlLnNob3dTcGlubmVycyA9IGFuZ3VsYXIuaXNEZWZpbmVkKCRhdHRycy5zaG93U3Bpbm5lcnMpID9cbiAgICAkc2NvcGUuJHBhcmVudC4kZXZhbCgkYXR0cnMuc2hvd1NwaW5uZXJzKSA6IHRpbWVwaWNrZXJDb25maWcuc2hvd1NwaW5uZXJzO1xuXG4gICRzY29wZS5pbmNyZW1lbnRIb3VycyA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICghJHNjb3BlLm5vSW5jcmVtZW50SG91cnMoKSkge1xuICAgICAgYWRkU2Vjb25kc1RvU2VsZWN0ZWQoaG91clN0ZXAgKiA2MCAqIDYwKTtcbiAgICB9XG4gIH07XG5cbiAgJHNjb3BlLmRlY3JlbWVudEhvdXJzID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCEkc2NvcGUubm9EZWNyZW1lbnRIb3VycygpKSB7XG4gICAgICBhZGRTZWNvbmRzVG9TZWxlY3RlZCgtaG91clN0ZXAgKiA2MCAqIDYwKTtcbiAgICB9XG4gIH07XG5cbiAgJHNjb3BlLmluY3JlbWVudE1pbnV0ZXMgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoISRzY29wZS5ub0luY3JlbWVudE1pbnV0ZXMoKSkge1xuICAgICAgYWRkU2Vjb25kc1RvU2VsZWN0ZWQobWludXRlU3RlcCAqIDYwKTtcbiAgICB9XG4gIH07XG5cbiAgJHNjb3BlLmRlY3JlbWVudE1pbnV0ZXMgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoISRzY29wZS5ub0RlY3JlbWVudE1pbnV0ZXMoKSkge1xuICAgICAgYWRkU2Vjb25kc1RvU2VsZWN0ZWQoLW1pbnV0ZVN0ZXAgKiA2MCk7XG4gICAgfVxuICB9O1xuXG4gICRzY29wZS5pbmNyZW1lbnRTZWNvbmRzID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCEkc2NvcGUubm9JbmNyZW1lbnRTZWNvbmRzKCkpIHtcbiAgICAgIGFkZFNlY29uZHNUb1NlbGVjdGVkKHNlY29uZFN0ZXApO1xuICAgIH1cbiAgfTtcblxuICAkc2NvcGUuZGVjcmVtZW50U2Vjb25kcyA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICghJHNjb3BlLm5vRGVjcmVtZW50U2Vjb25kcygpKSB7XG4gICAgICBhZGRTZWNvbmRzVG9TZWxlY3RlZCgtc2Vjb25kU3RlcCk7XG4gICAgfVxuICB9O1xuXG4gICRzY29wZS50b2dnbGVNZXJpZGlhbiA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBtaW51dGVzID0gZ2V0TWludXRlc0Zyb21UZW1wbGF0ZSgpLFxuICAgICAgICBob3VycyA9IGdldEhvdXJzRnJvbVRlbXBsYXRlKCk7XG5cbiAgICBpZiAoISRzY29wZS5ub1RvZ2dsZU1lcmlkaWFuKCkpIHtcbiAgICAgIGlmIChhbmd1bGFyLmlzRGVmaW5lZChtaW51dGVzKSAmJiBhbmd1bGFyLmlzRGVmaW5lZChob3VycykpIHtcbiAgICAgICAgYWRkU2Vjb25kc1RvU2VsZWN0ZWQoMTIgKiA2MCAqIChzZWxlY3RlZC5nZXRIb3VycygpIDwgMTIgPyA2MCA6IC02MCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJHNjb3BlLm1lcmlkaWFuID0gJHNjb3BlLm1lcmlkaWFuID09PSBtZXJpZGlhbnNbMF0gPyBtZXJpZGlhbnNbMV0gOiBtZXJpZGlhbnNbMF07XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gICRzY29wZS5ibHVyID0gZnVuY3Rpb24oKSB7XG4gICAgbmdNb2RlbEN0cmwuJHNldFRvdWNoZWQoKTtcbiAgfTtcblxuICAkc2NvcGUuJG9uKCckZGVzdHJveScsIGZ1bmN0aW9uKCkge1xuICAgIHdoaWxlICh3YXRjaGVycy5sZW5ndGgpIHtcbiAgICAgIHdhdGNoZXJzLnNoaWZ0KCkoKTtcbiAgICB9XG4gIH0pO1xufV0pXG5cbi5kaXJlY3RpdmUoJ3VpYlRpbWVwaWNrZXInLCBbJ3VpYlRpbWVwaWNrZXJDb25maWcnLCBmdW5jdGlvbih1aWJUaW1lcGlja2VyQ29uZmlnKSB7XG4gIHJldHVybiB7XG4gICAgcmVxdWlyZTogWyd1aWJUaW1lcGlja2VyJywgJz9ebmdNb2RlbCddLFxuICAgIHJlc3RyaWN0OiAnQScsXG4gICAgY29udHJvbGxlcjogJ1VpYlRpbWVwaWNrZXJDb250cm9sbGVyJyxcbiAgICBjb250cm9sbGVyQXM6ICd0aW1lcGlja2VyJyxcbiAgICBzY29wZToge30sXG4gICAgdGVtcGxhdGVVcmw6IGZ1bmN0aW9uKGVsZW1lbnQsIGF0dHJzKSB7XG4gICAgICByZXR1cm4gYXR0cnMudGVtcGxhdGVVcmwgfHwgdWliVGltZXBpY2tlckNvbmZpZy50ZW1wbGF0ZVVybDtcbiAgICB9LFxuICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRycywgY3RybHMpIHtcbiAgICAgIHZhciB0aW1lcGlja2VyQ3RybCA9IGN0cmxzWzBdLCBuZ01vZGVsQ3RybCA9IGN0cmxzWzFdO1xuXG4gICAgICBpZiAobmdNb2RlbEN0cmwpIHtcbiAgICAgICAgdGltZXBpY2tlckN0cmwuaW5pdChuZ01vZGVsQ3RybCwgZWxlbWVudC5maW5kKCdpbnB1dCcpKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XSk7XG5cbmFuZ3VsYXIubW9kdWxlKCd1aS5ib290c3RyYXAudHlwZWFoZWFkJywgWyd1aS5ib290c3RyYXAuZGVib3VuY2UnLCAndWkuYm9vdHN0cmFwLnBvc2l0aW9uJ10pXG5cbi8qKlxuICogQSBoZWxwZXIgc2VydmljZSB0aGF0IGNhbiBwYXJzZSB0eXBlYWhlYWQncyBzeW50YXggKHN0cmluZyBwcm92aWRlZCBieSB1c2VycylcbiAqIEV4dHJhY3RlZCB0byBhIHNlcGFyYXRlIHNlcnZpY2UgZm9yIGVhc2Ugb2YgdW5pdCB0ZXN0aW5nXG4gKi9cbiAgLmZhY3RvcnkoJ3VpYlR5cGVhaGVhZFBhcnNlcicsIFsnJHBhcnNlJywgZnVuY3Rpb24oJHBhcnNlKSB7XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgMDAwMDAxMTExMTExMTAwMDAwMDAwMDAwMDAyMjIyMjIyMjAwMDAwMDAwMDAwMDAwMDAzMzMzMzMzMzMzMzMzMzMwMDAwMDAwMDAwMDQ0NDQ0NDQ0MDAwXG4gICAgdmFyIFRZUEVBSEVBRF9SRUdFWFAgPSAvXlxccyooW1xcc1xcU10rPykoPzpcXHMrYXNcXHMrKFtcXHNcXFNdKz8pKT9cXHMrZm9yXFxzKyg/OihbXFwkXFx3XVtcXCRcXHdcXGRdKikpXFxzK2luXFxzKyhbXFxzXFxTXSs/KSQvO1xuICAgIHJldHVybiB7XG4gICAgICBwYXJzZTogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgdmFyIG1hdGNoID0gaW5wdXQubWF0Y2goVFlQRUFIRUFEX1JFR0VYUCk7XG4gICAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAnRXhwZWN0ZWQgdHlwZWFoZWFkIHNwZWNpZmljYXRpb24gaW4gZm9ybSBvZiBcIl9tb2RlbFZhbHVlXyAoYXMgX2xhYmVsXyk/IGZvciBfaXRlbV8gaW4gX2NvbGxlY3Rpb25fXCInICtcbiAgICAgICAgICAgICAgJyBidXQgZ290IFwiJyArIGlucHV0ICsgJ1wiLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpdGVtTmFtZTogbWF0Y2hbM10sXG4gICAgICAgICAgc291cmNlOiAkcGFyc2UobWF0Y2hbNF0pLFxuICAgICAgICAgIHZpZXdNYXBwZXI6ICRwYXJzZShtYXRjaFsyXSB8fCBtYXRjaFsxXSksXG4gICAgICAgICAgbW9kZWxNYXBwZXI6ICRwYXJzZShtYXRjaFsxXSlcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuICB9XSlcblxuICAuY29udHJvbGxlcignVWliVHlwZWFoZWFkQ29udHJvbGxlcicsIFsnJHNjb3BlJywgJyRlbGVtZW50JywgJyRhdHRycycsICckY29tcGlsZScsICckcGFyc2UnLCAnJHEnLCAnJHRpbWVvdXQnLCAnJGRvY3VtZW50JywgJyR3aW5kb3cnLCAnJHJvb3RTY29wZScsICckJGRlYm91bmNlJywgJyR1aWJQb3NpdGlvbicsICd1aWJUeXBlYWhlYWRQYXJzZXInLFxuICAgIGZ1bmN0aW9uKG9yaWdpbmFsU2NvcGUsIGVsZW1lbnQsIGF0dHJzLCAkY29tcGlsZSwgJHBhcnNlLCAkcSwgJHRpbWVvdXQsICRkb2N1bWVudCwgJHdpbmRvdywgJHJvb3RTY29wZSwgJCRkZWJvdW5jZSwgJHBvc2l0aW9uLCB0eXBlYWhlYWRQYXJzZXIpIHtcbiAgICB2YXIgSE9UX0tFWVMgPSBbOSwgMTMsIDI3LCAzOCwgNDBdO1xuICAgIHZhciBldmVudERlYm91bmNlVGltZSA9IDIwMDtcbiAgICB2YXIgbW9kZWxDdHJsLCBuZ01vZGVsT3B0aW9ucztcbiAgICAvL1NVUFBPUlRFRCBBVFRSSUJVVEVTIChPUFRJT05TKVxuXG4gICAgLy9taW5pbWFsIG5vIG9mIGNoYXJhY3RlcnMgdGhhdCBuZWVkcyB0byBiZSBlbnRlcmVkIGJlZm9yZSB0eXBlYWhlYWQga2lja3MtaW5cbiAgICB2YXIgbWluTGVuZ3RoID0gb3JpZ2luYWxTY29wZS4kZXZhbChhdHRycy50eXBlYWhlYWRNaW5MZW5ndGgpO1xuICAgIGlmICghbWluTGVuZ3RoICYmIG1pbkxlbmd0aCAhPT0gMCkge1xuICAgICAgbWluTGVuZ3RoID0gMTtcbiAgICB9XG5cbiAgICBvcmlnaW5hbFNjb3BlLiR3YXRjaChhdHRycy50eXBlYWhlYWRNaW5MZW5ndGgsIGZ1bmN0aW9uIChuZXdWYWwpIHtcbiAgICAgICAgbWluTGVuZ3RoID0gIW5ld1ZhbCAmJiBuZXdWYWwgIT09IDAgPyAxIDogbmV3VmFsO1xuICAgIH0pO1xuXG4gICAgLy9taW5pbWFsIHdhaXQgdGltZSBhZnRlciBsYXN0IGNoYXJhY3RlciB0eXBlZCBiZWZvcmUgdHlwZWFoZWFkIGtpY2tzLWluXG4gICAgdmFyIHdhaXRUaW1lID0gb3JpZ2luYWxTY29wZS4kZXZhbChhdHRycy50eXBlYWhlYWRXYWl0TXMpIHx8IDA7XG5cbiAgICAvL3Nob3VsZCBpdCByZXN0cmljdCBtb2RlbCB2YWx1ZXMgdG8gdGhlIG9uZXMgc2VsZWN0ZWQgZnJvbSB0aGUgcG9wdXAgb25seT9cbiAgICB2YXIgaXNFZGl0YWJsZSA9IG9yaWdpbmFsU2NvcGUuJGV2YWwoYXR0cnMudHlwZWFoZWFkRWRpdGFibGUpICE9PSBmYWxzZTtcbiAgICBvcmlnaW5hbFNjb3BlLiR3YXRjaChhdHRycy50eXBlYWhlYWRFZGl0YWJsZSwgZnVuY3Rpb24gKG5ld1ZhbCkge1xuICAgICAgaXNFZGl0YWJsZSA9IG5ld1ZhbCAhPT0gZmFsc2U7XG4gICAgfSk7XG5cbiAgICAvL2JpbmRpbmcgdG8gYSB2YXJpYWJsZSB0aGF0IGluZGljYXRlcyBpZiBtYXRjaGVzIGFyZSBiZWluZyByZXRyaWV2ZWQgYXN5bmNocm9ub3VzbHlcbiAgICB2YXIgaXNMb2FkaW5nU2V0dGVyID0gJHBhcnNlKGF0dHJzLnR5cGVhaGVhZExvYWRpbmcpLmFzc2lnbiB8fCBhbmd1bGFyLm5vb3A7XG5cbiAgICAvL2EgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGlmIGFuIGV2ZW50IHNob3VsZCBjYXVzZSBzZWxlY3Rpb25cbiAgICB2YXIgaXNTZWxlY3RFdmVudCA9IGF0dHJzLnR5cGVhaGVhZFNob3VsZFNlbGVjdCA/ICRwYXJzZShhdHRycy50eXBlYWhlYWRTaG91bGRTZWxlY3QpIDogZnVuY3Rpb24oc2NvcGUsIHZhbHMpIHtcbiAgICAgIHZhciBldnQgPSB2YWxzLiRldmVudDtcbiAgICAgIHJldHVybiBldnQud2hpY2ggPT09IDEzIHx8IGV2dC53aGljaCA9PT0gOTtcbiAgICB9O1xuXG4gICAgLy9hIGNhbGxiYWNrIGV4ZWN1dGVkIHdoZW4gYSBtYXRjaCBpcyBzZWxlY3RlZFxuICAgIHZhciBvblNlbGVjdENhbGxiYWNrID0gJHBhcnNlKGF0dHJzLnR5cGVhaGVhZE9uU2VsZWN0KTtcblxuICAgIC8vc2hvdWxkIGl0IHNlbGVjdCBoaWdobGlnaHRlZCBwb3B1cCB2YWx1ZSB3aGVuIGxvc2luZyBmb2N1cz9cbiAgICB2YXIgaXNTZWxlY3RPbkJsdXIgPSBhbmd1bGFyLmlzRGVmaW5lZChhdHRycy50eXBlYWhlYWRTZWxlY3RPbkJsdXIpID8gb3JpZ2luYWxTY29wZS4kZXZhbChhdHRycy50eXBlYWhlYWRTZWxlY3RPbkJsdXIpIDogZmFsc2U7XG5cbiAgICAvL2JpbmRpbmcgdG8gYSB2YXJpYWJsZSB0aGF0IGluZGljYXRlcyBpZiB0aGVyZSB3ZXJlIG5vIHJlc3VsdHMgYWZ0ZXIgdGhlIHF1ZXJ5IGlzIGNvbXBsZXRlZFxuICAgIHZhciBpc05vUmVzdWx0c1NldHRlciA9ICRwYXJzZShhdHRycy50eXBlYWhlYWROb1Jlc3VsdHMpLmFzc2lnbiB8fCBhbmd1bGFyLm5vb3A7XG5cbiAgICB2YXIgaW5wdXRGb3JtYXR0ZXIgPSBhdHRycy50eXBlYWhlYWRJbnB1dEZvcm1hdHRlciA/ICRwYXJzZShhdHRycy50eXBlYWhlYWRJbnB1dEZvcm1hdHRlcikgOiB1bmRlZmluZWQ7XG5cbiAgICB2YXIgYXBwZW5kVG9Cb2R5ID0gYXR0cnMudHlwZWFoZWFkQXBwZW5kVG9Cb2R5ID8gb3JpZ2luYWxTY29wZS4kZXZhbChhdHRycy50eXBlYWhlYWRBcHBlbmRUb0JvZHkpIDogZmFsc2U7XG5cbiAgICB2YXIgYXBwZW5kVG8gPSBhdHRycy50eXBlYWhlYWRBcHBlbmRUbyA/XG4gICAgICBvcmlnaW5hbFNjb3BlLiRldmFsKGF0dHJzLnR5cGVhaGVhZEFwcGVuZFRvKSA6IG51bGw7XG5cbiAgICB2YXIgZm9jdXNGaXJzdCA9IG9yaWdpbmFsU2NvcGUuJGV2YWwoYXR0cnMudHlwZWFoZWFkRm9jdXNGaXJzdCkgIT09IGZhbHNlO1xuXG4gICAgLy9JZiBpbnB1dCBtYXRjaGVzIGFuIGl0ZW0gb2YgdGhlIGxpc3QgZXhhY3RseSwgc2VsZWN0IGl0IGF1dG9tYXRpY2FsbHlcbiAgICB2YXIgc2VsZWN0T25FeGFjdCA9IGF0dHJzLnR5cGVhaGVhZFNlbGVjdE9uRXhhY3QgPyBvcmlnaW5hbFNjb3BlLiRldmFsKGF0dHJzLnR5cGVhaGVhZFNlbGVjdE9uRXhhY3QpIDogZmFsc2U7XG5cbiAgICAvL2JpbmRpbmcgdG8gYSB2YXJpYWJsZSB0aGF0IGluZGljYXRlcyBpZiBkcm9wZG93biBpcyBvcGVuXG4gICAgdmFyIGlzT3BlblNldHRlciA9ICRwYXJzZShhdHRycy50eXBlYWhlYWRJc09wZW4pLmFzc2lnbiB8fCBhbmd1bGFyLm5vb3A7XG5cbiAgICB2YXIgc2hvd0hpbnQgPSBvcmlnaW5hbFNjb3BlLiRldmFsKGF0dHJzLnR5cGVhaGVhZFNob3dIaW50KSB8fCBmYWxzZTtcblxuICAgIC8vSU5URVJOQUwgVkFSSUFCTEVTXG5cbiAgICAvL21vZGVsIHNldHRlciBleGVjdXRlZCB1cG9uIG1hdGNoIHNlbGVjdGlvblxuICAgIHZhciBwYXJzZWRNb2RlbCA9ICRwYXJzZShhdHRycy5uZ01vZGVsKTtcbiAgICB2YXIgaW52b2tlTW9kZWxTZXR0ZXIgPSAkcGFyc2UoYXR0cnMubmdNb2RlbCArICcoJCQkcCknKTtcbiAgICB2YXIgJHNldE1vZGVsVmFsdWUgPSBmdW5jdGlvbihzY29wZSwgbmV3VmFsdWUpIHtcbiAgICAgIGlmIChhbmd1bGFyLmlzRnVuY3Rpb24ocGFyc2VkTW9kZWwob3JpZ2luYWxTY29wZSkpICYmXG4gICAgICAgIG5nTW9kZWxPcHRpb25zLmdldE9wdGlvbignZ2V0dGVyU2V0dGVyJykpIHtcbiAgICAgICAgcmV0dXJuIGludm9rZU1vZGVsU2V0dGVyKHNjb3BlLCB7JCQkcDogbmV3VmFsdWV9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBhcnNlZE1vZGVsLmFzc2lnbihzY29wZSwgbmV3VmFsdWUpO1xuICAgIH07XG5cbiAgICAvL2V4cHJlc3Npb25zIHVzZWQgYnkgdHlwZWFoZWFkXG4gICAgdmFyIHBhcnNlclJlc3VsdCA9IHR5cGVhaGVhZFBhcnNlci5wYXJzZShhdHRycy51aWJUeXBlYWhlYWQpO1xuXG4gICAgdmFyIGhhc0ZvY3VzO1xuXG4gICAgLy9Vc2VkIHRvIGF2b2lkIGJ1ZyBpbiBpT1Mgd2VidmlldyB3aGVyZSBpT1Mga2V5Ym9hcmQgZG9lcyBub3QgZmlyZVxuICAgIC8vbW91c2Vkb3duICYgbW91c2V1cCBldmVudHNcbiAgICAvL0lzc3VlICMzNjk5XG4gICAgdmFyIHNlbGVjdGVkO1xuXG4gICAgLy9jcmVhdGUgYSBjaGlsZCBzY29wZSBmb3IgdGhlIHR5cGVhaGVhZCBkaXJlY3RpdmUgc28gd2UgYXJlIG5vdCBwb2xsdXRpbmcgb3JpZ2luYWwgc2NvcGVcbiAgICAvL3dpdGggdHlwZWFoZWFkLXNwZWNpZmljIGRhdGEgKG1hdGNoZXMsIHF1ZXJ5IGV0Yy4pXG4gICAgdmFyIHNjb3BlID0gb3JpZ2luYWxTY29wZS4kbmV3KCk7XG4gICAgdmFyIG9mZkRlc3Ryb3kgPSBvcmlnaW5hbFNjb3BlLiRvbignJGRlc3Ryb3knLCBmdW5jdGlvbigpIHtcbiAgICAgIHNjb3BlLiRkZXN0cm95KCk7XG4gICAgfSk7XG4gICAgc2NvcGUuJG9uKCckZGVzdHJveScsIG9mZkRlc3Ryb3kpO1xuXG4gICAgLy8gV0FJLUFSSUFcbiAgICB2YXIgcG9wdXBJZCA9ICd0eXBlYWhlYWQtJyArIHNjb3BlLiRpZCArICctJyArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDAwKTtcbiAgICBlbGVtZW50LmF0dHIoe1xuICAgICAgJ2FyaWEtYXV0b2NvbXBsZXRlJzogJ2xpc3QnLFxuICAgICAgJ2FyaWEtZXhwYW5kZWQnOiBmYWxzZSxcbiAgICAgICdhcmlhLW93bnMnOiBwb3B1cElkXG4gICAgfSk7XG5cbiAgICB2YXIgaW5wdXRzQ29udGFpbmVyLCBoaW50SW5wdXRFbGVtO1xuICAgIC8vYWRkIHJlYWQtb25seSBpbnB1dCB0byBzaG93IGhpbnRcbiAgICBpZiAoc2hvd0hpbnQpIHtcbiAgICAgIGlucHV0c0NvbnRhaW5lciA9IGFuZ3VsYXIuZWxlbWVudCgnPGRpdj48L2Rpdj4nKTtcbiAgICAgIGlucHV0c0NvbnRhaW5lci5jc3MoJ3Bvc2l0aW9uJywgJ3JlbGF0aXZlJyk7XG4gICAgICBlbGVtZW50LmFmdGVyKGlucHV0c0NvbnRhaW5lcik7XG4gICAgICBoaW50SW5wdXRFbGVtID0gZWxlbWVudC5jbG9uZSgpO1xuICAgICAgaGludElucHV0RWxlbS5hdHRyKCdwbGFjZWhvbGRlcicsICcnKTtcbiAgICAgIGhpbnRJbnB1dEVsZW0uYXR0cigndGFiaW5kZXgnLCAnLTEnKTtcbiAgICAgIGhpbnRJbnB1dEVsZW0udmFsKCcnKTtcbiAgICAgIGhpbnRJbnB1dEVsZW0uY3NzKHtcbiAgICAgICAgJ3Bvc2l0aW9uJzogJ2Fic29sdXRlJyxcbiAgICAgICAgJ3RvcCc6ICcwcHgnLFxuICAgICAgICAnbGVmdCc6ICcwcHgnLFxuICAgICAgICAnYm9yZGVyLWNvbG9yJzogJ3RyYW5zcGFyZW50JyxcbiAgICAgICAgJ2JveC1zaGFkb3cnOiAnbm9uZScsXG4gICAgICAgICdvcGFjaXR5JzogMSxcbiAgICAgICAgJ2JhY2tncm91bmQnOiAnbm9uZSAwJSAwJSAvIGF1dG8gcmVwZWF0IHNjcm9sbCBwYWRkaW5nLWJveCBib3JkZXItYm94IHJnYigyNTUsIDI1NSwgMjU1KScsXG4gICAgICAgICdjb2xvcic6ICcjOTk5J1xuICAgICAgfSk7XG4gICAgICBlbGVtZW50LmNzcyh7XG4gICAgICAgICdwb3NpdGlvbic6ICdyZWxhdGl2ZScsXG4gICAgICAgICd2ZXJ0aWNhbC1hbGlnbic6ICd0b3AnLFxuICAgICAgICAnYmFja2dyb3VuZC1jb2xvcic6ICd0cmFuc3BhcmVudCdcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoaGludElucHV0RWxlbS5hdHRyKCdpZCcpKSB7XG4gICAgICAgIGhpbnRJbnB1dEVsZW0ucmVtb3ZlQXR0cignaWQnKTsgLy8gcmVtb3ZlIGR1cGxpY2F0ZSBpZCBpZiBwcmVzZW50LlxuICAgICAgfVxuICAgICAgaW5wdXRzQ29udGFpbmVyLmFwcGVuZChoaW50SW5wdXRFbGVtKTtcbiAgICAgIGhpbnRJbnB1dEVsZW0uYWZ0ZXIoZWxlbWVudCk7XG4gICAgfVxuXG4gICAgLy9wb3AtdXAgZWxlbWVudCB1c2VkIHRvIGRpc3BsYXkgbWF0Y2hlc1xuICAgIHZhciBwb3BVcEVsID0gYW5ndWxhci5lbGVtZW50KCc8ZGl2IHVpYi10eXBlYWhlYWQtcG9wdXA+PC9kaXY+Jyk7XG4gICAgcG9wVXBFbC5hdHRyKHtcbiAgICAgIGlkOiBwb3B1cElkLFxuICAgICAgbWF0Y2hlczogJ21hdGNoZXMnLFxuICAgICAgYWN0aXZlOiAnYWN0aXZlSWR4JyxcbiAgICAgIHNlbGVjdDogJ3NlbGVjdChhY3RpdmVJZHgsIGV2dCknLFxuICAgICAgJ21vdmUtaW4tcHJvZ3Jlc3MnOiAnbW92ZUluUHJvZ3Jlc3MnLFxuICAgICAgcXVlcnk6ICdxdWVyeScsXG4gICAgICBwb3NpdGlvbjogJ3Bvc2l0aW9uJyxcbiAgICAgICdhc3NpZ24taXMtb3Blbic6ICdhc3NpZ25Jc09wZW4oaXNPcGVuKScsXG4gICAgICBkZWJvdW5jZTogJ2RlYm91bmNlVXBkYXRlJ1xuICAgIH0pO1xuICAgIC8vY3VzdG9tIGl0ZW0gdGVtcGxhdGVcbiAgICBpZiAoYW5ndWxhci5pc0RlZmluZWQoYXR0cnMudHlwZWFoZWFkVGVtcGxhdGVVcmwpKSB7XG4gICAgICBwb3BVcEVsLmF0dHIoJ3RlbXBsYXRlLXVybCcsIGF0dHJzLnR5cGVhaGVhZFRlbXBsYXRlVXJsKTtcbiAgICB9XG5cbiAgICBpZiAoYW5ndWxhci5pc0RlZmluZWQoYXR0cnMudHlwZWFoZWFkUG9wdXBUZW1wbGF0ZVVybCkpIHtcbiAgICAgIHBvcFVwRWwuYXR0cigncG9wdXAtdGVtcGxhdGUtdXJsJywgYXR0cnMudHlwZWFoZWFkUG9wdXBUZW1wbGF0ZVVybCk7XG4gICAgfVxuXG4gICAgdmFyIHJlc2V0SGludCA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHNob3dIaW50KSB7XG4gICAgICAgIGhpbnRJbnB1dEVsZW0udmFsKCcnKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHJlc2V0TWF0Y2hlcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgc2NvcGUubWF0Y2hlcyA9IFtdO1xuICAgICAgc2NvcGUuYWN0aXZlSWR4ID0gLTE7XG4gICAgICBlbGVtZW50LmF0dHIoJ2FyaWEtZXhwYW5kZWQnLCBmYWxzZSk7XG4gICAgICByZXNldEhpbnQoKTtcbiAgICB9O1xuXG4gICAgdmFyIGdldE1hdGNoSWQgPSBmdW5jdGlvbihpbmRleCkge1xuICAgICAgcmV0dXJuIHBvcHVwSWQgKyAnLW9wdGlvbi0nICsgaW5kZXg7XG4gICAgfTtcblxuICAgIC8vIEluZGljYXRlIHRoYXQgdGhlIHNwZWNpZmllZCBtYXRjaCBpcyB0aGUgYWN0aXZlIChwcmUtc2VsZWN0ZWQpIGl0ZW0gaW4gdGhlIGxpc3Qgb3duZWQgYnkgdGhpcyB0eXBlYWhlYWQuXG4gICAgLy8gVGhpcyBhdHRyaWJ1dGUgaXMgYWRkZWQgb3IgcmVtb3ZlZCBhdXRvbWF0aWNhbGx5IHdoZW4gdGhlIGBhY3RpdmVJZHhgIGNoYW5nZXMuXG4gICAgc2NvcGUuJHdhdGNoKCdhY3RpdmVJZHgnLCBmdW5jdGlvbihpbmRleCkge1xuICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHIoJ2FyaWEtYWN0aXZlZGVzY2VuZGFudCcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWxlbWVudC5hdHRyKCdhcmlhLWFjdGl2ZWRlc2NlbmRhbnQnLCBnZXRNYXRjaElkKGluZGV4KSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgaW5wdXRJc0V4YWN0TWF0Y2ggPSBmdW5jdGlvbihpbnB1dFZhbHVlLCBpbmRleCkge1xuICAgICAgaWYgKHNjb3BlLm1hdGNoZXMubGVuZ3RoID4gaW5kZXggJiYgaW5wdXRWYWx1ZSkge1xuICAgICAgICByZXR1cm4gaW5wdXRWYWx1ZS50b1VwcGVyQ2FzZSgpID09PSBzY29wZS5tYXRjaGVzW2luZGV4XS5sYWJlbC50b1VwcGVyQ2FzZSgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIHZhciBnZXRNYXRjaGVzQXN5bmMgPSBmdW5jdGlvbihpbnB1dFZhbHVlLCBldnQpIHtcbiAgICAgIHZhciBsb2NhbHMgPSB7JHZpZXdWYWx1ZTogaW5wdXRWYWx1ZX07XG4gICAgICBpc0xvYWRpbmdTZXR0ZXIob3JpZ2luYWxTY29wZSwgdHJ1ZSk7XG4gICAgICBpc05vUmVzdWx0c1NldHRlcihvcmlnaW5hbFNjb3BlLCBmYWxzZSk7XG4gICAgICAkcS53aGVuKHBhcnNlclJlc3VsdC5zb3VyY2Uob3JpZ2luYWxTY29wZSwgbG9jYWxzKSkudGhlbihmdW5jdGlvbihtYXRjaGVzKSB7XG4gICAgICAgIC8vaXQgbWlnaHQgaGFwcGVuIHRoYXQgc2V2ZXJhbCBhc3luYyBxdWVyaWVzIHdlcmUgaW4gcHJvZ3Jlc3MgaWYgYSB1c2VyIHdlcmUgdHlwaW5nIGZhc3RcbiAgICAgICAgLy9idXQgd2UgYXJlIGludGVyZXN0ZWQgb25seSBpbiByZXNwb25zZXMgdGhhdCBjb3JyZXNwb25kIHRvIHRoZSBjdXJyZW50IHZpZXcgdmFsdWVcbiAgICAgICAgdmFyIG9uQ3VycmVudFJlcXVlc3QgPSBpbnB1dFZhbHVlID09PSBtb2RlbEN0cmwuJHZpZXdWYWx1ZTtcbiAgICAgICAgaWYgKG9uQ3VycmVudFJlcXVlc3QgJiYgaGFzRm9jdXMpIHtcbiAgICAgICAgICBpZiAobWF0Y2hlcyAmJiBtYXRjaGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHNjb3BlLmFjdGl2ZUlkeCA9IGZvY3VzRmlyc3QgPyAwIDogLTE7XG4gICAgICAgICAgICBpc05vUmVzdWx0c1NldHRlcihvcmlnaW5hbFNjb3BlLCBmYWxzZSk7XG4gICAgICAgICAgICBzY29wZS5tYXRjaGVzLmxlbmd0aCA9IDA7XG5cbiAgICAgICAgICAgIC8vdHJhbnNmb3JtIGxhYmVsc1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXRjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIGxvY2Fsc1twYXJzZXJSZXN1bHQuaXRlbU5hbWVdID0gbWF0Y2hlc1tpXTtcbiAgICAgICAgICAgICAgc2NvcGUubWF0Y2hlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBpZDogZ2V0TWF0Y2hJZChpKSxcbiAgICAgICAgICAgICAgICBsYWJlbDogcGFyc2VyUmVzdWx0LnZpZXdNYXBwZXIoc2NvcGUsIGxvY2FscyksXG4gICAgICAgICAgICAgICAgbW9kZWw6IG1hdGNoZXNbaV1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNjb3BlLnF1ZXJ5ID0gaW5wdXRWYWx1ZTtcbiAgICAgICAgICAgIC8vcG9zaXRpb24gcG9wLXVwIHdpdGggbWF0Y2hlcyAtIHdlIG5lZWQgdG8gcmUtY2FsY3VsYXRlIGl0cyBwb3NpdGlvbiBlYWNoIHRpbWUgd2UgYXJlIG9wZW5pbmcgYSB3aW5kb3dcbiAgICAgICAgICAgIC8vd2l0aCBtYXRjaGVzIGFzIGEgcG9wLXVwIG1pZ2h0IGJlIGFic29sdXRlLXBvc2l0aW9uZWQgYW5kIHBvc2l0aW9uIG9mIGFuIGlucHV0IG1pZ2h0IGhhdmUgY2hhbmdlZCBvbiBhIHBhZ2VcbiAgICAgICAgICAgIC8vZHVlIHRvIG90aGVyIGVsZW1lbnRzIGJlaW5nIHJlbmRlcmVkXG4gICAgICAgICAgICByZWNhbGN1bGF0ZVBvc2l0aW9uKCk7XG5cbiAgICAgICAgICAgIGVsZW1lbnQuYXR0cignYXJpYS1leHBhbmRlZCcsIHRydWUpO1xuXG4gICAgICAgICAgICAvL1NlbGVjdCB0aGUgc2luZ2xlIHJlbWFpbmluZyBvcHRpb24gaWYgdXNlciBpbnB1dCBtYXRjaGVzXG4gICAgICAgICAgICBpZiAoc2VsZWN0T25FeGFjdCAmJiBzY29wZS5tYXRjaGVzLmxlbmd0aCA9PT0gMSAmJiBpbnB1dElzRXhhY3RNYXRjaChpbnB1dFZhbHVlLCAwKSkge1xuICAgICAgICAgICAgICBpZiAoYW5ndWxhci5pc051bWJlcihzY29wZS5kZWJvdW5jZVVwZGF0ZSkgfHwgYW5ndWxhci5pc09iamVjdChzY29wZS5kZWJvdW5jZVVwZGF0ZSkpIHtcbiAgICAgICAgICAgICAgICAkJGRlYm91bmNlKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgc2NvcGUuc2VsZWN0KDAsIGV2dCk7XG4gICAgICAgICAgICAgICAgfSwgYW5ndWxhci5pc051bWJlcihzY29wZS5kZWJvdW5jZVVwZGF0ZSkgPyBzY29wZS5kZWJvdW5jZVVwZGF0ZSA6IHNjb3BlLmRlYm91bmNlVXBkYXRlWydkZWZhdWx0J10pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNjb3BlLnNlbGVjdCgwLCBldnQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzaG93SGludCkge1xuICAgICAgICAgICAgICB2YXIgZmlyc3RMYWJlbCA9IHNjb3BlLm1hdGNoZXNbMF0ubGFiZWw7XG4gICAgICAgICAgICAgIGlmIChhbmd1bGFyLmlzU3RyaW5nKGlucHV0VmFsdWUpICYmXG4gICAgICAgICAgICAgICAgaW5wdXRWYWx1ZS5sZW5ndGggPiAwICYmXG4gICAgICAgICAgICAgICAgZmlyc3RMYWJlbC5zbGljZSgwLCBpbnB1dFZhbHVlLmxlbmd0aCkudG9VcHBlckNhc2UoKSA9PT0gaW5wdXRWYWx1ZS50b1VwcGVyQ2FzZSgpKSB7XG4gICAgICAgICAgICAgICAgaGludElucHV0RWxlbS52YWwoaW5wdXRWYWx1ZSArIGZpcnN0TGFiZWwuc2xpY2UoaW5wdXRWYWx1ZS5sZW5ndGgpKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBoaW50SW5wdXRFbGVtLnZhbCgnJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzZXRNYXRjaGVzKCk7XG4gICAgICAgICAgICBpc05vUmVzdWx0c1NldHRlcihvcmlnaW5hbFNjb3BlLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uQ3VycmVudFJlcXVlc3QpIHtcbiAgICAgICAgICBpc0xvYWRpbmdTZXR0ZXIob3JpZ2luYWxTY29wZSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgcmVzZXRNYXRjaGVzKCk7XG4gICAgICAgIGlzTG9hZGluZ1NldHRlcihvcmlnaW5hbFNjb3BlLCBmYWxzZSk7XG4gICAgICAgIGlzTm9SZXN1bHRzU2V0dGVyKG9yaWdpbmFsU2NvcGUsIHRydWUpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8vIGJpbmQgZXZlbnRzIG9ubHkgaWYgYXBwZW5kVG9Cb2R5IHBhcmFtcyBleGlzdCAtIHBlcmZvcm1hbmNlIGZlYXR1cmVcbiAgICBpZiAoYXBwZW5kVG9Cb2R5KSB7XG4gICAgICBhbmd1bGFyLmVsZW1lbnQoJHdpbmRvdykub24oJ3Jlc2l6ZScsIGZpcmVSZWNhbGN1bGF0aW5nKTtcbiAgICAgICRkb2N1bWVudC5maW5kKCdib2R5Jykub24oJ3Njcm9sbCcsIGZpcmVSZWNhbGN1bGF0aW5nKTtcbiAgICB9XG5cbiAgICAvLyBEZWNsYXJlIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gb3V0c2lkZSByZWNhbGN1bGF0aW5nIGZvclxuICAgIC8vIHByb3BlciBkZWJvdW5jaW5nXG4gICAgdmFyIGRlYm91bmNlZFJlY2FsY3VsYXRlID0gJCRkZWJvdW5jZShmdW5jdGlvbigpIHtcbiAgICAgIC8vIGlmIHBvcHVwIGlzIHZpc2libGVcbiAgICAgIGlmIChzY29wZS5tYXRjaGVzLmxlbmd0aCkge1xuICAgICAgICByZWNhbGN1bGF0ZVBvc2l0aW9uKCk7XG4gICAgICB9XG5cbiAgICAgIHNjb3BlLm1vdmVJblByb2dyZXNzID0gZmFsc2U7XG4gICAgfSwgZXZlbnREZWJvdW5jZVRpbWUpO1xuXG4gICAgLy8gRGVmYXVsdCBwcm9ncmVzcyB0eXBlXG4gICAgc2NvcGUubW92ZUluUHJvZ3Jlc3MgPSBmYWxzZTtcblxuICAgIGZ1bmN0aW9uIGZpcmVSZWNhbGN1bGF0aW5nKCkge1xuICAgICAgaWYgKCFzY29wZS5tb3ZlSW5Qcm9ncmVzcykge1xuICAgICAgICBzY29wZS5tb3ZlSW5Qcm9ncmVzcyA9IHRydWU7XG4gICAgICAgIHNjb3BlLiRkaWdlc3QoKTtcbiAgICAgIH1cblxuICAgICAgZGVib3VuY2VkUmVjYWxjdWxhdGUoKTtcbiAgICB9XG5cbiAgICAvLyByZWNhbGN1bGF0ZSBhY3R1YWwgcG9zaXRpb24gYW5kIHNldCBuZXcgdmFsdWVzIHRvIHNjb3BlXG4gICAgLy8gYWZ0ZXIgZGlnZXN0IGxvb3AgaXMgcG9wdXAgaW4gcmlnaHQgcG9zaXRpb25cbiAgICBmdW5jdGlvbiByZWNhbGN1bGF0ZVBvc2l0aW9uKCkge1xuICAgICAgc2NvcGUucG9zaXRpb24gPSBhcHBlbmRUb0JvZHkgPyAkcG9zaXRpb24ub2Zmc2V0KGVsZW1lbnQpIDogJHBvc2l0aW9uLnBvc2l0aW9uKGVsZW1lbnQpO1xuICAgICAgc2NvcGUucG9zaXRpb24udG9wICs9IGVsZW1lbnQucHJvcCgnb2Zmc2V0SGVpZ2h0Jyk7XG4gICAgfVxuXG4gICAgLy93ZSBuZWVkIHRvIHByb3BhZ2F0ZSB1c2VyJ3MgcXVlcnkgc28gd2UgY2FuIGhpZ2xpZ2h0IG1hdGNoZXNcbiAgICBzY29wZS5xdWVyeSA9IHVuZGVmaW5lZDtcblxuICAgIC8vRGVjbGFyZSB0aGUgdGltZW91dCBwcm9taXNlIHZhciBvdXRzaWRlIHRoZSBmdW5jdGlvbiBzY29wZSBzbyB0aGF0IHN0YWNrZWQgY2FsbHMgY2FuIGJlIGNhbmNlbGxlZCBsYXRlclxuICAgIHZhciB0aW1lb3V0UHJvbWlzZTtcblxuICAgIHZhciBzY2hlZHVsZVNlYXJjaFdpdGhUaW1lb3V0ID0gZnVuY3Rpb24oaW5wdXRWYWx1ZSkge1xuICAgICAgdGltZW91dFByb21pc2UgPSAkdGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgZ2V0TWF0Y2hlc0FzeW5jKGlucHV0VmFsdWUpO1xuICAgICAgfSwgd2FpdFRpbWUpO1xuICAgIH07XG5cbiAgICB2YXIgY2FuY2VsUHJldmlvdXNUaW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGltZW91dFByb21pc2UpIHtcbiAgICAgICAgJHRpbWVvdXQuY2FuY2VsKHRpbWVvdXRQcm9taXNlKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmVzZXRNYXRjaGVzKCk7XG5cbiAgICBzY29wZS5hc3NpZ25Jc09wZW4gPSBmdW5jdGlvbiAoaXNPcGVuKSB7XG4gICAgICBpc09wZW5TZXR0ZXIob3JpZ2luYWxTY29wZSwgaXNPcGVuKTtcbiAgICB9O1xuXG4gICAgc2NvcGUuc2VsZWN0ID0gZnVuY3Rpb24oYWN0aXZlSWR4LCBldnQpIHtcbiAgICAgIC8vY2FsbGVkIGZyb20gd2l0aGluIHRoZSAkZGlnZXN0KCkgY3ljbGVcbiAgICAgIHZhciBsb2NhbHMgPSB7fTtcbiAgICAgIHZhciBtb2RlbCwgaXRlbTtcblxuICAgICAgc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgbG9jYWxzW3BhcnNlclJlc3VsdC5pdGVtTmFtZV0gPSBpdGVtID0gc2NvcGUubWF0Y2hlc1thY3RpdmVJZHhdLm1vZGVsO1xuICAgICAgbW9kZWwgPSBwYXJzZXJSZXN1bHQubW9kZWxNYXBwZXIob3JpZ2luYWxTY29wZSwgbG9jYWxzKTtcbiAgICAgICRzZXRNb2RlbFZhbHVlKG9yaWdpbmFsU2NvcGUsIG1vZGVsKTtcbiAgICAgIG1vZGVsQ3RybC4kc2V0VmFsaWRpdHkoJ2VkaXRhYmxlJywgdHJ1ZSk7XG4gICAgICBtb2RlbEN0cmwuJHNldFZhbGlkaXR5KCdwYXJzZScsIHRydWUpO1xuXG4gICAgICBvblNlbGVjdENhbGxiYWNrKG9yaWdpbmFsU2NvcGUsIHtcbiAgICAgICAgJGl0ZW06IGl0ZW0sXG4gICAgICAgICRtb2RlbDogbW9kZWwsXG4gICAgICAgICRsYWJlbDogcGFyc2VyUmVzdWx0LnZpZXdNYXBwZXIob3JpZ2luYWxTY29wZSwgbG9jYWxzKSxcbiAgICAgICAgJGV2ZW50OiBldnRcbiAgICAgIH0pO1xuXG4gICAgICByZXNldE1hdGNoZXMoKTtcblxuICAgICAgLy9yZXR1cm4gZm9jdXMgdG8gdGhlIGlucHV0IGVsZW1lbnQgaWYgYSBtYXRjaCB3YXMgc2VsZWN0ZWQgdmlhIGEgbW91c2UgY2xpY2sgZXZlbnRcbiAgICAgIC8vIHVzZSB0aW1lb3V0IHRvIGF2b2lkICRyb290U2NvcGU6aW5wcm9nIGVycm9yXG4gICAgICBpZiAoc2NvcGUuJGV2YWwoYXR0cnMudHlwZWFoZWFkRm9jdXNPblNlbGVjdCkgIT09IGZhbHNlKSB7XG4gICAgICAgICR0aW1lb3V0KGZ1bmN0aW9uKCkgeyBlbGVtZW50WzBdLmZvY3VzKCk7IH0sIDAsIGZhbHNlKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy9iaW5kIGtleWJvYXJkIGV2ZW50czogYXJyb3dzIHVwKDM4KSAvIGRvd24oNDApLCBlbnRlcigxMykgYW5kIHRhYig5KSwgZXNjKDI3KVxuICAgIGVsZW1lbnQub24oJ2tleWRvd24nLCBmdW5jdGlvbihldnQpIHtcbiAgICAgIC8vdHlwZWFoZWFkIGlzIG9wZW4gYW5kIGFuIFwiaW50ZXJlc3RpbmdcIiBrZXkgd2FzIHByZXNzZWRcbiAgICAgIGlmIChzY29wZS5tYXRjaGVzLmxlbmd0aCA9PT0gMCB8fCBIT1RfS0VZUy5pbmRleE9mKGV2dC53aGljaCkgPT09IC0xKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHNob3VsZFNlbGVjdCA9IGlzU2VsZWN0RXZlbnQob3JpZ2luYWxTY29wZSwgeyRldmVudDogZXZ0fSk7XG5cbiAgICAgIC8qKlxuICAgICAgICogaWYgdGhlcmUncyBub3RoaW5nIHNlbGVjdGVkIChpLmUuIGZvY3VzRmlyc3QpIGFuZCBlbnRlciBvciB0YWIgaXMgaGl0XG4gICAgICAgKiBvclxuICAgICAgICogc2hpZnQgKyB0YWIgaXMgcHJlc3NlZCB0byBicmluZyBmb2N1cyB0byB0aGUgcHJldmlvdXMgZWxlbWVudFxuICAgICAgICogdGhlbiBjbGVhciB0aGUgcmVzdWx0c1xuICAgICAgICovXG4gICAgICBpZiAoc2NvcGUuYWN0aXZlSWR4ID09PSAtMSAmJiBzaG91bGRTZWxlY3QgfHwgZXZ0LndoaWNoID09PSA5ICYmICEhZXZ0LnNoaWZ0S2V5KSB7XG4gICAgICAgIHJlc2V0TWF0Y2hlcygpO1xuICAgICAgICBzY29wZS4kZGlnZXN0KCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB2YXIgdGFyZ2V0O1xuICAgICAgc3dpdGNoIChldnQud2hpY2gpIHtcbiAgICAgICAgY2FzZSAyNzogLy8gZXNjYXBlXG4gICAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICAgICAgcmVzZXRNYXRjaGVzKCk7XG4gICAgICAgICAgb3JpZ2luYWxTY29wZS4kZGlnZXN0KCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzg6IC8vIHVwIGFycm93XG4gICAgICAgICAgc2NvcGUuYWN0aXZlSWR4ID0gKHNjb3BlLmFjdGl2ZUlkeCA+IDAgPyBzY29wZS5hY3RpdmVJZHggOiBzY29wZS5tYXRjaGVzLmxlbmd0aCkgLSAxO1xuICAgICAgICAgIHNjb3BlLiRkaWdlc3QoKTtcbiAgICAgICAgICB0YXJnZXQgPSBwb3BVcEVsWzBdLnF1ZXJ5U2VsZWN0b3JBbGwoJy51aWItdHlwZWFoZWFkLW1hdGNoJylbc2NvcGUuYWN0aXZlSWR4XTtcbiAgICAgICAgICB0YXJnZXQucGFyZW50Tm9kZS5zY3JvbGxUb3AgPSB0YXJnZXQub2Zmc2V0VG9wO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDQwOiAvLyBkb3duIGFycm93XG4gICAgICAgICAgc2NvcGUuYWN0aXZlSWR4ID0gKHNjb3BlLmFjdGl2ZUlkeCArIDEpICUgc2NvcGUubWF0Y2hlcy5sZW5ndGg7XG4gICAgICAgICAgc2NvcGUuJGRpZ2VzdCgpO1xuICAgICAgICAgIHRhcmdldCA9IHBvcFVwRWxbMF0ucXVlcnlTZWxlY3RvckFsbCgnLnVpYi10eXBlYWhlYWQtbWF0Y2gnKVtzY29wZS5hY3RpdmVJZHhdO1xuICAgICAgICAgIHRhcmdldC5wYXJlbnROb2RlLnNjcm9sbFRvcCA9IHRhcmdldC5vZmZzZXRUb3A7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKHNob3VsZFNlbGVjdCkge1xuICAgICAgICAgICAgc2NvcGUuJGFwcGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBpZiAoYW5ndWxhci5pc051bWJlcihzY29wZS5kZWJvdW5jZVVwZGF0ZSkgfHwgYW5ndWxhci5pc09iamVjdChzY29wZS5kZWJvdW5jZVVwZGF0ZSkpIHtcbiAgICAgICAgICAgICAgICAkJGRlYm91bmNlKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgc2NvcGUuc2VsZWN0KHNjb3BlLmFjdGl2ZUlkeCwgZXZ0KTtcbiAgICAgICAgICAgICAgICB9LCBhbmd1bGFyLmlzTnVtYmVyKHNjb3BlLmRlYm91bmNlVXBkYXRlKSA/IHNjb3BlLmRlYm91bmNlVXBkYXRlIDogc2NvcGUuZGVib3VuY2VVcGRhdGVbJ2RlZmF1bHQnXSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2NvcGUuc2VsZWN0KHNjb3BlLmFjdGl2ZUlkeCwgZXZ0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgZWxlbWVudC5vbignZm9jdXMnLCBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICBoYXNGb2N1cyA9IHRydWU7XG4gICAgICBpZiAobWluTGVuZ3RoID09PSAwICYmICFtb2RlbEN0cmwuJHZpZXdWYWx1ZSkge1xuICAgICAgICAkdGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICBnZXRNYXRjaGVzQXN5bmMobW9kZWxDdHJsLiR2aWV3VmFsdWUsIGV2dCk7XG4gICAgICAgIH0sIDApO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgZWxlbWVudC5vbignYmx1cicsIGZ1bmN0aW9uKGV2dCkge1xuICAgICAgaWYgKGlzU2VsZWN0T25CbHVyICYmIHNjb3BlLm1hdGNoZXMubGVuZ3RoICYmIHNjb3BlLmFjdGl2ZUlkeCAhPT0gLTEgJiYgIXNlbGVjdGVkKSB7XG4gICAgICAgIHNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgc2NvcGUuJGFwcGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmIChhbmd1bGFyLmlzT2JqZWN0KHNjb3BlLmRlYm91bmNlVXBkYXRlKSAmJiBhbmd1bGFyLmlzTnVtYmVyKHNjb3BlLmRlYm91bmNlVXBkYXRlLmJsdXIpKSB7XG4gICAgICAgICAgICAkJGRlYm91bmNlKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBzY29wZS5zZWxlY3Qoc2NvcGUuYWN0aXZlSWR4LCBldnQpO1xuICAgICAgICAgICAgfSwgc2NvcGUuZGVib3VuY2VVcGRhdGUuYmx1cik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNjb3BlLnNlbGVjdChzY29wZS5hY3RpdmVJZHgsIGV2dCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmICghaXNFZGl0YWJsZSAmJiBtb2RlbEN0cmwuJGVycm9yLmVkaXRhYmxlKSB7XG4gICAgICAgIG1vZGVsQ3RybC4kc2V0Vmlld1ZhbHVlKCk7XG4gICAgICAgIHNjb3BlLiRhcHBseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAvLyBSZXNldCB2YWxpZGl0eSBhcyB3ZSBhcmUgY2xlYXJpbmdcbiAgICAgICAgICBtb2RlbEN0cmwuJHNldFZhbGlkaXR5KCdlZGl0YWJsZScsIHRydWUpO1xuICAgICAgICAgIG1vZGVsQ3RybC4kc2V0VmFsaWRpdHkoJ3BhcnNlJywgdHJ1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBlbGVtZW50LnZhbCgnJyk7XG4gICAgICB9XG4gICAgICBoYXNGb2N1cyA9IGZhbHNlO1xuICAgICAgc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICB9KTtcblxuICAgIC8vIEtlZXAgcmVmZXJlbmNlIHRvIGNsaWNrIGhhbmRsZXIgdG8gdW5iaW5kIGl0LlxuICAgIHZhciBkaXNtaXNzQ2xpY2tIYW5kbGVyID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAvLyBJc3N1ZSAjMzk3M1xuICAgICAgLy8gRmlyZWZveCB0cmVhdHMgcmlnaHQgY2xpY2sgYXMgYSBjbGljayBvbiBkb2N1bWVudFxuICAgICAgaWYgKGVsZW1lbnRbMF0gIT09IGV2dC50YXJnZXQgJiYgZXZ0LndoaWNoICE9PSAzICYmIHNjb3BlLm1hdGNoZXMubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIHJlc2V0TWF0Y2hlcygpO1xuICAgICAgICBpZiAoISRyb290U2NvcGUuJCRwaGFzZSkge1xuICAgICAgICAgIG9yaWdpbmFsU2NvcGUuJGRpZ2VzdCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgICRkb2N1bWVudC5vbignY2xpY2snLCBkaXNtaXNzQ2xpY2tIYW5kbGVyKTtcblxuICAgIG9yaWdpbmFsU2NvcGUuJG9uKCckZGVzdHJveScsIGZ1bmN0aW9uKCkge1xuICAgICAgJGRvY3VtZW50Lm9mZignY2xpY2snLCBkaXNtaXNzQ2xpY2tIYW5kbGVyKTtcbiAgICAgIGlmIChhcHBlbmRUb0JvZHkgfHwgYXBwZW5kVG8pIHtcbiAgICAgICAgJHBvcHVwLnJlbW92ZSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoYXBwZW5kVG9Cb2R5KSB7XG4gICAgICAgIGFuZ3VsYXIuZWxlbWVudCgkd2luZG93KS5vZmYoJ3Jlc2l6ZScsIGZpcmVSZWNhbGN1bGF0aW5nKTtcbiAgICAgICAgJGRvY3VtZW50LmZpbmQoJ2JvZHknKS5vZmYoJ3Njcm9sbCcsIGZpcmVSZWNhbGN1bGF0aW5nKTtcbiAgICAgIH1cbiAgICAgIC8vIFByZXZlbnQgalF1ZXJ5IGNhY2hlIG1lbW9yeSBsZWFrXG4gICAgICBwb3BVcEVsLnJlbW92ZSgpO1xuXG4gICAgICBpZiAoc2hvd0hpbnQpIHtcbiAgICAgICAgICBpbnB1dHNDb250YWluZXIucmVtb3ZlKCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgJHBvcHVwID0gJGNvbXBpbGUocG9wVXBFbCkoc2NvcGUpO1xuXG4gICAgaWYgKGFwcGVuZFRvQm9keSkge1xuICAgICAgJGRvY3VtZW50LmZpbmQoJ2JvZHknKS5hcHBlbmQoJHBvcHVwKTtcbiAgICB9IGVsc2UgaWYgKGFwcGVuZFRvKSB7XG4gICAgICBhbmd1bGFyLmVsZW1lbnQoYXBwZW5kVG8pLmVxKDApLmFwcGVuZCgkcG9wdXApO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtZW50LmFmdGVyKCRwb3B1cCk7XG4gICAgfVxuXG4gICAgdGhpcy5pbml0ID0gZnVuY3Rpb24oX21vZGVsQ3RybCkge1xuICAgICAgbW9kZWxDdHJsID0gX21vZGVsQ3RybDtcbiAgICAgIG5nTW9kZWxPcHRpb25zID0gZXh0cmFjdE9wdGlvbnMobW9kZWxDdHJsKTtcblxuICAgICAgc2NvcGUuZGVib3VuY2VVcGRhdGUgPSAkcGFyc2UobmdNb2RlbE9wdGlvbnMuZ2V0T3B0aW9uKCdkZWJvdW5jZScpKShvcmlnaW5hbFNjb3BlKTtcblxuICAgICAgLy9wbHVnIGludG8gJHBhcnNlcnMgcGlwZWxpbmUgdG8gb3BlbiBhIHR5cGVhaGVhZCBvbiB2aWV3IGNoYW5nZXMgaW5pdGlhdGVkIGZyb20gRE9NXG4gICAgICAvLyRwYXJzZXJzIGtpY2staW4gb24gYWxsIHRoZSBjaGFuZ2VzIGNvbWluZyBmcm9tIHRoZSB2aWV3IGFzIHdlbGwgYXMgbWFudWFsbHkgdHJpZ2dlcmVkIGJ5ICRzZXRWaWV3VmFsdWVcbiAgICAgIG1vZGVsQ3RybC4kcGFyc2Vycy51bnNoaWZ0KGZ1bmN0aW9uKGlucHV0VmFsdWUpIHtcbiAgICAgICAgaGFzRm9jdXMgPSB0cnVlO1xuXG4gICAgICAgIGlmIChtaW5MZW5ndGggPT09IDAgfHwgaW5wdXRWYWx1ZSAmJiBpbnB1dFZhbHVlLmxlbmd0aCA+PSBtaW5MZW5ndGgpIHtcbiAgICAgICAgICBpZiAod2FpdFRpbWUgPiAwKSB7XG4gICAgICAgICAgICBjYW5jZWxQcmV2aW91c1RpbWVvdXQoKTtcbiAgICAgICAgICAgIHNjaGVkdWxlU2VhcmNoV2l0aFRpbWVvdXQoaW5wdXRWYWx1ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdldE1hdGNoZXNBc3luYyhpbnB1dFZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXNMb2FkaW5nU2V0dGVyKG9yaWdpbmFsU2NvcGUsIGZhbHNlKTtcbiAgICAgICAgICBjYW5jZWxQcmV2aW91c1RpbWVvdXQoKTtcbiAgICAgICAgICByZXNldE1hdGNoZXMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0VkaXRhYmxlKSB7XG4gICAgICAgICAgcmV0dXJuIGlucHV0VmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlucHV0VmFsdWUpIHtcbiAgICAgICAgICAvLyBSZXNldCBpbiBjYXNlIHVzZXIgaGFkIHR5cGVkIHNvbWV0aGluZyBwcmV2aW91c2x5LlxuICAgICAgICAgIG1vZGVsQ3RybC4kc2V0VmFsaWRpdHkoJ2VkaXRhYmxlJywgdHJ1ZSk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBtb2RlbEN0cmwuJHNldFZhbGlkaXR5KCdlZGl0YWJsZScsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH0pO1xuXG4gICAgICBtb2RlbEN0cmwuJGZvcm1hdHRlcnMucHVzaChmdW5jdGlvbihtb2RlbFZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGVWaWV3VmFsdWUsIGVtcHR5Vmlld1ZhbHVlO1xuICAgICAgICB2YXIgbG9jYWxzID0ge307XG5cbiAgICAgICAgLy8gVGhlIHZhbGlkaXR5IG1heSBiZSBzZXQgdG8gZmFsc2UgdmlhICRwYXJzZXJzIChzZWUgYWJvdmUpIGlmXG4gICAgICAgIC8vIHRoZSBtb2RlbCBpcyByZXN0cmljdGVkIHRvIHNlbGVjdGVkIHZhbHVlcy4gSWYgdGhlIG1vZGVsXG4gICAgICAgIC8vIGlzIHNldCBtYW51YWxseSBpdCBpcyBjb25zaWRlcmVkIHRvIGJlIHZhbGlkLlxuICAgICAgICBpZiAoIWlzRWRpdGFibGUpIHtcbiAgICAgICAgICBtb2RlbEN0cmwuJHNldFZhbGlkaXR5KCdlZGl0YWJsZScsIHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlucHV0Rm9ybWF0dGVyKSB7XG4gICAgICAgICAgbG9jYWxzLiRtb2RlbCA9IG1vZGVsVmFsdWU7XG4gICAgICAgICAgcmV0dXJuIGlucHV0Rm9ybWF0dGVyKG9yaWdpbmFsU2NvcGUsIGxvY2Fscyk7XG4gICAgICAgIH1cblxuICAgICAgICAvL2l0IG1pZ2h0IGhhcHBlbiB0aGF0IHdlIGRvbid0IGhhdmUgZW5vdWdoIGluZm8gdG8gcHJvcGVybHkgcmVuZGVyIGlucHV0IHZhbHVlXG4gICAgICAgIC8vd2UgbmVlZCB0byBjaGVjayBmb3IgdGhpcyBzaXR1YXRpb24gYW5kIHNpbXBseSByZXR1cm4gbW9kZWwgdmFsdWUgaWYgd2UgY2FuJ3QgYXBwbHkgY3VzdG9tIGZvcm1hdHRpbmdcbiAgICAgICAgbG9jYWxzW3BhcnNlclJlc3VsdC5pdGVtTmFtZV0gPSBtb2RlbFZhbHVlO1xuICAgICAgICBjYW5kaWRhdGVWaWV3VmFsdWUgPSBwYXJzZXJSZXN1bHQudmlld01hcHBlcihvcmlnaW5hbFNjb3BlLCBsb2NhbHMpO1xuICAgICAgICBsb2NhbHNbcGFyc2VyUmVzdWx0Lml0ZW1OYW1lXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgZW1wdHlWaWV3VmFsdWUgPSBwYXJzZXJSZXN1bHQudmlld01hcHBlcihvcmlnaW5hbFNjb3BlLCBsb2NhbHMpO1xuXG4gICAgICAgIHJldHVybiBjYW5kaWRhdGVWaWV3VmFsdWUgIT09IGVtcHR5Vmlld1ZhbHVlID8gY2FuZGlkYXRlVmlld1ZhbHVlIDogbW9kZWxWYWx1ZTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBleHRyYWN0T3B0aW9ucyhuZ01vZGVsQ3RybCkge1xuICAgICAgdmFyIG5nTW9kZWxPcHRpb25zO1xuXG4gICAgICBpZiAoYW5ndWxhci52ZXJzaW9uLm1pbm9yIDwgNikgeyAvLyBpbiBhbmd1bGFyIDwgMS42ICRvcHRpb25zIGNvdWxkIGJlIG1pc3NpbmdcbiAgICAgICAgLy8gZ3VhcmFudGVlIGEgdmFsdWVcbiAgICAgICAgbmdNb2RlbE9wdGlvbnMgPSBuZ01vZGVsQ3RybC4kb3B0aW9ucyB8fCB7fTtcblxuICAgICAgICAvLyBtaW1pYyAxLjYrIGFwaVxuICAgICAgICBuZ01vZGVsT3B0aW9ucy5nZXRPcHRpb24gPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgcmV0dXJuIG5nTW9kZWxPcHRpb25zW2tleV07XG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgeyAvLyBpbiBhbmd1bGFyID49MS42ICRvcHRpb25zIGlzIGFsd2F5cyBwcmVzZW50XG4gICAgICAgIG5nTW9kZWxPcHRpb25zID0gbmdNb2RlbEN0cmwuJG9wdGlvbnM7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZ01vZGVsT3B0aW9ucztcbiAgICB9XG4gIH1dKVxuXG4gIC5kaXJlY3RpdmUoJ3VpYlR5cGVhaGVhZCcsIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjb250cm9sbGVyOiAnVWliVHlwZWFoZWFkQ29udHJvbGxlcicsXG4gICAgICByZXF1aXJlOiBbJ25nTW9kZWwnLCAndWliVHlwZWFoZWFkJ10sXG4gICAgICBsaW5rOiBmdW5jdGlvbihvcmlnaW5hbFNjb3BlLCBlbGVtZW50LCBhdHRycywgY3RybHMpIHtcbiAgICAgICAgY3RybHNbMV0uaW5pdChjdHJsc1swXSk7XG4gICAgICB9XG4gICAgfTtcbiAgfSlcblxuICAuZGlyZWN0aXZlKCd1aWJUeXBlYWhlYWRQb3B1cCcsIFsnJCRkZWJvdW5jZScsIGZ1bmN0aW9uKCQkZGVib3VuY2UpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc2NvcGU6IHtcbiAgICAgICAgbWF0Y2hlczogJz0nLFxuICAgICAgICBxdWVyeTogJz0nLFxuICAgICAgICBhY3RpdmU6ICc9JyxcbiAgICAgICAgcG9zaXRpb246ICcmJyxcbiAgICAgICAgbW92ZUluUHJvZ3Jlc3M6ICc9JyxcbiAgICAgICAgc2VsZWN0OiAnJicsXG4gICAgICAgIGFzc2lnbklzT3BlbjogJyYnLFxuICAgICAgICBkZWJvdW5jZTogJyYnXG4gICAgICB9LFxuICAgICAgcmVwbGFjZTogdHJ1ZSxcbiAgICAgIHRlbXBsYXRlVXJsOiBmdW5jdGlvbihlbGVtZW50LCBhdHRycykge1xuICAgICAgICByZXR1cm4gYXR0cnMucG9wdXBUZW1wbGF0ZVVybCB8fCAndWliL3RlbXBsYXRlL3R5cGVhaGVhZC90eXBlYWhlYWQtcG9wdXAuaHRtbCc7XG4gICAgICB9LFxuICAgICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHJzKSB7XG4gICAgICAgIHNjb3BlLnRlbXBsYXRlVXJsID0gYXR0cnMudGVtcGxhdGVVcmw7XG5cbiAgICAgICAgc2NvcGUuaXNPcGVuID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIGlzRHJvcGRvd25PcGVuID0gc2NvcGUubWF0Y2hlcy5sZW5ndGggPiAwO1xuICAgICAgICAgIHNjb3BlLmFzc2lnbklzT3Blbih7IGlzT3BlbjogaXNEcm9wZG93bk9wZW4gfSk7XG4gICAgICAgICAgcmV0dXJuIGlzRHJvcGRvd25PcGVuO1xuICAgICAgICB9O1xuXG4gICAgICAgIHNjb3BlLmlzQWN0aXZlID0gZnVuY3Rpb24obWF0Y2hJZHgpIHtcbiAgICAgICAgICByZXR1cm4gc2NvcGUuYWN0aXZlID09PSBtYXRjaElkeDtcbiAgICAgICAgfTtcblxuICAgICAgICBzY29wZS5zZWxlY3RBY3RpdmUgPSBmdW5jdGlvbihtYXRjaElkeCkge1xuICAgICAgICAgIHNjb3BlLmFjdGl2ZSA9IG1hdGNoSWR4O1xuICAgICAgICB9O1xuXG4gICAgICAgIHNjb3BlLnNlbGVjdE1hdGNoID0gZnVuY3Rpb24oYWN0aXZlSWR4LCBldnQpIHtcbiAgICAgICAgICB2YXIgZGVib3VuY2UgPSBzY29wZS5kZWJvdW5jZSgpO1xuICAgICAgICAgIGlmIChhbmd1bGFyLmlzTnVtYmVyKGRlYm91bmNlKSB8fCBhbmd1bGFyLmlzT2JqZWN0KGRlYm91bmNlKSkge1xuICAgICAgICAgICAgJCRkZWJvdW5jZShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgc2NvcGUuc2VsZWN0KHthY3RpdmVJZHg6IGFjdGl2ZUlkeCwgZXZ0OiBldnR9KTtcbiAgICAgICAgICAgIH0sIGFuZ3VsYXIuaXNOdW1iZXIoZGVib3VuY2UpID8gZGVib3VuY2UgOiBkZWJvdW5jZVsnZGVmYXVsdCddKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2NvcGUuc2VsZWN0KHthY3RpdmVJZHg6IGFjdGl2ZUlkeCwgZXZ0OiBldnR9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcbiAgfV0pXG5cbiAgLmRpcmVjdGl2ZSgndWliVHlwZWFoZWFkTWF0Y2gnLCBbJyR0ZW1wbGF0ZVJlcXVlc3QnLCAnJGNvbXBpbGUnLCAnJHBhcnNlJywgZnVuY3Rpb24oJHRlbXBsYXRlUmVxdWVzdCwgJGNvbXBpbGUsICRwYXJzZSkge1xuICAgIHJldHVybiB7XG4gICAgICBzY29wZToge1xuICAgICAgICBpbmRleDogJz0nLFxuICAgICAgICBtYXRjaDogJz0nLFxuICAgICAgICBxdWVyeTogJz0nXG4gICAgICB9LFxuICAgICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHJzKSB7XG4gICAgICAgIHZhciB0cGxVcmwgPSAkcGFyc2UoYXR0cnMudGVtcGxhdGVVcmwpKHNjb3BlLiRwYXJlbnQpIHx8ICd1aWIvdGVtcGxhdGUvdHlwZWFoZWFkL3R5cGVhaGVhZC1tYXRjaC5odG1sJztcbiAgICAgICAgJHRlbXBsYXRlUmVxdWVzdCh0cGxVcmwpLnRoZW4oZnVuY3Rpb24odHBsQ29udGVudCkge1xuICAgICAgICAgIHZhciB0cGxFbCA9IGFuZ3VsYXIuZWxlbWVudCh0cGxDb250ZW50LnRyaW0oKSk7XG4gICAgICAgICAgZWxlbWVudC5yZXBsYWNlV2l0aCh0cGxFbCk7XG4gICAgICAgICAgJGNvbXBpbGUodHBsRWwpKHNjb3BlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgfV0pXG5cbiAgLmZpbHRlcigndWliVHlwZWFoZWFkSGlnaGxpZ2h0JywgWyckc2NlJywgJyRpbmplY3RvcicsICckbG9nJywgZnVuY3Rpb24oJHNjZSwgJGluamVjdG9yLCAkbG9nKSB7XG4gICAgdmFyIGlzU2FuaXRpemVQcmVzZW50O1xuICAgIGlzU2FuaXRpemVQcmVzZW50ID0gJGluamVjdG9yLmhhcygnJHNhbml0aXplJyk7XG5cbiAgICBmdW5jdGlvbiBlc2NhcGVSZWdleHAocXVlcnlUb0VzY2FwZSkge1xuICAgICAgLy8gUmVnZXg6IGNhcHR1cmUgdGhlIHdob2xlIHF1ZXJ5IHN0cmluZyBhbmQgcmVwbGFjZSBpdCB3aXRoIHRoZSBzdHJpbmcgdGhhdCB3aWxsIGJlIHVzZWQgdG8gbWF0Y2hcbiAgICAgIC8vIHRoZSByZXN1bHRzLCBmb3IgZXhhbXBsZSBpZiB0aGUgY2FwdHVyZSBpcyBcImFcIiB0aGUgcmVzdWx0IHdpbGwgYmUgXFxhXG4gICAgICByZXR1cm4gcXVlcnlUb0VzY2FwZS5yZXBsYWNlKC8oWy4/KiteJFtcXF1cXFxcKCl7fXwtXSkvZywgJ1xcXFwkMScpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbnRhaW5zSHRtbChtYXRjaEl0ZW0pIHtcbiAgICAgIHJldHVybiAvPC4qPi9nLnRlc3QobWF0Y2hJdGVtKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24obWF0Y2hJdGVtLCBxdWVyeSkge1xuICAgICAgaWYgKCFpc1Nhbml0aXplUHJlc2VudCAmJiBjb250YWluc0h0bWwobWF0Y2hJdGVtKSkge1xuICAgICAgICAkbG9nLndhcm4oJ1Vuc2FmZSB1c2Ugb2YgdHlwZWFoZWFkIHBsZWFzZSB1c2UgbmdTYW5pdGl6ZScpOyAvLyBXYXJuIHRoZSB1c2VyIGFib3V0IHRoZSBkYW5nZXJcbiAgICAgIH1cbiAgICAgIG1hdGNoSXRlbSA9IHF1ZXJ5ID8gKCcnICsgbWF0Y2hJdGVtKS5yZXBsYWNlKG5ldyBSZWdFeHAoZXNjYXBlUmVnZXhwKHF1ZXJ5KSwgJ2dpJyksICc8c3Ryb25nPiQmPC9zdHJvbmc+JykgOiBtYXRjaEl0ZW07IC8vIFJlcGxhY2VzIHRoZSBjYXB0dXJlIHN0cmluZyB3aXRoIGEgdGhlIHNhbWUgc3RyaW5nIGluc2lkZSBvZiBhIFwic3Ryb25nXCIgdGFnXG4gICAgICBpZiAoIWlzU2FuaXRpemVQcmVzZW50KSB7XG4gICAgICAgIG1hdGNoSXRlbSA9ICRzY2UudHJ1c3RBc0h0bWwobWF0Y2hJdGVtKTsgLy8gSWYgJHNhbml0aXplIGlzIG5vdCBwcmVzZW50IHdlIHBhY2sgdGhlIHN0cmluZyBpbiBhICRzY2Ugb2JqZWN0IGZvciB0aGUgbmctYmluZC1odG1sIGRpcmVjdGl2ZVxuICAgICAgfVxuICAgICAgcmV0dXJuIG1hdGNoSXRlbTtcbiAgICB9O1xuICB9XSk7XG5cbmFuZ3VsYXIubW9kdWxlKFwidWliL3RlbXBsYXRlL2FjY29yZGlvbi9hY2NvcmRpb24tZ3JvdXAuaHRtbFwiLCBbXSkucnVuKFtcIiR0ZW1wbGF0ZUNhY2hlXCIsIGZ1bmN0aW9uICgkdGVtcGxhdGVDYWNoZSkge1xuICAkdGVtcGxhdGVDYWNoZS5wdXQoXCJ1aWIvdGVtcGxhdGUvYWNjb3JkaW9uL2FjY29yZGlvbi1ncm91cC5odG1sXCIsXG4gICAgXCI8ZGl2IHJvbGU9XFxcInRhYlxcXCIgaWQ9XFxcInt7OjpoZWFkaW5nSWR9fVxcXCIgYXJpYS1zZWxlY3RlZD1cXFwie3tpc09wZW59fVxcXCIgY2xhc3M9XFxcInBhbmVsLWhlYWRpbmdcXFwiIG5nLWtleXByZXNzPVxcXCJ0b2dnbGVPcGVuKCRldmVudClcXFwiPlxcblwiICtcbiAgICBcIiAgPGg0IGNsYXNzPVxcXCJwYW5lbC10aXRsZVxcXCI+XFxuXCIgK1xuICAgIFwiICAgIDxhIHJvbGU9XFxcImJ1dHRvblxcXCIgZGF0YS10b2dnbGU9XFxcImNvbGxhcHNlXFxcIiBocmVmIGFyaWEtZXhwYW5kZWQ9XFxcInt7aXNPcGVufX1cXFwiIGFyaWEtY29udHJvbHM9XFxcInt7OjpwYW5lbElkfX1cXFwiIHRhYmluZGV4PVxcXCIwXFxcIiBjbGFzcz1cXFwiYWNjb3JkaW9uLXRvZ2dsZVxcXCIgbmctY2xpY2s9XFxcInRvZ2dsZU9wZW4oKVxcXCIgdWliLWFjY29yZGlvbi10cmFuc2NsdWRlPVxcXCJoZWFkaW5nXFxcIiBuZy1kaXNhYmxlZD1cXFwiaXNEaXNhYmxlZFxcXCIgdWliLXRhYmluZGV4LXRvZ2dsZT48c3BhbiB1aWItYWNjb3JkaW9uLWhlYWRlciBuZy1jbGFzcz1cXFwieyd0ZXh0LW11dGVkJzogaXNEaXNhYmxlZH1cXFwiPnt7aGVhZGluZ319PC9zcGFuPjwvYT5cXG5cIiArXG4gICAgXCIgIDwvaDQ+XFxuXCIgK1xuICAgIFwiPC9kaXY+XFxuXCIgK1xuICAgIFwiPGRpdiBpZD1cXFwie3s6OnBhbmVsSWR9fVxcXCIgYXJpYS1sYWJlbGxlZGJ5PVxcXCJ7ezo6aGVhZGluZ0lkfX1cXFwiIGFyaWEtaGlkZGVuPVxcXCJ7eyFpc09wZW59fVxcXCIgcm9sZT1cXFwidGFicGFuZWxcXFwiIGNsYXNzPVxcXCJwYW5lbC1jb2xsYXBzZSBjb2xsYXBzZVxcXCIgdWliLWNvbGxhcHNlPVxcXCIhaXNPcGVuXFxcIj5cXG5cIiArXG4gICAgXCIgIDxkaXYgY2xhc3M9XFxcInBhbmVsLWJvZHlcXFwiIG5nLXRyYW5zY2x1ZGU+PC9kaXY+XFxuXCIgK1xuICAgIFwiPC9kaXY+XFxuXCIgK1xuICAgIFwiXCIpO1xufV0pO1xuXG5hbmd1bGFyLm1vZHVsZShcInVpYi90ZW1wbGF0ZS9hY2NvcmRpb24vYWNjb3JkaW9uLmh0bWxcIiwgW10pLnJ1bihbXCIkdGVtcGxhdGVDYWNoZVwiLCBmdW5jdGlvbiAoJHRlbXBsYXRlQ2FjaGUpIHtcbiAgJHRlbXBsYXRlQ2FjaGUucHV0KFwidWliL3RlbXBsYXRlL2FjY29yZGlvbi9hY2NvcmRpb24uaHRtbFwiLFxuICAgIFwiPGRpdiByb2xlPVxcXCJ0YWJsaXN0XFxcIiBjbGFzcz1cXFwicGFuZWwtZ3JvdXBcXFwiIG5nLXRyYW5zY2x1ZGU+PC9kaXY+XCIpO1xufV0pO1xuXG5hbmd1bGFyLm1vZHVsZShcInVpYi90ZW1wbGF0ZS9hbGVydC9hbGVydC5odG1sXCIsIFtdKS5ydW4oW1wiJHRlbXBsYXRlQ2FjaGVcIiwgZnVuY3Rpb24gKCR0ZW1wbGF0ZUNhY2hlKSB7XG4gICR0ZW1wbGF0ZUNhY2hlLnB1dChcInVpYi90ZW1wbGF0ZS9hbGVydC9hbGVydC5odG1sXCIsXG4gICAgXCI8YnV0dG9uIG5nLXNob3c9XFxcImNsb3NlYWJsZVxcXCIgdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiY2xvc2VcXFwiIG5nLWNsaWNrPVxcXCJjbG9zZSh7JGV2ZW50OiAkZXZlbnR9KVxcXCI+XFxuXCIgK1xuICAgIFwiICA8c3BhbiBhcmlhLWhpZGRlbj1cXFwidHJ1ZVxcXCI+JnRpbWVzOzwvc3Bhbj5cXG5cIiArXG4gICAgXCIgIDxzcGFuIGNsYXNzPVxcXCJzci1vbmx5XFxcIj5DbG9zZTwvc3Bhbj5cXG5cIiArXG4gICAgXCI8L2J1dHRvbj5cXG5cIiArXG4gICAgXCI8ZGl2IG5nLXRyYW5zY2x1ZGU+PC9kaXY+XFxuXCIgK1xuICAgIFwiXCIpO1xufV0pO1xuXG5hbmd1bGFyLm1vZHVsZShcInVpYi90ZW1wbGF0ZS9jYXJvdXNlbC9jYXJvdXNlbC5odG1sXCIsIFtdKS5ydW4oW1wiJHRlbXBsYXRlQ2FjaGVcIiwgZnVuY3Rpb24gKCR0ZW1wbGF0ZUNhY2hlKSB7XG4gICR0ZW1wbGF0ZUNhY2hlLnB1dChcInVpYi90ZW1wbGF0ZS9jYXJvdXNlbC9jYXJvdXNlbC5odG1sXCIsXG4gICAgXCI8ZGl2IGNsYXNzPVxcXCJjYXJvdXNlbC1pbm5lclxcXCIgbmctdHJhbnNjbHVkZT48L2Rpdj5cXG5cIiArXG4gICAgXCI8YSByb2xlPVxcXCJidXR0b25cXFwiIGhyZWYgY2xhc3M9XFxcImxlZnQgY2Fyb3VzZWwtY29udHJvbFxcXCIgbmctY2xpY2s9XFxcInByZXYoKVxcXCIgbmctY2xhc3M9XFxcInsgZGlzYWJsZWQ6IGlzUHJldkRpc2FibGVkKCkgfVxcXCIgbmctc2hvdz1cXFwic2xpZGVzLmxlbmd0aCA+IDFcXFwiPlxcblwiICtcbiAgICBcIiAgPHNwYW4gYXJpYS1oaWRkZW49XFxcInRydWVcXFwiIGNsYXNzPVxcXCJnbHlwaGljb24gZ2x5cGhpY29uLWNoZXZyb24tbGVmdFxcXCI+PC9zcGFuPlxcblwiICtcbiAgICBcIiAgPHNwYW4gY2xhc3M9XFxcInNyLW9ubHlcXFwiPnByZXZpb3VzPC9zcGFuPlxcblwiICtcbiAgICBcIjwvYT5cXG5cIiArXG4gICAgXCI8YSByb2xlPVxcXCJidXR0b25cXFwiIGhyZWYgY2xhc3M9XFxcInJpZ2h0IGNhcm91c2VsLWNvbnRyb2xcXFwiIG5nLWNsaWNrPVxcXCJuZXh0KClcXFwiIG5nLWNsYXNzPVxcXCJ7IGRpc2FibGVkOiBpc05leHREaXNhYmxlZCgpIH1cXFwiIG5nLXNob3c9XFxcInNsaWRlcy5sZW5ndGggPiAxXFxcIj5cXG5cIiArXG4gICAgXCIgIDxzcGFuIGFyaWEtaGlkZGVuPVxcXCJ0cnVlXFxcIiBjbGFzcz1cXFwiZ2x5cGhpY29uIGdseXBoaWNvbi1jaGV2cm9uLXJpZ2h0XFxcIj48L3NwYW4+XFxuXCIgK1xuICAgIFwiICA8c3BhbiBjbGFzcz1cXFwic3Itb25seVxcXCI+bmV4dDwvc3Bhbj5cXG5cIiArXG4gICAgXCI8L2E+XFxuXCIgK1xuICAgIFwiPG9sIGNsYXNzPVxcXCJjYXJvdXNlbC1pbmRpY2F0b3JzXFxcIiBuZy1zaG93PVxcXCJzbGlkZXMubGVuZ3RoID4gMVxcXCI+XFxuXCIgK1xuICAgIFwiICA8bGkgbmctcmVwZWF0PVxcXCJzbGlkZSBpbiBzbGlkZXMgfCBvcmRlckJ5OmluZGV4T2ZTbGlkZSB0cmFjayBieSAkaW5kZXhcXFwiIG5nLWNsYXNzPVxcXCJ7IGFjdGl2ZTogaXNBY3RpdmUoc2xpZGUpIH1cXFwiIG5nLWNsaWNrPVxcXCJzZWxlY3Qoc2xpZGUpXFxcIj5cXG5cIiArXG4gICAgXCIgICAgPHNwYW4gY2xhc3M9XFxcInNyLW9ubHlcXFwiPnNsaWRlIHt7ICRpbmRleCArIDEgfX0gb2Yge3sgc2xpZGVzLmxlbmd0aCB9fTxzcGFuIG5nLWlmPVxcXCJpc0FjdGl2ZShzbGlkZSlcXFwiPiwgY3VycmVudGx5IGFjdGl2ZTwvc3Bhbj48L3NwYW4+XFxuXCIgK1xuICAgIFwiICA8L2xpPlxcblwiICtcbiAgICBcIjwvb2w+XFxuXCIgK1xuICAgIFwiXCIpO1xufV0pO1xuXG5hbmd1bGFyLm1vZHVsZShcInVpYi90ZW1wbGF0ZS9jYXJvdXNlbC9zbGlkZS5odG1sXCIsIFtdKS5ydW4oW1wiJHRlbXBsYXRlQ2FjaGVcIiwgZnVuY3Rpb24gKCR0ZW1wbGF0ZUNhY2hlKSB7XG4gICR0ZW1wbGF0ZUNhY2hlLnB1dChcInVpYi90ZW1wbGF0ZS9jYXJvdXNlbC9zbGlkZS5odG1sXCIsXG4gICAgXCI8ZGl2IGNsYXNzPVxcXCJ0ZXh0LWNlbnRlclxcXCIgbmctdHJhbnNjbHVkZT48L2Rpdj5cXG5cIiArXG4gICAgXCJcIik7XG59XSk7XG5cbmFuZ3VsYXIubW9kdWxlKFwidWliL3RlbXBsYXRlL2RhdGVwaWNrZXIvZGF0ZXBpY2tlci5odG1sXCIsIFtdKS5ydW4oW1wiJHRlbXBsYXRlQ2FjaGVcIiwgZnVuY3Rpb24gKCR0ZW1wbGF0ZUNhY2hlKSB7XG4gICR0ZW1wbGF0ZUNhY2hlLnB1dChcInVpYi90ZW1wbGF0ZS9kYXRlcGlja2VyL2RhdGVwaWNrZXIuaHRtbFwiLFxuICAgIFwiPGRpdiBuZy1zd2l0Y2g9XFxcImRhdGVwaWNrZXJNb2RlXFxcIj5cXG5cIiArXG4gICAgXCIgIDxkaXYgdWliLWRheXBpY2tlciBuZy1zd2l0Y2gtd2hlbj1cXFwiZGF5XFxcIiB0YWJpbmRleD1cXFwiMFxcXCIgY2xhc3M9XFxcInVpYi1kYXlwaWNrZXJcXFwiPjwvZGl2PlxcblwiICtcbiAgICBcIiAgPGRpdiB1aWItbW9udGhwaWNrZXIgbmctc3dpdGNoLXdoZW49XFxcIm1vbnRoXFxcIiB0YWJpbmRleD1cXFwiMFxcXCIgY2xhc3M9XFxcInVpYi1tb250aHBpY2tlclxcXCI+PC9kaXY+XFxuXCIgK1xuICAgIFwiICA8ZGl2IHVpYi15ZWFycGlja2VyIG5nLXN3aXRjaC13aGVuPVxcXCJ5ZWFyXFxcIiB0YWJpbmRleD1cXFwiMFxcXCIgY2xhc3M9XFxcInVpYi15ZWFycGlja2VyXFxcIj48L2Rpdj5cXG5cIiArXG4gICAgXCI8L2Rpdj5cXG5cIiArXG4gICAgXCJcIik7XG59XSk7XG5cbmFuZ3VsYXIubW9kdWxlKFwidWliL3RlbXBsYXRlL2RhdGVwaWNrZXIvZGF5Lmh0bWxcIiwgW10pLnJ1bihbXCIkdGVtcGxhdGVDYWNoZVwiLCBmdW5jdGlvbiAoJHRlbXBsYXRlQ2FjaGUpIHtcbiAgJHRlbXBsYXRlQ2FjaGUucHV0KFwidWliL3RlbXBsYXRlL2RhdGVwaWNrZXIvZGF5Lmh0bWxcIixcbiAgICBcIjx0YWJsZSByb2xlPVxcXCJncmlkXFxcIiBhcmlhLWxhYmVsbGVkYnk9XFxcInt7Ojp1bmlxdWVJZH19LXRpdGxlXFxcIiBhcmlhLWFjdGl2ZWRlc2NlbmRhbnQ9XFxcInt7YWN0aXZlRGF0ZUlkfX1cXFwiPlxcblwiICtcbiAgICBcIiAgPHRoZWFkPlxcblwiICtcbiAgICBcIiAgICA8dHI+XFxuXCIgK1xuICAgIFwiICAgICAgPHRoPjxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1kZWZhdWx0IGJ0bi1zbSBwdWxsLWxlZnQgdWliLWxlZnRcXFwiIG5nLWNsaWNrPVxcXCJtb3ZlKC0xKVxcXCIgdGFiaW5kZXg9XFxcIi0xXFxcIj48aSBhcmlhLWhpZGRlbj1cXFwidHJ1ZVxcXCIgY2xhc3M9XFxcImdseXBoaWNvbiBnbHlwaGljb24tY2hldnJvbi1sZWZ0XFxcIj48L2k+PHNwYW4gY2xhc3M9XFxcInNyLW9ubHlcXFwiPnByZXZpb3VzPC9zcGFuPjwvYnV0dG9uPjwvdGg+XFxuXCIgK1xuICAgIFwiICAgICAgPHRoIGNvbHNwYW49XFxcInt7Ojo1ICsgc2hvd1dlZWtzfX1cXFwiPjxidXR0b24gaWQ9XFxcInt7Ojp1bmlxdWVJZH19LXRpdGxlXFxcIiByb2xlPVxcXCJoZWFkaW5nXFxcIiBhcmlhLWxpdmU9XFxcImFzc2VydGl2ZVxcXCIgYXJpYS1hdG9taWM9XFxcInRydWVcXFwiIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImJ0biBidG4tZGVmYXVsdCBidG4tc20gdWliLXRpdGxlXFxcIiBuZy1jbGljaz1cXFwidG9nZ2xlTW9kZSgpXFxcIiBuZy1kaXNhYmxlZD1cXFwiZGF0ZXBpY2tlck1vZGUgPT09IG1heE1vZGVcXFwiIHRhYmluZGV4PVxcXCItMVxcXCI+PHN0cm9uZz57e3RpdGxlfX08L3N0cm9uZz48L2J1dHRvbj48L3RoPlxcblwiICtcbiAgICBcIiAgICAgIDx0aD48YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImJ0biBidG4tZGVmYXVsdCBidG4tc20gcHVsbC1yaWdodCB1aWItcmlnaHRcXFwiIG5nLWNsaWNrPVxcXCJtb3ZlKDEpXFxcIiB0YWJpbmRleD1cXFwiLTFcXFwiPjxpIGFyaWEtaGlkZGVuPVxcXCJ0cnVlXFxcIiBjbGFzcz1cXFwiZ2x5cGhpY29uIGdseXBoaWNvbi1jaGV2cm9uLXJpZ2h0XFxcIj48L2k+PHNwYW4gY2xhc3M9XFxcInNyLW9ubHlcXFwiPm5leHQ8L3NwYW4+PC9idXR0b24+PC90aD5cXG5cIiArXG4gICAgXCIgICAgPC90cj5cXG5cIiArXG4gICAgXCIgICAgPHRyPlxcblwiICtcbiAgICBcIiAgICAgIDx0aCBuZy1pZj1cXFwic2hvd1dlZWtzXFxcIiBjbGFzcz1cXFwidGV4dC1jZW50ZXJcXFwiPjwvdGg+XFxuXCIgK1xuICAgIFwiICAgICAgPHRoIG5nLXJlcGVhdD1cXFwibGFiZWwgaW4gOjpsYWJlbHMgdHJhY2sgYnkgJGluZGV4XFxcIiBjbGFzcz1cXFwidGV4dC1jZW50ZXJcXFwiPjxzbWFsbCBhcmlhLWxhYmVsPVxcXCJ7ezo6bGFiZWwuZnVsbH19XFxcIj57ezo6bGFiZWwuYWJicn19PC9zbWFsbD48L3RoPlxcblwiICtcbiAgICBcIiAgICA8L3RyPlxcblwiICtcbiAgICBcIiAgPC90aGVhZD5cXG5cIiArXG4gICAgXCIgIDx0Ym9keT5cXG5cIiArXG4gICAgXCIgICAgPHRyIGNsYXNzPVxcXCJ1aWItd2Vla3NcXFwiIG5nLXJlcGVhdD1cXFwicm93IGluIHJvd3MgdHJhY2sgYnkgJGluZGV4XFxcIiByb2xlPVxcXCJyb3dcXFwiPlxcblwiICtcbiAgICBcIiAgICAgIDx0ZCBuZy1pZj1cXFwic2hvd1dlZWtzXFxcIiBjbGFzcz1cXFwidGV4dC1jZW50ZXIgaDZcXFwiPjxlbT57eyB3ZWVrTnVtYmVyc1skaW5kZXhdIH19PC9lbT48L3RkPlxcblwiICtcbiAgICBcIiAgICAgIDx0ZCBuZy1yZXBlYXQ9XFxcImR0IGluIHJvd1xcXCIgY2xhc3M9XFxcInVpYi1kYXkgdGV4dC1jZW50ZXJcXFwiIHJvbGU9XFxcImdyaWRjZWxsXFxcIlxcblwiICtcbiAgICBcIiAgICAgICAgaWQ9XFxcInt7OjpkdC51aWR9fVxcXCJcXG5cIiArXG4gICAgXCIgICAgICAgIG5nLWNsYXNzPVxcXCI6OmR0LmN1c3RvbUNsYXNzXFxcIj5cXG5cIiArXG4gICAgXCIgICAgICAgIDxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1kZWZhdWx0IGJ0bi1zbVxcXCJcXG5cIiArXG4gICAgXCIgICAgICAgICAgdWliLWlzLWNsYXNzPVxcXCJcXG5cIiArXG4gICAgXCIgICAgICAgICAgICAnYnRuLWluZm8nIGZvciBzZWxlY3RlZER0LFxcblwiICtcbiAgICBcIiAgICAgICAgICAgICdhY3RpdmUnIGZvciBhY3RpdmVEdFxcblwiICtcbiAgICBcIiAgICAgICAgICAgIG9uIGR0XFxcIlxcblwiICtcbiAgICBcIiAgICAgICAgICBuZy1jbGljaz1cXFwic2VsZWN0KGR0LmRhdGUpXFxcIlxcblwiICtcbiAgICBcIiAgICAgICAgICBuZy1kaXNhYmxlZD1cXFwiOjpkdC5kaXNhYmxlZFxcXCJcXG5cIiArXG4gICAgXCIgICAgICAgICAgdGFiaW5kZXg9XFxcIi0xXFxcIj48c3BhbiBuZy1jbGFzcz1cXFwiOjp7J3RleHQtbXV0ZWQnOiBkdC5zZWNvbmRhcnksICd0ZXh0LWluZm8nOiBkdC5jdXJyZW50fVxcXCI+e3s6OmR0LmxhYmVsfX08L3NwYW4+PC9idXR0b24+XFxuXCIgK1xuICAgIFwiICAgICAgPC90ZD5cXG5cIiArXG4gICAgXCIgICAgPC90cj5cXG5cIiArXG4gICAgXCIgIDwvdGJvZHk+XFxuXCIgK1xuICAgIFwiPC90YWJsZT5cXG5cIiArXG4gICAgXCJcIik7XG59XSk7XG5cbmFuZ3VsYXIubW9kdWxlKFwidWliL3RlbXBsYXRlL2RhdGVwaWNrZXIvbW9udGguaHRtbFwiLCBbXSkucnVuKFtcIiR0ZW1wbGF0ZUNhY2hlXCIsIGZ1bmN0aW9uICgkdGVtcGxhdGVDYWNoZSkge1xuICAkdGVtcGxhdGVDYWNoZS5wdXQoXCJ1aWIvdGVtcGxhdGUvZGF0ZXBpY2tlci9tb250aC5odG1sXCIsXG4gICAgXCI8dGFibGUgcm9sZT1cXFwiZ3JpZFxcXCIgYXJpYS1sYWJlbGxlZGJ5PVxcXCJ7ezo6dW5pcXVlSWR9fS10aXRsZVxcXCIgYXJpYS1hY3RpdmVkZXNjZW5kYW50PVxcXCJ7e2FjdGl2ZURhdGVJZH19XFxcIj5cXG5cIiArXG4gICAgXCIgIDx0aGVhZD5cXG5cIiArXG4gICAgXCIgICAgPHRyPlxcblwiICtcbiAgICBcIiAgICAgIDx0aD48YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImJ0biBidG4tZGVmYXVsdCBidG4tc20gcHVsbC1sZWZ0IHVpYi1sZWZ0XFxcIiBuZy1jbGljaz1cXFwibW92ZSgtMSlcXFwiIHRhYmluZGV4PVxcXCItMVxcXCI+PGkgYXJpYS1oaWRkZW49XFxcInRydWVcXFwiIGNsYXNzPVxcXCJnbHlwaGljb24gZ2x5cGhpY29uLWNoZXZyb24tbGVmdFxcXCI+PC9pPjxzcGFuIGNsYXNzPVxcXCJzci1vbmx5XFxcIj5wcmV2aW91czwvc3Bhbj48L2J1dHRvbj48L3RoPlxcblwiICtcbiAgICBcIiAgICAgIDx0aCBjb2xzcGFuPVxcXCJ7ezo6eWVhckhlYWRlckNvbHNwYW59fVxcXCI+PGJ1dHRvbiBpZD1cXFwie3s6OnVuaXF1ZUlkfX0tdGl0bGVcXFwiIHJvbGU9XFxcImhlYWRpbmdcXFwiIGFyaWEtbGl2ZT1cXFwiYXNzZXJ0aXZlXFxcIiBhcmlhLWF0b21pYz1cXFwidHJ1ZVxcXCIgdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1kZWZhdWx0IGJ0bi1zbSB1aWItdGl0bGVcXFwiIG5nLWNsaWNrPVxcXCJ0b2dnbGVNb2RlKClcXFwiIG5nLWRpc2FibGVkPVxcXCJkYXRlcGlja2VyTW9kZSA9PT0gbWF4TW9kZVxcXCIgdGFiaW5kZXg9XFxcIi0xXFxcIj48c3Ryb25nPnt7dGl0bGV9fTwvc3Ryb25nPjwvYnV0dG9uPjwvdGg+XFxuXCIgK1xuICAgIFwiICAgICAgPHRoPjxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1kZWZhdWx0IGJ0bi1zbSBwdWxsLXJpZ2h0IHVpYi1yaWdodFxcXCIgbmctY2xpY2s9XFxcIm1vdmUoMSlcXFwiIHRhYmluZGV4PVxcXCItMVxcXCI+PGkgYXJpYS1oaWRkZW49XFxcInRydWVcXFwiIGNsYXNzPVxcXCJnbHlwaGljb24gZ2x5cGhpY29uLWNoZXZyb24tcmlnaHRcXFwiPjwvaT48c3BhbiBjbGFzcz1cXFwic3Itb25seVxcXCI+bmV4dDwvc3Bhbj48L2k+PC9idXR0b24+PC90aD5cXG5cIiArXG4gICAgXCIgICAgPC90cj5cXG5cIiArXG4gICAgXCIgIDwvdGhlYWQ+XFxuXCIgK1xuICAgIFwiICA8dGJvZHk+XFxuXCIgK1xuICAgIFwiICAgIDx0ciBjbGFzcz1cXFwidWliLW1vbnRoc1xcXCIgbmctcmVwZWF0PVxcXCJyb3cgaW4gcm93cyB0cmFjayBieSAkaW5kZXhcXFwiIHJvbGU9XFxcInJvd1xcXCI+XFxuXCIgK1xuICAgIFwiICAgICAgPHRkIG5nLXJlcGVhdD1cXFwiZHQgaW4gcm93XFxcIiBjbGFzcz1cXFwidWliLW1vbnRoIHRleHQtY2VudGVyXFxcIiByb2xlPVxcXCJncmlkY2VsbFxcXCJcXG5cIiArXG4gICAgXCIgICAgICAgIGlkPVxcXCJ7ezo6ZHQudWlkfX1cXFwiXFxuXCIgK1xuICAgIFwiICAgICAgICBuZy1jbGFzcz1cXFwiOjpkdC5jdXN0b21DbGFzc1xcXCI+XFxuXCIgK1xuICAgIFwiICAgICAgICA8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImJ0biBidG4tZGVmYXVsdFxcXCJcXG5cIiArXG4gICAgXCIgICAgICAgICAgdWliLWlzLWNsYXNzPVxcXCJcXG5cIiArXG4gICAgXCIgICAgICAgICAgICAnYnRuLWluZm8nIGZvciBzZWxlY3RlZER0LFxcblwiICtcbiAgICBcIiAgICAgICAgICAgICdhY3RpdmUnIGZvciBhY3RpdmVEdFxcblwiICtcbiAgICBcIiAgICAgICAgICAgIG9uIGR0XFxcIlxcblwiICtcbiAgICBcIiAgICAgICAgICBuZy1jbGljaz1cXFwic2VsZWN0KGR0LmRhdGUpXFxcIlxcblwiICtcbiAgICBcIiAgICAgICAgICBuZy1kaXNhYmxlZD1cXFwiOjpkdC5kaXNhYmxlZFxcXCJcXG5cIiArXG4gICAgXCIgICAgICAgICAgdGFiaW5kZXg9XFxcIi0xXFxcIj48c3BhbiBuZy1jbGFzcz1cXFwiOjp7J3RleHQtaW5mbyc6IGR0LmN1cnJlbnR9XFxcIj57ezo6ZHQubGFiZWx9fTwvc3Bhbj48L2J1dHRvbj5cXG5cIiArXG4gICAgXCIgICAgICA8L3RkPlxcblwiICtcbiAgICBcIiAgICA8L3RyPlxcblwiICtcbiAgICBcIiAgPC90Ym9keT5cXG5cIiArXG4gICAgXCI8L3RhYmxlPlxcblwiICtcbiAgICBcIlwiKTtcbn1dKTtcblxuYW5ndWxhci5tb2R1bGUoXCJ1aWIvdGVtcGxhdGUvZGF0ZXBpY2tlci9wb3B1cC5odG1sXCIsIFtdKS5ydW4oW1wiJHRlbXBsYXRlQ2FjaGVcIiwgZnVuY3Rpb24oJHRlbXBsYXRlQ2FjaGUpIHtcbiAgJHRlbXBsYXRlQ2FjaGUucHV0KFwidWliL3RlbXBsYXRlL2RhdGVwaWNrZXIvcG9wdXAuaHRtbFwiLFxuICAgIFwiPGRpdj5cXG5cIiArXG4gICAgXCIgIDx1bCBjbGFzcz1cXFwidWliLWRhdGVwaWNrZXItcG9wdXAgZHJvcGRvd24tbWVudSB1aWItcG9zaXRpb24tbWVhc3VyZVxcXCIgZHJvcGRvd24tbmVzdGVkIG5nLWlmPVxcXCJpc09wZW5cXFwiIG5nLWtleWRvd249XFxcImtleWRvd24oJGV2ZW50KVxcXCIgbmctY2xpY2s9XFxcIiRldmVudC5zdG9wUHJvcGFnYXRpb24oKVxcXCI+XFxuXCIgK1xuICAgIFwiICAgIDxsaSBuZy10cmFuc2NsdWRlPjwvbGk+XFxuXCIgK1xuICAgIFwiICAgIDxsaSBuZy1pZj1cXFwic2hvd0J1dHRvbkJhclxcXCIgY2xhc3M9XFxcInVpYi1idXR0b24tYmFyXFxcIj5cXG5cIiArXG4gICAgXCIgICAgICA8c3BhbiBjbGFzcz1cXFwiYnRuLWdyb3VwIHB1bGwtbGVmdFxcXCI+XFxuXCIgK1xuICAgIFwiICAgICAgICA8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImJ0biBidG4tc20gYnRuLWluZm8gdWliLWRhdGVwaWNrZXItY3VycmVudFxcXCIgbmctY2xpY2s9XFxcInNlbGVjdCgndG9kYXknLCAkZXZlbnQpXFxcIiBuZy1kaXNhYmxlZD1cXFwiaXNEaXNhYmxlZCgndG9kYXknKVxcXCI+e3sgZ2V0VGV4dCgnY3VycmVudCcpIH19PC9idXR0b24+XFxuXCIgK1xuICAgIFwiICAgICAgICA8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImJ0biBidG4tc20gYnRuLWRhbmdlciB1aWItY2xlYXJcXFwiIG5nLWNsaWNrPVxcXCJzZWxlY3QobnVsbCwgJGV2ZW50KVxcXCI+e3sgZ2V0VGV4dCgnY2xlYXInKSB9fTwvYnV0dG9uPlxcblwiICtcbiAgICBcIiAgICAgIDwvc3Bhbj5cXG5cIiArXG4gICAgXCIgICAgICA8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImJ0biBidG4tc20gYnRuLXN1Y2Nlc3MgcHVsbC1yaWdodCB1aWItY2xvc2VcXFwiIG5nLWNsaWNrPVxcXCJjbG9zZSgkZXZlbnQpXFxcIj57eyBnZXRUZXh0KCdjbG9zZScpIH19PC9idXR0b24+XFxuXCIgK1xuICAgIFwiICAgIDwvbGk+XFxuXCIgK1xuICAgIFwiICA8L3VsPlxcblwiICtcbiAgICBcIjwvZGl2PlxcblwiICtcbiAgICBcIlwiKTtcbn1dKTtcblxuYW5ndWxhci5tb2R1bGUoXCJ1aWIvdGVtcGxhdGUvZGF0ZXBpY2tlci95ZWFyLmh0bWxcIiwgW10pLnJ1bihbXCIkdGVtcGxhdGVDYWNoZVwiLCBmdW5jdGlvbiAoJHRlbXBsYXRlQ2FjaGUpIHtcbiAgJHRlbXBsYXRlQ2FjaGUucHV0KFwidWliL3RlbXBsYXRlL2RhdGVwaWNrZXIveWVhci5odG1sXCIsXG4gICAgXCI8dGFibGUgcm9sZT1cXFwiZ3JpZFxcXCIgYXJpYS1sYWJlbGxlZGJ5PVxcXCJ7ezo6dW5pcXVlSWR9fS10aXRsZVxcXCIgYXJpYS1hY3RpdmVkZXNjZW5kYW50PVxcXCJ7e2FjdGl2ZURhdGVJZH19XFxcIj5cXG5cIiArXG4gICAgXCIgIDx0aGVhZD5cXG5cIiArXG4gICAgXCIgICAgPHRyPlxcblwiICtcbiAgICBcIiAgICAgIDx0aD48YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImJ0biBidG4tZGVmYXVsdCBidG4tc20gcHVsbC1sZWZ0IHVpYi1sZWZ0XFxcIiBuZy1jbGljaz1cXFwibW92ZSgtMSlcXFwiIHRhYmluZGV4PVxcXCItMVxcXCI+PGkgYXJpYS1oaWRkZW49XFxcInRydWVcXFwiIGNsYXNzPVxcXCJnbHlwaGljb24gZ2x5cGhpY29uLWNoZXZyb24tbGVmdFxcXCI+PC9pPjxzcGFuIGNsYXNzPVxcXCJzci1vbmx5XFxcIj5wcmV2aW91czwvc3Bhbj48L2J1dHRvbj48L3RoPlxcblwiICtcbiAgICBcIiAgICAgIDx0aCBjb2xzcGFuPVxcXCJ7ezo6Y29sdW1ucyAtIDJ9fVxcXCI+PGJ1dHRvbiBpZD1cXFwie3s6OnVuaXF1ZUlkfX0tdGl0bGVcXFwiIHJvbGU9XFxcImhlYWRpbmdcXFwiIGFyaWEtbGl2ZT1cXFwiYXNzZXJ0aXZlXFxcIiBhcmlhLWF0b21pYz1cXFwidHJ1ZVxcXCIgdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1kZWZhdWx0IGJ0bi1zbSB1aWItdGl0bGVcXFwiIG5nLWNsaWNrPVxcXCJ0b2dnbGVNb2RlKClcXFwiIG5nLWRpc2FibGVkPVxcXCJkYXRlcGlja2VyTW9kZSA9PT0gbWF4TW9kZVxcXCIgdGFiaW5kZXg9XFxcIi0xXFxcIj48c3Ryb25nPnt7dGl0bGV9fTwvc3Ryb25nPjwvYnV0dG9uPjwvdGg+XFxuXCIgK1xuICAgIFwiICAgICAgPHRoPjxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1kZWZhdWx0IGJ0bi1zbSBwdWxsLXJpZ2h0IHVpYi1yaWdodFxcXCIgbmctY2xpY2s9XFxcIm1vdmUoMSlcXFwiIHRhYmluZGV4PVxcXCItMVxcXCI+PGkgYXJpYS1oaWRkZW49XFxcInRydWVcXFwiIGNsYXNzPVxcXCJnbHlwaGljb24gZ2x5cGhpY29uLWNoZXZyb24tcmlnaHRcXFwiPjwvaT48c3BhbiBjbGFzcz1cXFwic3Itb25seVxcXCI+bmV4dDwvc3Bhbj48L2J1dHRvbj48L3RoPlxcblwiICtcbiAgICBcIiAgICA8L3RyPlxcblwiICtcbiAgICBcIiAgPC90aGVhZD5cXG5cIiArXG4gICAgXCIgIDx0Ym9keT5cXG5cIiArXG4gICAgXCIgICAgPHRyIGNsYXNzPVxcXCJ1aWIteWVhcnNcXFwiIG5nLXJlcGVhdD1cXFwicm93IGluIHJvd3MgdHJhY2sgYnkgJGluZGV4XFxcIiByb2xlPVxcXCJyb3dcXFwiPlxcblwiICtcbiAgICBcIiAgICAgIDx0ZCBuZy1yZXBlYXQ9XFxcImR0IGluIHJvd1xcXCIgY2xhc3M9XFxcInVpYi15ZWFyIHRleHQtY2VudGVyXFxcIiByb2xlPVxcXCJncmlkY2VsbFxcXCJcXG5cIiArXG4gICAgXCIgICAgICAgIGlkPVxcXCJ7ezo6ZHQudWlkfX1cXFwiXFxuXCIgK1xuICAgIFwiICAgICAgICBuZy1jbGFzcz1cXFwiOjpkdC5jdXN0b21DbGFzc1xcXCI+XFxuXCIgK1xuICAgIFwiICAgICAgICA8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImJ0biBidG4tZGVmYXVsdFxcXCJcXG5cIiArXG4gICAgXCIgICAgICAgICAgdWliLWlzLWNsYXNzPVxcXCJcXG5cIiArXG4gICAgXCIgICAgICAgICAgICAnYnRuLWluZm8nIGZvciBzZWxlY3RlZER0LFxcblwiICtcbiAgICBcIiAgICAgICAgICAgICdhY3RpdmUnIGZvciBhY3RpdmVEdFxcblwiICtcbiAgICBcIiAgICAgICAgICAgIG9uIGR0XFxcIlxcblwiICtcbiAgICBcIiAgICAgICAgICBuZy1jbGljaz1cXFwic2VsZWN0KGR0LmRhdGUpXFxcIlxcblwiICtcbiAgICBcIiAgICAgICAgICBuZy1kaXNhYmxlZD1cXFwiOjpkdC5kaXNhYmxlZFxcXCJcXG5cIiArXG4gICAgXCIgICAgICAgICAgdGFiaW5kZXg9XFxcIi0xXFxcIj48c3BhbiBuZy1jbGFzcz1cXFwiOjp7J3RleHQtaW5mbyc6IGR0LmN1cnJlbnR9XFxcIj57ezo6ZHQubGFiZWx9fTwvc3Bhbj48L2J1dHRvbj5cXG5cIiArXG4gICAgXCIgICAgICA8L3RkPlxcblwiICtcbiAgICBcIiAgICA8L3RyPlxcblwiICtcbiAgICBcIiAgPC90Ym9keT5cXG5cIiArXG4gICAgXCI8L3RhYmxlPlxcblwiICtcbiAgICBcIlwiKTtcbn1dKTtcblxuYW5ndWxhci5tb2R1bGUoXCJ1aWIvdGVtcGxhdGUvZGF0ZXBpY2tlclBvcHVwL3BvcHVwLmh0bWxcIiwgW10pLnJ1bihbXCIkdGVtcGxhdGVDYWNoZVwiLCBmdW5jdGlvbiAoJHRlbXBsYXRlQ2FjaGUpIHtcbiAgJHRlbXBsYXRlQ2FjaGUucHV0KFwidWliL3RlbXBsYXRlL2RhdGVwaWNrZXJQb3B1cC9wb3B1cC5odG1sXCIsXG4gICAgXCI8dWwgcm9sZT1cXFwicHJlc2VudGF0aW9uXFxcIiBjbGFzcz1cXFwidWliLWRhdGVwaWNrZXItcG9wdXAgZHJvcGRvd24tbWVudSB1aWItcG9zaXRpb24tbWVhc3VyZVxcXCIgZHJvcGRvd24tbmVzdGVkIG5nLWlmPVxcXCJpc09wZW5cXFwiIG5nLWtleWRvd249XFxcImtleWRvd24oJGV2ZW50KVxcXCIgbmctY2xpY2s9XFxcIiRldmVudC5zdG9wUHJvcGFnYXRpb24oKVxcXCI+XFxuXCIgK1xuICAgIFwiICA8bGkgbmctdHJhbnNjbHVkZT48L2xpPlxcblwiICtcbiAgICBcIiAgPGxpIG5nLWlmPVxcXCJzaG93QnV0dG9uQmFyXFxcIiBjbGFzcz1cXFwidWliLWJ1dHRvbi1iYXJcXFwiPlxcblwiICtcbiAgICBcIiAgICA8c3BhbiBjbGFzcz1cXFwiYnRuLWdyb3VwIHB1bGwtbGVmdFxcXCI+XFxuXCIgK1xuICAgIFwiICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJidG4gYnRuLXNtIGJ0bi1pbmZvIHVpYi1kYXRlcGlja2VyLWN1cnJlbnRcXFwiIG5nLWNsaWNrPVxcXCJzZWxlY3QoJ3RvZGF5JywgJGV2ZW50KVxcXCIgbmctZGlzYWJsZWQ9XFxcImlzRGlzYWJsZWQoJ3RvZGF5JylcXFwiPnt7IGdldFRleHQoJ2N1cnJlbnQnKSB9fTwvYnV0dG9uPlxcblwiICtcbiAgICBcIiAgICAgIDxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1zbSBidG4tZGFuZ2VyIHVpYi1jbGVhclxcXCIgbmctY2xpY2s9XFxcInNlbGVjdChudWxsLCAkZXZlbnQpXFxcIj57eyBnZXRUZXh0KCdjbGVhcicpIH19PC9idXR0b24+XFxuXCIgK1xuICAgIFwiICAgIDwvc3Bhbj5cXG5cIiArXG4gICAgXCIgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJidG4gYnRuLXNtIGJ0bi1zdWNjZXNzIHB1bGwtcmlnaHQgdWliLWNsb3NlXFxcIiBuZy1jbGljaz1cXFwiY2xvc2UoJGV2ZW50KVxcXCI+e3sgZ2V0VGV4dCgnY2xvc2UnKSB9fTwvYnV0dG9uPlxcblwiICtcbiAgICBcIiAgPC9saT5cXG5cIiArXG4gICAgXCI8L3VsPlxcblwiICtcbiAgICBcIlwiKTtcbn1dKTtcblxuYW5ndWxhci5tb2R1bGUoXCJ1aWIvdGVtcGxhdGUvbW9kYWwvYmFja2Ryb3AuaHRtbFwiLCBbXSkucnVuKFtcIiR0ZW1wbGF0ZUNhY2hlXCIsIGZ1bmN0aW9uKCR0ZW1wbGF0ZUNhY2hlKSB7XG4gICR0ZW1wbGF0ZUNhY2hlLnB1dChcInVpYi90ZW1wbGF0ZS9tb2RhbC9iYWNrZHJvcC5odG1sXCIsXG4gICAgXCI8ZGl2IGNsYXNzPVxcXCJtb2RhbC1iYWNrZHJvcFxcXCJcXG5cIiArXG4gICAgXCIgICAgIHVpYi1tb2RhbC1hbmltYXRpb24tY2xhc3M9XFxcImZhZGVcXFwiXFxuXCIgK1xuICAgIFwiICAgICBtb2RhbC1pbi1jbGFzcz1cXFwiaW5cXFwiXFxuXCIgK1xuICAgIFwiICAgICBuZy1zdHlsZT1cXFwieyd6LWluZGV4JzogMTA0MCArIChpbmRleCAmJiAxIHx8IDApICsgaW5kZXgqMTB9XFxcIlxcblwiICtcbiAgICBcIj48L2Rpdj5cXG5cIiArXG4gICAgXCJcIik7XG59XSk7XG5cbmFuZ3VsYXIubW9kdWxlKFwidWliL3RlbXBsYXRlL21vZGFsL3dpbmRvdy5odG1sXCIsIFtdKS5ydW4oW1wiJHRlbXBsYXRlQ2FjaGVcIiwgZnVuY3Rpb24gKCR0ZW1wbGF0ZUNhY2hlKSB7XG4gICR0ZW1wbGF0ZUNhY2hlLnB1dChcInVpYi90ZW1wbGF0ZS9tb2RhbC93aW5kb3cuaHRtbFwiLFxuICAgIFwiPGRpdiBjbGFzcz1cXFwibW9kYWwtZGlhbG9nIHt7c2l6ZSA/ICdtb2RhbC0nICsgc2l6ZSA6ICcnfX1cXFwiPjxkaXYgY2xhc3M9XFxcIm1vZGFsLWNvbnRlbnRcXFwiIHVpYi1tb2RhbC10cmFuc2NsdWRlPjwvZGl2PjwvZGl2PlxcblwiICtcbiAgICBcIlwiKTtcbn1dKTtcblxuYW5ndWxhci5tb2R1bGUoXCJ1aWIvdGVtcGxhdGUvcGFnZXIvcGFnZXIuaHRtbFwiLCBbXSkucnVuKFtcIiR0ZW1wbGF0ZUNhY2hlXCIsIGZ1bmN0aW9uICgkdGVtcGxhdGVDYWNoZSkge1xuICAkdGVtcGxhdGVDYWNoZS5wdXQoXCJ1aWIvdGVtcGxhdGUvcGFnZXIvcGFnZXIuaHRtbFwiLFxuICAgIFwiPGxpIG5nLWNsYXNzPVxcXCJ7ZGlzYWJsZWQ6IG5vUHJldmlvdXMoKXx8bmdEaXNhYmxlZCwgcHJldmlvdXM6IGFsaWdufVxcXCI+PGEgaHJlZiBuZy1jbGljaz1cXFwic2VsZWN0UGFnZShwYWdlIC0gMSwgJGV2ZW50KVxcXCIgbmctZGlzYWJsZWQ9XFxcIm5vUHJldmlvdXMoKXx8bmdEaXNhYmxlZFxcXCIgdWliLXRhYmluZGV4LXRvZ2dsZT57ezo6Z2V0VGV4dCgncHJldmlvdXMnKX19PC9hPjwvbGk+XFxuXCIgK1xuICAgIFwiPGxpIG5nLWNsYXNzPVxcXCJ7ZGlzYWJsZWQ6IG5vTmV4dCgpfHxuZ0Rpc2FibGVkLCBuZXh0OiBhbGlnbn1cXFwiPjxhIGhyZWYgbmctY2xpY2s9XFxcInNlbGVjdFBhZ2UocGFnZSArIDEsICRldmVudClcXFwiIG5nLWRpc2FibGVkPVxcXCJub05leHQoKXx8bmdEaXNhYmxlZFxcXCIgdWliLXRhYmluZGV4LXRvZ2dsZT57ezo6Z2V0VGV4dCgnbmV4dCcpfX08L2E+PC9saT5cXG5cIiArXG4gICAgXCJcIik7XG59XSk7XG5cbmFuZ3VsYXIubW9kdWxlKFwidWliL3RlbXBsYXRlL3BhZ2luYXRpb24vcGFnaW5hdGlvbi5odG1sXCIsIFtdKS5ydW4oW1wiJHRlbXBsYXRlQ2FjaGVcIiwgZnVuY3Rpb24gKCR0ZW1wbGF0ZUNhY2hlKSB7XG4gICR0ZW1wbGF0ZUNhY2hlLnB1dChcInVpYi90ZW1wbGF0ZS9wYWdpbmF0aW9uL3BhZ2luYXRpb24uaHRtbFwiLFxuICAgIFwiPGxpIHJvbGU9XFxcIm1lbnVpdGVtXFxcIiBuZy1pZj1cXFwiOjpib3VuZGFyeUxpbmtzXFxcIiBuZy1jbGFzcz1cXFwie2Rpc2FibGVkOiBub1ByZXZpb3VzKCl8fG5nRGlzYWJsZWR9XFxcIiBjbGFzcz1cXFwicGFnaW5hdGlvbi1maXJzdFxcXCI+PGEgaHJlZiBuZy1jbGljaz1cXFwic2VsZWN0UGFnZSgxLCAkZXZlbnQpXFxcIiBuZy1kaXNhYmxlZD1cXFwibm9QcmV2aW91cygpfHxuZ0Rpc2FibGVkXFxcIiB1aWItdGFiaW5kZXgtdG9nZ2xlPnt7OjpnZXRUZXh0KCdmaXJzdCcpfX08L2E+PC9saT5cXG5cIiArXG4gICAgXCI8bGkgcm9sZT1cXFwibWVudWl0ZW1cXFwiIG5nLWlmPVxcXCI6OmRpcmVjdGlvbkxpbmtzXFxcIiBuZy1jbGFzcz1cXFwie2Rpc2FibGVkOiBub1ByZXZpb3VzKCl8fG5nRGlzYWJsZWR9XFxcIiBjbGFzcz1cXFwicGFnaW5hdGlvbi1wcmV2XFxcIj48YSBocmVmIG5nLWNsaWNrPVxcXCJzZWxlY3RQYWdlKHBhZ2UgLSAxLCAkZXZlbnQpXFxcIiBuZy1kaXNhYmxlZD1cXFwibm9QcmV2aW91cygpfHxuZ0Rpc2FibGVkXFxcIiB1aWItdGFiaW5kZXgtdG9nZ2xlPnt7OjpnZXRUZXh0KCdwcmV2aW91cycpfX08L2E+PC9saT5cXG5cIiArXG4gICAgXCI8bGkgcm9sZT1cXFwibWVudWl0ZW1cXFwiIG5nLXJlcGVhdD1cXFwicGFnZSBpbiBwYWdlcyB0cmFjayBieSAkaW5kZXhcXFwiIG5nLWNsYXNzPVxcXCJ7YWN0aXZlOiBwYWdlLmFjdGl2ZSxkaXNhYmxlZDogbmdEaXNhYmxlZCYmIXBhZ2UuYWN0aXZlfVxcXCIgY2xhc3M9XFxcInBhZ2luYXRpb24tcGFnZVxcXCI+PGEgaHJlZiBuZy1jbGljaz1cXFwic2VsZWN0UGFnZShwYWdlLm51bWJlciwgJGV2ZW50KVxcXCIgbmctZGlzYWJsZWQ9XFxcIm5nRGlzYWJsZWQmJiFwYWdlLmFjdGl2ZVxcXCIgdWliLXRhYmluZGV4LXRvZ2dsZT57e3BhZ2UudGV4dH19PC9hPjwvbGk+XFxuXCIgK1xuICAgIFwiPGxpIHJvbGU9XFxcIm1lbnVpdGVtXFxcIiBuZy1pZj1cXFwiOjpkaXJlY3Rpb25MaW5rc1xcXCIgbmctY2xhc3M9XFxcIntkaXNhYmxlZDogbm9OZXh0KCl8fG5nRGlzYWJsZWR9XFxcIiBjbGFzcz1cXFwicGFnaW5hdGlvbi1uZXh0XFxcIj48YSBocmVmIG5nLWNsaWNrPVxcXCJzZWxlY3RQYWdlKHBhZ2UgKyAxLCAkZXZlbnQpXFxcIiBuZy1kaXNhYmxlZD1cXFwibm9OZXh0KCl8fG5nRGlzYWJsZWRcXFwiIHVpYi10YWJpbmRleC10b2dnbGU+e3s6OmdldFRleHQoJ25leHQnKX19PC9hPjwvbGk+XFxuXCIgK1xuICAgIFwiPGxpIHJvbGU9XFxcIm1lbnVpdGVtXFxcIiBuZy1pZj1cXFwiOjpib3VuZGFyeUxpbmtzXFxcIiBuZy1jbGFzcz1cXFwie2Rpc2FibGVkOiBub05leHQoKXx8bmdEaXNhYmxlZH1cXFwiIGNsYXNzPVxcXCJwYWdpbmF0aW9uLWxhc3RcXFwiPjxhIGhyZWYgbmctY2xpY2s9XFxcInNlbGVjdFBhZ2UodG90YWxQYWdlcywgJGV2ZW50KVxcXCIgbmctZGlzYWJsZWQ9XFxcIm5vTmV4dCgpfHxuZ0Rpc2FibGVkXFxcIiB1aWItdGFiaW5kZXgtdG9nZ2xlPnt7OjpnZXRUZXh0KCdsYXN0Jyl9fTwvYT48L2xpPlxcblwiICtcbiAgICBcIlwiKTtcbn1dKTtcblxuYW5ndWxhci5tb2R1bGUoXCJ1aWIvdGVtcGxhdGUvdG9vbHRpcC90b29sdGlwLWh0bWwtcG9wdXAuaHRtbFwiLCBbXSkucnVuKFtcIiR0ZW1wbGF0ZUNhY2hlXCIsIGZ1bmN0aW9uICgkdGVtcGxhdGVDYWNoZSkge1xuICAkdGVtcGxhdGVDYWNoZS5wdXQoXCJ1aWIvdGVtcGxhdGUvdG9vbHRpcC90b29sdGlwLWh0bWwtcG9wdXAuaHRtbFwiLFxuICAgIFwiPGRpdiBjbGFzcz1cXFwidG9vbHRpcC1hcnJvd1xcXCI+PC9kaXY+XFxuXCIgK1xuICAgIFwiPGRpdiBjbGFzcz1cXFwidG9vbHRpcC1pbm5lclxcXCIgbmctYmluZC1odG1sPVxcXCJjb250ZW50RXhwKClcXFwiPjwvZGl2PlxcblwiICtcbiAgICBcIlwiKTtcbn1dKTtcblxuYW5ndWxhci5tb2R1bGUoXCJ1aWIvdGVtcGxhdGUvdG9vbHRpcC90b29sdGlwLXBvcHVwLmh0bWxcIiwgW10pLnJ1bihbXCIkdGVtcGxhdGVDYWNoZVwiLCBmdW5jdGlvbiAoJHRlbXBsYXRlQ2FjaGUpIHtcbiAgJHRlbXBsYXRlQ2FjaGUucHV0KFwidWliL3RlbXBsYXRlL3Rvb2x0aXAvdG9vbHRpcC1wb3B1cC5odG1sXCIsXG4gICAgXCI8ZGl2IGNsYXNzPVxcXCJ0b29sdGlwLWFycm93XFxcIj48L2Rpdj5cXG5cIiArXG4gICAgXCI8ZGl2IGNsYXNzPVxcXCJ0b29sdGlwLWlubmVyXFxcIiBuZy1iaW5kPVxcXCJjb250ZW50XFxcIj48L2Rpdj5cXG5cIiArXG4gICAgXCJcIik7XG59XSk7XG5cbmFuZ3VsYXIubW9kdWxlKFwidWliL3RlbXBsYXRlL3Rvb2x0aXAvdG9vbHRpcC10ZW1wbGF0ZS1wb3B1cC5odG1sXCIsIFtdKS5ydW4oW1wiJHRlbXBsYXRlQ2FjaGVcIiwgZnVuY3Rpb24gKCR0ZW1wbGF0ZUNhY2hlKSB7XG4gICR0ZW1wbGF0ZUNhY2hlLnB1dChcInVpYi90ZW1wbGF0ZS90b29sdGlwL3Rvb2x0aXAtdGVtcGxhdGUtcG9wdXAuaHRtbFwiLFxuICAgIFwiPGRpdiBjbGFzcz1cXFwidG9vbHRpcC1hcnJvd1xcXCI+PC9kaXY+XFxuXCIgK1xuICAgIFwiPGRpdiBjbGFzcz1cXFwidG9vbHRpcC1pbm5lclxcXCJcXG5cIiArXG4gICAgXCIgIHVpYi10b29sdGlwLXRlbXBsYXRlLXRyYW5zY2x1ZGU9XFxcImNvbnRlbnRFeHAoKVxcXCJcXG5cIiArXG4gICAgXCIgIHRvb2x0aXAtdGVtcGxhdGUtdHJhbnNjbHVkZS1zY29wZT1cXFwib3JpZ2luU2NvcGUoKVxcXCI+PC9kaXY+XFxuXCIgK1xuICAgIFwiXCIpO1xufV0pO1xuXG5hbmd1bGFyLm1vZHVsZShcInVpYi90ZW1wbGF0ZS9wb3BvdmVyL3BvcG92ZXItaHRtbC5odG1sXCIsIFtdKS5ydW4oW1wiJHRlbXBsYXRlQ2FjaGVcIiwgZnVuY3Rpb24gKCR0ZW1wbGF0ZUNhY2hlKSB7XG4gICR0ZW1wbGF0ZUNhY2hlLnB1dChcInVpYi90ZW1wbGF0ZS9wb3BvdmVyL3BvcG92ZXItaHRtbC5odG1sXCIsXG4gICAgXCI8ZGl2IGNsYXNzPVxcXCJhcnJvd1xcXCI+PC9kaXY+XFxuXCIgK1xuICAgIFwiXFxuXCIgK1xuICAgIFwiPGRpdiBjbGFzcz1cXFwicG9wb3Zlci1pbm5lclxcXCI+XFxuXCIgK1xuICAgIFwiICAgIDxoMyBjbGFzcz1cXFwicG9wb3Zlci10aXRsZVxcXCIgbmctYmluZD1cXFwidWliVGl0bGVcXFwiIG5nLWlmPVxcXCJ1aWJUaXRsZVxcXCI+PC9oMz5cXG5cIiArXG4gICAgXCIgICAgPGRpdiBjbGFzcz1cXFwicG9wb3Zlci1jb250ZW50XFxcIiBuZy1iaW5kLWh0bWw9XFxcImNvbnRlbnRFeHAoKVxcXCI+PC9kaXY+XFxuXCIgK1xuICAgIFwiPC9kaXY+XFxuXCIgK1xuICAgIFwiXCIpO1xufV0pO1xuXG5hbmd1bGFyLm1vZHVsZShcInVpYi90ZW1wbGF0ZS9wb3BvdmVyL3BvcG92ZXItdGVtcGxhdGUuaHRtbFwiLCBbXSkucnVuKFtcIiR0ZW1wbGF0ZUNhY2hlXCIsIGZ1bmN0aW9uICgkdGVtcGxhdGVDYWNoZSkge1xuICAkdGVtcGxhdGVDYWNoZS5wdXQoXCJ1aWIvdGVtcGxhdGUvcG9wb3Zlci9wb3BvdmVyLXRlbXBsYXRlLmh0bWxcIixcbiAgICBcIjxkaXYgY2xhc3M9XFxcImFycm93XFxcIj48L2Rpdj5cXG5cIiArXG4gICAgXCJcXG5cIiArXG4gICAgXCI8ZGl2IGNsYXNzPVxcXCJwb3BvdmVyLWlubmVyXFxcIj5cXG5cIiArXG4gICAgXCIgICAgPGgzIGNsYXNzPVxcXCJwb3BvdmVyLXRpdGxlXFxcIiBuZy1iaW5kPVxcXCJ1aWJUaXRsZVxcXCIgbmctaWY9XFxcInVpYlRpdGxlXFxcIj48L2gzPlxcblwiICtcbiAgICBcIiAgICA8ZGl2IGNsYXNzPVxcXCJwb3BvdmVyLWNvbnRlbnRcXFwiXFxuXCIgK1xuICAgIFwiICAgICAgdWliLXRvb2x0aXAtdGVtcGxhdGUtdHJhbnNjbHVkZT1cXFwiY29udGVudEV4cCgpXFxcIlxcblwiICtcbiAgICBcIiAgICAgIHRvb2x0aXAtdGVtcGxhdGUtdHJhbnNjbHVkZS1zY29wZT1cXFwib3JpZ2luU2NvcGUoKVxcXCI+PC9kaXY+XFxuXCIgK1xuICAgIFwiPC9kaXY+XFxuXCIgK1xuICAgIFwiXCIpO1xufV0pO1xuXG5hbmd1bGFyLm1vZHVsZShcInVpYi90ZW1wbGF0ZS9wb3BvdmVyL3BvcG92ZXIuaHRtbFwiLCBbXSkucnVuKFtcIiR0ZW1wbGF0ZUNhY2hlXCIsIGZ1bmN0aW9uICgkdGVtcGxhdGVDYWNoZSkge1xuICAkdGVtcGxhdGVDYWNoZS5wdXQoXCJ1aWIvdGVtcGxhdGUvcG9wb3Zlci9wb3BvdmVyLmh0bWxcIixcbiAgICBcIjxkaXYgY2xhc3M9XFxcImFycm93XFxcIj48L2Rpdj5cXG5cIiArXG4gICAgXCJcXG5cIiArXG4gICAgXCI8ZGl2IGNsYXNzPVxcXCJwb3BvdmVyLWlubmVyXFxcIj5cXG5cIiArXG4gICAgXCIgICAgPGgzIGNsYXNzPVxcXCJwb3BvdmVyLXRpdGxlXFxcIiBuZy1iaW5kPVxcXCJ1aWJUaXRsZVxcXCIgbmctaWY9XFxcInVpYlRpdGxlXFxcIj48L2gzPlxcblwiICtcbiAgICBcIiAgICA8ZGl2IGNsYXNzPVxcXCJwb3BvdmVyLWNvbnRlbnRcXFwiIG5nLWJpbmQ9XFxcImNvbnRlbnRcXFwiPjwvZGl2PlxcblwiICtcbiAgICBcIjwvZGl2PlxcblwiICtcbiAgICBcIlwiKTtcbn1dKTtcblxuYW5ndWxhci5tb2R1bGUoXCJ1aWIvdGVtcGxhdGUvcHJvZ3Jlc3NiYXIvYmFyLmh0bWxcIiwgW10pLnJ1bihbXCIkdGVtcGxhdGVDYWNoZVwiLCBmdW5jdGlvbiAoJHRlbXBsYXRlQ2FjaGUpIHtcbiAgJHRlbXBsYXRlQ2FjaGUucHV0KFwidWliL3RlbXBsYXRlL3Byb2dyZXNzYmFyL2Jhci5odG1sXCIsXG4gICAgXCI8ZGl2IGNsYXNzPVxcXCJwcm9ncmVzcy1iYXJcXFwiIG5nLWNsYXNzPVxcXCJ0eXBlICYmICdwcm9ncmVzcy1iYXItJyArIHR5cGVcXFwiIHJvbGU9XFxcInByb2dyZXNzYmFyXFxcIiBhcmlhLXZhbHVlbm93PVxcXCJ7e3ZhbHVlfX1cXFwiIGFyaWEtdmFsdWVtaW49XFxcIjBcXFwiIGFyaWEtdmFsdWVtYXg9XFxcInt7bWF4fX1cXFwiIG5nLXN0eWxlPVxcXCJ7d2lkdGg6IChwZXJjZW50IDwgMTAwID8gcGVyY2VudCA6IDEwMCkgKyAnJSd9XFxcIiBhcmlhLXZhbHVldGV4dD1cXFwie3twZXJjZW50IHwgbnVtYmVyOjB9fSVcXFwiIGFyaWEtbGFiZWxsZWRieT1cXFwie3s6OnRpdGxlfX1cXFwiIG5nLXRyYW5zY2x1ZGU+PC9kaXY+XFxuXCIgK1xuICAgIFwiXCIpO1xufV0pO1xuXG5hbmd1bGFyLm1vZHVsZShcInVpYi90ZW1wbGF0ZS9wcm9ncmVzc2Jhci9wcm9ncmVzcy5odG1sXCIsIFtdKS5ydW4oW1wiJHRlbXBsYXRlQ2FjaGVcIiwgZnVuY3Rpb24gKCR0ZW1wbGF0ZUNhY2hlKSB7XG4gICR0ZW1wbGF0ZUNhY2hlLnB1dChcInVpYi90ZW1wbGF0ZS9wcm9ncmVzc2Jhci9wcm9ncmVzcy5odG1sXCIsXG4gICAgXCI8ZGl2IGNsYXNzPVxcXCJwcm9ncmVzc1xcXCIgbmctdHJhbnNjbHVkZSBhcmlhLWxhYmVsbGVkYnk9XFxcInt7Ojp0aXRsZX19XFxcIj48L2Rpdj5cIik7XG59XSk7XG5cbmFuZ3VsYXIubW9kdWxlKFwidWliL3RlbXBsYXRlL3Byb2dyZXNzYmFyL3Byb2dyZXNzYmFyLmh0bWxcIiwgW10pLnJ1bihbXCIkdGVtcGxhdGVDYWNoZVwiLCBmdW5jdGlvbiAoJHRlbXBsYXRlQ2FjaGUpIHtcbiAgJHRlbXBsYXRlQ2FjaGUucHV0KFwidWliL3RlbXBsYXRlL3Byb2dyZXNzYmFyL3Byb2dyZXNzYmFyLmh0bWxcIixcbiAgICBcIjxkaXYgY2xhc3M9XFxcInByb2dyZXNzXFxcIj5cXG5cIiArXG4gICAgXCIgIDxkaXYgY2xhc3M9XFxcInByb2dyZXNzLWJhclxcXCIgbmctY2xhc3M9XFxcInR5cGUgJiYgJ3Byb2dyZXNzLWJhci0nICsgdHlwZVxcXCIgcm9sZT1cXFwicHJvZ3Jlc3NiYXJcXFwiIGFyaWEtdmFsdWVub3c9XFxcInt7dmFsdWV9fVxcXCIgYXJpYS12YWx1ZW1pbj1cXFwiMFxcXCIgYXJpYS12YWx1ZW1heD1cXFwie3ttYXh9fVxcXCIgbmctc3R5bGU9XFxcInt3aWR0aDogKHBlcmNlbnQgPCAxMDAgPyBwZXJjZW50IDogMTAwKSArICclJ31cXFwiIGFyaWEtdmFsdWV0ZXh0PVxcXCJ7e3BlcmNlbnQgfCBudW1iZXI6MH19JVxcXCIgYXJpYS1sYWJlbGxlZGJ5PVxcXCJ7ezo6dGl0bGV9fVxcXCIgbmctdHJhbnNjbHVkZT48L2Rpdj5cXG5cIiArXG4gICAgXCI8L2Rpdj5cXG5cIiArXG4gICAgXCJcIik7XG59XSk7XG5cbmFuZ3VsYXIubW9kdWxlKFwidWliL3RlbXBsYXRlL3JhdGluZy9yYXRpbmcuaHRtbFwiLCBbXSkucnVuKFtcIiR0ZW1wbGF0ZUNhY2hlXCIsIGZ1bmN0aW9uICgkdGVtcGxhdGVDYWNoZSkge1xuICAkdGVtcGxhdGVDYWNoZS5wdXQoXCJ1aWIvdGVtcGxhdGUvcmF0aW5nL3JhdGluZy5odG1sXCIsXG4gICAgXCI8c3BhbiBuZy1tb3VzZWxlYXZlPVxcXCJyZXNldCgpXFxcIiBuZy1rZXlkb3duPVxcXCJvbktleWRvd24oJGV2ZW50KVxcXCIgdGFiaW5kZXg9XFxcIjBcXFwiIHJvbGU9XFxcInNsaWRlclxcXCIgYXJpYS12YWx1ZW1pbj1cXFwiMFxcXCIgYXJpYS12YWx1ZW1heD1cXFwie3tyYW5nZS5sZW5ndGh9fVxcXCIgYXJpYS12YWx1ZW5vdz1cXFwie3t2YWx1ZX19XFxcIiBhcmlhLXZhbHVldGV4dD1cXFwie3t0aXRsZX19XFxcIj5cXG5cIiArXG4gICAgXCIgICAgPHNwYW4gbmctcmVwZWF0LXN0YXJ0PVxcXCJyIGluIHJhbmdlIHRyYWNrIGJ5ICRpbmRleFxcXCIgY2xhc3M9XFxcInNyLW9ubHlcXFwiPih7eyAkaW5kZXggPCB2YWx1ZSA/ICcqJyA6ICcgJyB9fSk8L3NwYW4+XFxuXCIgK1xuICAgIFwiICAgIDxpIG5nLXJlcGVhdC1lbmQgbmctbW91c2VlbnRlcj1cXFwiZW50ZXIoJGluZGV4ICsgMSlcXFwiIG5nLWNsaWNrPVxcXCJyYXRlKCRpbmRleCArIDEpXFxcIiBjbGFzcz1cXFwiZ2x5cGhpY29uXFxcIiBuZy1jbGFzcz1cXFwiJGluZGV4IDwgdmFsdWUgJiYgKHIuc3RhdGVPbiB8fCAnZ2x5cGhpY29uLXN0YXInKSB8fCAoci5zdGF0ZU9mZiB8fCAnZ2x5cGhpY29uLXN0YXItZW1wdHknKVxcXCIgbmctYXR0ci10aXRsZT1cXFwie3tyLnRpdGxlfX1cXFwiPjwvaT5cXG5cIiArXG4gICAgXCI8L3NwYW4+XFxuXCIgK1xuICAgIFwiXCIpO1xufV0pO1xuXG5hbmd1bGFyLm1vZHVsZShcInVpYi90ZW1wbGF0ZS90YWJzL3RhYi5odG1sXCIsIFtdKS5ydW4oW1wiJHRlbXBsYXRlQ2FjaGVcIiwgZnVuY3Rpb24gKCR0ZW1wbGF0ZUNhY2hlKSB7XG4gICR0ZW1wbGF0ZUNhY2hlLnB1dChcInVpYi90ZW1wbGF0ZS90YWJzL3RhYi5odG1sXCIsXG4gICAgXCI8bGkgbmctY2xhc3M9XFxcIlt7YWN0aXZlOiBhY3RpdmUsIGRpc2FibGVkOiBkaXNhYmxlZH0sIGNsYXNzZXNdXFxcIiBjbGFzcz1cXFwidWliLXRhYiBuYXYtaXRlbVxcXCI+XFxuXCIgK1xuICAgIFwiICA8YSBocmVmIG5nLWNsaWNrPVxcXCJzZWxlY3QoJGV2ZW50KVxcXCIgY2xhc3M9XFxcIm5hdi1saW5rXFxcIiB1aWItdGFiLWhlYWRpbmctdHJhbnNjbHVkZT57e2hlYWRpbmd9fTwvYT5cXG5cIiArXG4gICAgXCI8L2xpPlxcblwiICtcbiAgICBcIlwiKTtcbn1dKTtcblxuYW5ndWxhci5tb2R1bGUoXCJ1aWIvdGVtcGxhdGUvdGFicy90YWJzZXQuaHRtbFwiLCBbXSkucnVuKFtcIiR0ZW1wbGF0ZUNhY2hlXCIsIGZ1bmN0aW9uICgkdGVtcGxhdGVDYWNoZSkge1xuICAkdGVtcGxhdGVDYWNoZS5wdXQoXCJ1aWIvdGVtcGxhdGUvdGFicy90YWJzZXQuaHRtbFwiLFxuICAgIFwiPGRpdj5cXG5cIiArXG4gICAgXCIgIDx1bCBjbGFzcz1cXFwibmF2IG5hdi17e3RhYnNldC50eXBlIHx8ICd0YWJzJ319XFxcIiBuZy1jbGFzcz1cXFwieyduYXYtc3RhY2tlZCc6IHZlcnRpY2FsLCAnbmF2LWp1c3RpZmllZCc6IGp1c3RpZmllZH1cXFwiIG5nLXRyYW5zY2x1ZGU+PC91bD5cXG5cIiArXG4gICAgXCIgIDxkaXYgY2xhc3M9XFxcInRhYi1jb250ZW50XFxcIj5cXG5cIiArXG4gICAgXCIgICAgPGRpdiBjbGFzcz1cXFwidGFiLXBhbmVcXFwiXFxuXCIgK1xuICAgIFwiICAgICAgICAgbmctcmVwZWF0PVxcXCJ0YWIgaW4gdGFic2V0LnRhYnNcXFwiXFxuXCIgK1xuICAgIFwiICAgICAgICAgbmctY2xhc3M9XFxcInthY3RpdmU6IHRhYnNldC5hY3RpdmUgPT09IHRhYi5pbmRleH1cXFwiXFxuXCIgK1xuICAgIFwiICAgICAgICAgdWliLXRhYi1jb250ZW50LXRyYW5zY2x1ZGU9XFxcInRhYlxcXCI+XFxuXCIgK1xuICAgIFwiICAgIDwvZGl2PlxcblwiICtcbiAgICBcIiAgPC9kaXY+XFxuXCIgK1xuICAgIFwiPC9kaXY+XFxuXCIgK1xuICAgIFwiXCIpO1xufV0pO1xuXG5hbmd1bGFyLm1vZHVsZShcInVpYi90ZW1wbGF0ZS90aW1lcGlja2VyL3RpbWVwaWNrZXIuaHRtbFwiLCBbXSkucnVuKFtcIiR0ZW1wbGF0ZUNhY2hlXCIsIGZ1bmN0aW9uICgkdGVtcGxhdGVDYWNoZSkge1xuICAkdGVtcGxhdGVDYWNoZS5wdXQoXCJ1aWIvdGVtcGxhdGUvdGltZXBpY2tlci90aW1lcGlja2VyLmh0bWxcIixcbiAgICBcIjx0YWJsZSBjbGFzcz1cXFwidWliLXRpbWVwaWNrZXJcXFwiPlxcblwiICtcbiAgICBcIiAgPHRib2R5PlxcblwiICtcbiAgICBcIiAgICA8dHIgY2xhc3M9XFxcInRleHQtY2VudGVyXFxcIiBuZy1zaG93PVxcXCI6OnNob3dTcGlubmVyc1xcXCI+XFxuXCIgK1xuICAgIFwiICAgICAgPHRkIGNsYXNzPVxcXCJ1aWItaW5jcmVtZW50IGhvdXJzXFxcIj48YSBuZy1jbGljaz1cXFwiaW5jcmVtZW50SG91cnMoKVxcXCIgbmctY2xhc3M9XFxcIntkaXNhYmxlZDogbm9JbmNyZW1lbnRIb3VycygpfVxcXCIgY2xhc3M9XFxcImJ0biBidG4tbGlua1xcXCIgbmctZGlzYWJsZWQ9XFxcIm5vSW5jcmVtZW50SG91cnMoKVxcXCIgdGFiaW5kZXg9XFxcIi0xXFxcIj48c3BhbiBjbGFzcz1cXFwiZ2x5cGhpY29uIGdseXBoaWNvbi1jaGV2cm9uLXVwXFxcIj48L3NwYW4+PC9hPjwvdGQ+XFxuXCIgK1xuICAgIFwiICAgICAgPHRkPiZuYnNwOzwvdGQ+XFxuXCIgK1xuICAgIFwiICAgICAgPHRkIGNsYXNzPVxcXCJ1aWItaW5jcmVtZW50IG1pbnV0ZXNcXFwiPjxhIG5nLWNsaWNrPVxcXCJpbmNyZW1lbnRNaW51dGVzKClcXFwiIG5nLWNsYXNzPVxcXCJ7ZGlzYWJsZWQ6IG5vSW5jcmVtZW50TWludXRlcygpfVxcXCIgY2xhc3M9XFxcImJ0biBidG4tbGlua1xcXCIgbmctZGlzYWJsZWQ9XFxcIm5vSW5jcmVtZW50TWludXRlcygpXFxcIiB0YWJpbmRleD1cXFwiLTFcXFwiPjxzcGFuIGNsYXNzPVxcXCJnbHlwaGljb24gZ2x5cGhpY29uLWNoZXZyb24tdXBcXFwiPjwvc3Bhbj48L2E+PC90ZD5cXG5cIiArXG4gICAgXCIgICAgICA8dGQgbmctc2hvdz1cXFwic2hvd1NlY29uZHNcXFwiPiZuYnNwOzwvdGQ+XFxuXCIgK1xuICAgIFwiICAgICAgPHRkIG5nLXNob3c9XFxcInNob3dTZWNvbmRzXFxcIiBjbGFzcz1cXFwidWliLWluY3JlbWVudCBzZWNvbmRzXFxcIj48YSBuZy1jbGljaz1cXFwiaW5jcmVtZW50U2Vjb25kcygpXFxcIiBuZy1jbGFzcz1cXFwie2Rpc2FibGVkOiBub0luY3JlbWVudFNlY29uZHMoKX1cXFwiIGNsYXNzPVxcXCJidG4gYnRuLWxpbmtcXFwiIG5nLWRpc2FibGVkPVxcXCJub0luY3JlbWVudFNlY29uZHMoKVxcXCIgdGFiaW5kZXg9XFxcIi0xXFxcIj48c3BhbiBjbGFzcz1cXFwiZ2x5cGhpY29uIGdseXBoaWNvbi1jaGV2cm9uLXVwXFxcIj48L3NwYW4+PC9hPjwvdGQ+XFxuXCIgK1xuICAgIFwiICAgICAgPHRkIG5nLXNob3c9XFxcInNob3dNZXJpZGlhblxcXCI+PC90ZD5cXG5cIiArXG4gICAgXCIgICAgPC90cj5cXG5cIiArXG4gICAgXCIgICAgPHRyPlxcblwiICtcbiAgICBcIiAgICAgIDx0ZCBjbGFzcz1cXFwiZm9ybS1ncm91cCB1aWItdGltZSBob3Vyc1xcXCIgbmctY2xhc3M9XFxcInsnaGFzLWVycm9yJzogaW52YWxpZEhvdXJzfVxcXCI+XFxuXCIgK1xuICAgIFwiICAgICAgICA8aW5wdXQgdHlwZT1cXFwidGV4dFxcXCIgcGxhY2Vob2xkZXI9XFxcIkhIXFxcIiBuZy1tb2RlbD1cXFwiaG91cnNcXFwiIG5nLWNoYW5nZT1cXFwidXBkYXRlSG91cnMoKVxcXCIgY2xhc3M9XFxcImZvcm0tY29udHJvbCB0ZXh0LWNlbnRlclxcXCIgbmctcmVhZG9ubHk9XFxcIjo6cmVhZG9ubHlJbnB1dFxcXCIgbWF4bGVuZ3RoPVxcXCIyXFxcIiB0YWJpbmRleD1cXFwie3s6OnRhYmluZGV4fX1cXFwiIG5nLWRpc2FibGVkPVxcXCJub0luY3JlbWVudEhvdXJzKClcXFwiIG5nLWJsdXI9XFxcImJsdXIoKVxcXCI+XFxuXCIgK1xuICAgIFwiICAgICAgPC90ZD5cXG5cIiArXG4gICAgXCIgICAgICA8dGQgY2xhc3M9XFxcInVpYi1zZXBhcmF0b3JcXFwiPjo8L3RkPlxcblwiICtcbiAgICBcIiAgICAgIDx0ZCBjbGFzcz1cXFwiZm9ybS1ncm91cCB1aWItdGltZSBtaW51dGVzXFxcIiBuZy1jbGFzcz1cXFwieydoYXMtZXJyb3InOiBpbnZhbGlkTWludXRlc31cXFwiPlxcblwiICtcbiAgICBcIiAgICAgICAgPGlucHV0IHR5cGU9XFxcInRleHRcXFwiIHBsYWNlaG9sZGVyPVxcXCJNTVxcXCIgbmctbW9kZWw9XFxcIm1pbnV0ZXNcXFwiIG5nLWNoYW5nZT1cXFwidXBkYXRlTWludXRlcygpXFxcIiBjbGFzcz1cXFwiZm9ybS1jb250cm9sIHRleHQtY2VudGVyXFxcIiBuZy1yZWFkb25seT1cXFwiOjpyZWFkb25seUlucHV0XFxcIiBtYXhsZW5ndGg9XFxcIjJcXFwiIHRhYmluZGV4PVxcXCJ7ezo6dGFiaW5kZXh9fVxcXCIgbmctZGlzYWJsZWQ9XFxcIm5vSW5jcmVtZW50TWludXRlcygpXFxcIiBuZy1ibHVyPVxcXCJibHVyKClcXFwiPlxcblwiICtcbiAgICBcIiAgICAgIDwvdGQ+XFxuXCIgK1xuICAgIFwiICAgICAgPHRkIG5nLXNob3c9XFxcInNob3dTZWNvbmRzXFxcIiBjbGFzcz1cXFwidWliLXNlcGFyYXRvclxcXCI+OjwvdGQ+XFxuXCIgK1xuICAgIFwiICAgICAgPHRkIGNsYXNzPVxcXCJmb3JtLWdyb3VwIHVpYi10aW1lIHNlY29uZHNcXFwiIG5nLWNsYXNzPVxcXCJ7J2hhcy1lcnJvcic6IGludmFsaWRTZWNvbmRzfVxcXCIgbmctc2hvdz1cXFwic2hvd1NlY29uZHNcXFwiPlxcblwiICtcbiAgICBcIiAgICAgICAgPGlucHV0IHR5cGU9XFxcInRleHRcXFwiIHBsYWNlaG9sZGVyPVxcXCJTU1xcXCIgbmctbW9kZWw9XFxcInNlY29uZHNcXFwiIG5nLWNoYW5nZT1cXFwidXBkYXRlU2Vjb25kcygpXFxcIiBjbGFzcz1cXFwiZm9ybS1jb250cm9sIHRleHQtY2VudGVyXFxcIiBuZy1yZWFkb25seT1cXFwicmVhZG9ubHlJbnB1dFxcXCIgbWF4bGVuZ3RoPVxcXCIyXFxcIiB0YWJpbmRleD1cXFwie3s6OnRhYmluZGV4fX1cXFwiIG5nLWRpc2FibGVkPVxcXCJub0luY3JlbWVudFNlY29uZHMoKVxcXCIgbmctYmx1cj1cXFwiYmx1cigpXFxcIj5cXG5cIiArXG4gICAgXCIgICAgICA8L3RkPlxcblwiICtcbiAgICBcIiAgICAgIDx0ZCBuZy1zaG93PVxcXCJzaG93TWVyaWRpYW5cXFwiIGNsYXNzPVxcXCJ1aWItdGltZSBhbS1wbVxcXCI+PGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIG5nLWNsYXNzPVxcXCJ7ZGlzYWJsZWQ6IG5vVG9nZ2xlTWVyaWRpYW4oKX1cXFwiIGNsYXNzPVxcXCJidG4gYnRuLWRlZmF1bHQgdGV4dC1jZW50ZXJcXFwiIG5nLWNsaWNrPVxcXCJ0b2dnbGVNZXJpZGlhbigpXFxcIiBuZy1kaXNhYmxlZD1cXFwibm9Ub2dnbGVNZXJpZGlhbigpXFxcIiB0YWJpbmRleD1cXFwie3s6OnRhYmluZGV4fX1cXFwiPnt7bWVyaWRpYW59fTwvYnV0dG9uPjwvdGQ+XFxuXCIgK1xuICAgIFwiICAgIDwvdHI+XFxuXCIgK1xuICAgIFwiICAgIDx0ciBjbGFzcz1cXFwidGV4dC1jZW50ZXJcXFwiIG5nLXNob3c9XFxcIjo6c2hvd1NwaW5uZXJzXFxcIj5cXG5cIiArXG4gICAgXCIgICAgICA8dGQgY2xhc3M9XFxcInVpYi1kZWNyZW1lbnQgaG91cnNcXFwiPjxhIG5nLWNsaWNrPVxcXCJkZWNyZW1lbnRIb3VycygpXFxcIiBuZy1jbGFzcz1cXFwie2Rpc2FibGVkOiBub0RlY3JlbWVudEhvdXJzKCl9XFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1saW5rXFxcIiBuZy1kaXNhYmxlZD1cXFwibm9EZWNyZW1lbnRIb3VycygpXFxcIiB0YWJpbmRleD1cXFwiLTFcXFwiPjxzcGFuIGNsYXNzPVxcXCJnbHlwaGljb24gZ2x5cGhpY29uLWNoZXZyb24tZG93blxcXCI+PC9zcGFuPjwvYT48L3RkPlxcblwiICtcbiAgICBcIiAgICAgIDx0ZD4mbmJzcDs8L3RkPlxcblwiICtcbiAgICBcIiAgICAgIDx0ZCBjbGFzcz1cXFwidWliLWRlY3JlbWVudCBtaW51dGVzXFxcIj48YSBuZy1jbGljaz1cXFwiZGVjcmVtZW50TWludXRlcygpXFxcIiBuZy1jbGFzcz1cXFwie2Rpc2FibGVkOiBub0RlY3JlbWVudE1pbnV0ZXMoKX1cXFwiIGNsYXNzPVxcXCJidG4gYnRuLWxpbmtcXFwiIG5nLWRpc2FibGVkPVxcXCJub0RlY3JlbWVudE1pbnV0ZXMoKVxcXCIgdGFiaW5kZXg9XFxcIi0xXFxcIj48c3BhbiBjbGFzcz1cXFwiZ2x5cGhpY29uIGdseXBoaWNvbi1jaGV2cm9uLWRvd25cXFwiPjwvc3Bhbj48L2E+PC90ZD5cXG5cIiArXG4gICAgXCIgICAgICA8dGQgbmctc2hvdz1cXFwic2hvd1NlY29uZHNcXFwiPiZuYnNwOzwvdGQ+XFxuXCIgK1xuICAgIFwiICAgICAgPHRkIG5nLXNob3c9XFxcInNob3dTZWNvbmRzXFxcIiBjbGFzcz1cXFwidWliLWRlY3JlbWVudCBzZWNvbmRzXFxcIj48YSBuZy1jbGljaz1cXFwiZGVjcmVtZW50U2Vjb25kcygpXFxcIiBuZy1jbGFzcz1cXFwie2Rpc2FibGVkOiBub0RlY3JlbWVudFNlY29uZHMoKX1cXFwiIGNsYXNzPVxcXCJidG4gYnRuLWxpbmtcXFwiIG5nLWRpc2FibGVkPVxcXCJub0RlY3JlbWVudFNlY29uZHMoKVxcXCIgdGFiaW5kZXg9XFxcIi0xXFxcIj48c3BhbiBjbGFzcz1cXFwiZ2x5cGhpY29uIGdseXBoaWNvbi1jaGV2cm9uLWRvd25cXFwiPjwvc3Bhbj48L2E+PC90ZD5cXG5cIiArXG4gICAgXCIgICAgICA8dGQgbmctc2hvdz1cXFwic2hvd01lcmlkaWFuXFxcIj48L3RkPlxcblwiICtcbiAgICBcIiAgICA8L3RyPlxcblwiICtcbiAgICBcIiAgPC90Ym9keT5cXG5cIiArXG4gICAgXCI8L3RhYmxlPlxcblwiICtcbiAgICBcIlwiKTtcbn1dKTtcblxuYW5ndWxhci5tb2R1bGUoXCJ1aWIvdGVtcGxhdGUvdHlwZWFoZWFkL3R5cGVhaGVhZC1tYXRjaC5odG1sXCIsIFtdKS5ydW4oW1wiJHRlbXBsYXRlQ2FjaGVcIiwgZnVuY3Rpb24gKCR0ZW1wbGF0ZUNhY2hlKSB7XG4gICR0ZW1wbGF0ZUNhY2hlLnB1dChcInVpYi90ZW1wbGF0ZS90eXBlYWhlYWQvdHlwZWFoZWFkLW1hdGNoLmh0bWxcIixcbiAgICBcIjxhIGhyZWZcXG5cIiArXG4gICAgXCIgICB0YWJpbmRleD1cXFwiLTFcXFwiXFxuXCIgK1xuICAgIFwiICAgbmctYmluZC1odG1sPVxcXCJtYXRjaC5sYWJlbCB8IHVpYlR5cGVhaGVhZEhpZ2hsaWdodDpxdWVyeVxcXCJcXG5cIiArXG4gICAgXCIgICBuZy1hdHRyLXRpdGxlPVxcXCJ7e21hdGNoLmxhYmVsfX1cXFwiPjwvYT5cXG5cIiArXG4gICAgXCJcIik7XG59XSk7XG5cbmFuZ3VsYXIubW9kdWxlKFwidWliL3RlbXBsYXRlL3R5cGVhaGVhZC90eXBlYWhlYWQtcG9wdXAuaHRtbFwiLCBbXSkucnVuKFtcIiR0ZW1wbGF0ZUNhY2hlXCIsIGZ1bmN0aW9uICgkdGVtcGxhdGVDYWNoZSkge1xuICAkdGVtcGxhdGVDYWNoZS5wdXQoXCJ1aWIvdGVtcGxhdGUvdHlwZWFoZWFkL3R5cGVhaGVhZC1wb3B1cC5odG1sXCIsXG4gICAgXCI8dWwgY2xhc3M9XFxcImRyb3Bkb3duLW1lbnVcXFwiIG5nLXNob3c9XFxcImlzT3BlbigpICYmICFtb3ZlSW5Qcm9ncmVzc1xcXCIgbmctc3R5bGU9XFxcInt0b3A6IHBvc2l0aW9uKCkudG9wKydweCcsIGxlZnQ6IHBvc2l0aW9uKCkubGVmdCsncHgnfVxcXCIgcm9sZT1cXFwibGlzdGJveFxcXCIgYXJpYS1oaWRkZW49XFxcInt7IWlzT3BlbigpfX1cXFwiPlxcblwiICtcbiAgICBcIiAgICA8bGkgY2xhc3M9XFxcInVpYi10eXBlYWhlYWQtbWF0Y2hcXFwiIG5nLXJlcGVhdD1cXFwibWF0Y2ggaW4gbWF0Y2hlcyB0cmFjayBieSAkaW5kZXhcXFwiIG5nLWNsYXNzPVxcXCJ7YWN0aXZlOiBpc0FjdGl2ZSgkaW5kZXgpIH1cXFwiIG5nLW1vdXNlZW50ZXI9XFxcInNlbGVjdEFjdGl2ZSgkaW5kZXgpXFxcIiBuZy1jbGljaz1cXFwic2VsZWN0TWF0Y2goJGluZGV4LCAkZXZlbnQpXFxcIiByb2xlPVxcXCJvcHRpb25cXFwiIGlkPVxcXCJ7ezo6bWF0Y2guaWR9fVxcXCI+XFxuXCIgK1xuICAgIFwiICAgICAgICA8ZGl2IHVpYi10eXBlYWhlYWQtbWF0Y2ggaW5kZXg9XFxcIiRpbmRleFxcXCIgbWF0Y2g9XFxcIm1hdGNoXFxcIiBxdWVyeT1cXFwicXVlcnlcXFwiIHRlbXBsYXRlLXVybD1cXFwidGVtcGxhdGVVcmxcXFwiPjwvZGl2PlxcblwiICtcbiAgICBcIiAgICA8L2xpPlxcblwiICtcbiAgICBcIjwvdWw+XFxuXCIgK1xuICAgIFwiXCIpO1xufV0pO1xuYW5ndWxhci5tb2R1bGUoJ3VpLmJvb3RzdHJhcC5jYXJvdXNlbCcpLnJ1bihmdW5jdGlvbigpIHshYW5ndWxhci4kJGNzcCgpLm5vSW5saW5lU3R5bGUgJiYgIWFuZ3VsYXIuJCR1aWJDYXJvdXNlbENzcyAmJiBhbmd1bGFyLmVsZW1lbnQoZG9jdW1lbnQpLmZpbmQoJ2hlYWQnKS5wcmVwZW5kKCc8c3R5bGUgdHlwZT1cInRleHQvY3NzXCI+Lm5nLWFuaW1hdGUuaXRlbTpub3QoLmxlZnQpOm5vdCgucmlnaHQpey13ZWJraXQtdHJhbnNpdGlvbjowcyBlYXNlLWluLW91dCBsZWZ0O3RyYW5zaXRpb246MHMgZWFzZS1pbi1vdXQgbGVmdH08L3N0eWxlPicpOyBhbmd1bGFyLiQkdWliQ2Fyb3VzZWxDc3MgPSB0cnVlOyB9KTtcbmFuZ3VsYXIubW9kdWxlKCd1aS5ib290c3RyYXAuZGF0ZXBpY2tlcicpLnJ1bihmdW5jdGlvbigpIHshYW5ndWxhci4kJGNzcCgpLm5vSW5saW5lU3R5bGUgJiYgIWFuZ3VsYXIuJCR1aWJEYXRlcGlja2VyQ3NzICYmIGFuZ3VsYXIuZWxlbWVudChkb2N1bWVudCkuZmluZCgnaGVhZCcpLnByZXBlbmQoJzxzdHlsZSB0eXBlPVwidGV4dC9jc3NcIj4udWliLWRhdGVwaWNrZXIgLnVpYi10aXRsZXt3aWR0aDoxMDAlO30udWliLWRheSBidXR0b24sLnVpYi1tb250aCBidXR0b24sLnVpYi15ZWFyIGJ1dHRvbnttaW4td2lkdGg6MTAwJTt9LnVpYi1sZWZ0LC51aWItcmlnaHR7d2lkdGg6MTAwJX08L3N0eWxlPicpOyBhbmd1bGFyLiQkdWliRGF0ZXBpY2tlckNzcyA9IHRydWU7IH0pO1xuYW5ndWxhci5tb2R1bGUoJ3VpLmJvb3RzdHJhcC5wb3NpdGlvbicpLnJ1bihmdW5jdGlvbigpIHshYW5ndWxhci4kJGNzcCgpLm5vSW5saW5lU3R5bGUgJiYgIWFuZ3VsYXIuJCR1aWJQb3NpdGlvbkNzcyAmJiBhbmd1bGFyLmVsZW1lbnQoZG9jdW1lbnQpLmZpbmQoJ2hlYWQnKS5wcmVwZW5kKCc8c3R5bGUgdHlwZT1cInRleHQvY3NzXCI+LnVpYi1wb3NpdGlvbi1tZWFzdXJle2Rpc3BsYXk6YmxvY2sgIWltcG9ydGFudDt2aXNpYmlsaXR5OmhpZGRlbiAhaW1wb3J0YW50O3Bvc2l0aW9uOmFic29sdXRlICFpbXBvcnRhbnQ7dG9wOi05OTk5cHggIWltcG9ydGFudDtsZWZ0Oi05OTk5cHggIWltcG9ydGFudDt9LnVpYi1wb3NpdGlvbi1zY3JvbGxiYXItbWVhc3VyZXtwb3NpdGlvbjphYnNvbHV0ZSAhaW1wb3J0YW50O3RvcDotOTk5OXB4ICFpbXBvcnRhbnQ7d2lkdGg6NTBweCAhaW1wb3J0YW50O2hlaWdodDo1MHB4ICFpbXBvcnRhbnQ7b3ZlcmZsb3c6c2Nyb2xsICFpbXBvcnRhbnQ7fS51aWItcG9zaXRpb24tYm9keS1zY3JvbGxiYXItbWVhc3VyZXtvdmVyZmxvdzpzY3JvbGwgIWltcG9ydGFudDt9PC9zdHlsZT4nKTsgYW5ndWxhci4kJHVpYlBvc2l0aW9uQ3NzID0gdHJ1ZTsgfSk7XG5hbmd1bGFyLm1vZHVsZSgndWkuYm9vdHN0cmFwLmRhdGVwaWNrZXJQb3B1cCcpLnJ1bihmdW5jdGlvbigpIHshYW5ndWxhci4kJGNzcCgpLm5vSW5saW5lU3R5bGUgJiYgIWFuZ3VsYXIuJCR1aWJEYXRlcGlja2VycG9wdXBDc3MgJiYgYW5ndWxhci5lbGVtZW50KGRvY3VtZW50KS5maW5kKCdoZWFkJykucHJlcGVuZCgnPHN0eWxlIHR5cGU9XCJ0ZXh0L2Nzc1wiPi51aWItZGF0ZXBpY2tlci1wb3B1cC5kcm9wZG93bi1tZW51e2Rpc3BsYXk6YmxvY2s7ZmxvYXQ6bm9uZTttYXJnaW46MDt9LnVpYi1idXR0b24tYmFye3BhZGRpbmc6MTBweCA5cHggMnB4O308L3N0eWxlPicpOyBhbmd1bGFyLiQkdWliRGF0ZXBpY2tlcnBvcHVwQ3NzID0gdHJ1ZTsgfSk7XG5hbmd1bGFyLm1vZHVsZSgndWkuYm9vdHN0cmFwLnRvb2x0aXAnKS5ydW4oZnVuY3Rpb24oKSB7IWFuZ3VsYXIuJCRjc3AoKS5ub0lubGluZVN0eWxlICYmICFhbmd1bGFyLiQkdWliVG9vbHRpcENzcyAmJiBhbmd1bGFyLmVsZW1lbnQoZG9jdW1lbnQpLmZpbmQoJ2hlYWQnKS5wcmVwZW5kKCc8c3R5bGUgdHlwZT1cInRleHQvY3NzXCI+W3VpYi10b29sdGlwLXBvcHVwXS50b29sdGlwLnRvcC1sZWZ0ID4gLnRvb2x0aXAtYXJyb3csW3VpYi10b29sdGlwLXBvcHVwXS50b29sdGlwLnRvcC1yaWdodCA+IC50b29sdGlwLWFycm93LFt1aWItdG9vbHRpcC1wb3B1cF0udG9vbHRpcC5ib3R0b20tbGVmdCA+IC50b29sdGlwLWFycm93LFt1aWItdG9vbHRpcC1wb3B1cF0udG9vbHRpcC5ib3R0b20tcmlnaHQgPiAudG9vbHRpcC1hcnJvdyxbdWliLXRvb2x0aXAtcG9wdXBdLnRvb2x0aXAubGVmdC10b3AgPiAudG9vbHRpcC1hcnJvdyxbdWliLXRvb2x0aXAtcG9wdXBdLnRvb2x0aXAubGVmdC1ib3R0b20gPiAudG9vbHRpcC1hcnJvdyxbdWliLXRvb2x0aXAtcG9wdXBdLnRvb2x0aXAucmlnaHQtdG9wID4gLnRvb2x0aXAtYXJyb3csW3VpYi10b29sdGlwLXBvcHVwXS50b29sdGlwLnJpZ2h0LWJvdHRvbSA+IC50b29sdGlwLWFycm93LFt1aWItdG9vbHRpcC1odG1sLXBvcHVwXS50b29sdGlwLnRvcC1sZWZ0ID4gLnRvb2x0aXAtYXJyb3csW3VpYi10b29sdGlwLWh0bWwtcG9wdXBdLnRvb2x0aXAudG9wLXJpZ2h0ID4gLnRvb2x0aXAtYXJyb3csW3VpYi10b29sdGlwLWh0bWwtcG9wdXBdLnRvb2x0aXAuYm90dG9tLWxlZnQgPiAudG9vbHRpcC1hcnJvdyxbdWliLXRvb2x0aXAtaHRtbC1wb3B1cF0udG9vbHRpcC5ib3R0b20tcmlnaHQgPiAudG9vbHRpcC1hcnJvdyxbdWliLXRvb2x0aXAtaHRtbC1wb3B1cF0udG9vbHRpcC5sZWZ0LXRvcCA+IC50b29sdGlwLWFycm93LFt1aWItdG9vbHRpcC1odG1sLXBvcHVwXS50b29sdGlwLmxlZnQtYm90dG9tID4gLnRvb2x0aXAtYXJyb3csW3VpYi10b29sdGlwLWh0bWwtcG9wdXBdLnRvb2x0aXAucmlnaHQtdG9wID4gLnRvb2x0aXAtYXJyb3csW3VpYi10b29sdGlwLWh0bWwtcG9wdXBdLnRvb2x0aXAucmlnaHQtYm90dG9tID4gLnRvb2x0aXAtYXJyb3csW3VpYi10b29sdGlwLXRlbXBsYXRlLXBvcHVwXS50b29sdGlwLnRvcC1sZWZ0ID4gLnRvb2x0aXAtYXJyb3csW3VpYi10b29sdGlwLXRlbXBsYXRlLXBvcHVwXS50b29sdGlwLnRvcC1yaWdodCA+IC50b29sdGlwLWFycm93LFt1aWItdG9vbHRpcC10ZW1wbGF0ZS1wb3B1cF0udG9vbHRpcC5ib3R0b20tbGVmdCA+IC50b29sdGlwLWFycm93LFt1aWItdG9vbHRpcC10ZW1wbGF0ZS1wb3B1cF0udG9vbHRpcC5ib3R0b20tcmlnaHQgPiAudG9vbHRpcC1hcnJvdyxbdWliLXRvb2x0aXAtdGVtcGxhdGUtcG9wdXBdLnRvb2x0aXAubGVmdC10b3AgPiAudG9vbHRpcC1hcnJvdyxbdWliLXRvb2x0aXAtdGVtcGxhdGUtcG9wdXBdLnRvb2x0aXAubGVmdC1ib3R0b20gPiAudG9vbHRpcC1hcnJvdyxbdWliLXRvb2x0aXAtdGVtcGxhdGUtcG9wdXBdLnRvb2x0aXAucmlnaHQtdG9wID4gLnRvb2x0aXAtYXJyb3csW3VpYi10b29sdGlwLXRlbXBsYXRlLXBvcHVwXS50b29sdGlwLnJpZ2h0LWJvdHRvbSA+IC50b29sdGlwLWFycm93LFt1aWItcG9wb3Zlci1wb3B1cF0ucG9wb3Zlci50b3AtbGVmdCA+IC5hcnJvdyxbdWliLXBvcG92ZXItcG9wdXBdLnBvcG92ZXIudG9wLXJpZ2h0ID4gLmFycm93LFt1aWItcG9wb3Zlci1wb3B1cF0ucG9wb3Zlci5ib3R0b20tbGVmdCA+IC5hcnJvdyxbdWliLXBvcG92ZXItcG9wdXBdLnBvcG92ZXIuYm90dG9tLXJpZ2h0ID4gLmFycm93LFt1aWItcG9wb3Zlci1wb3B1cF0ucG9wb3Zlci5sZWZ0LXRvcCA+IC5hcnJvdyxbdWliLXBvcG92ZXItcG9wdXBdLnBvcG92ZXIubGVmdC1ib3R0b20gPiAuYXJyb3csW3VpYi1wb3BvdmVyLXBvcHVwXS5wb3BvdmVyLnJpZ2h0LXRvcCA+IC5hcnJvdyxbdWliLXBvcG92ZXItcG9wdXBdLnBvcG92ZXIucmlnaHQtYm90dG9tID4gLmFycm93LFt1aWItcG9wb3Zlci1odG1sLXBvcHVwXS5wb3BvdmVyLnRvcC1sZWZ0ID4gLmFycm93LFt1aWItcG9wb3Zlci1odG1sLXBvcHVwXS5wb3BvdmVyLnRvcC1yaWdodCA+IC5hcnJvdyxbdWliLXBvcG92ZXItaHRtbC1wb3B1cF0ucG9wb3Zlci5ib3R0b20tbGVmdCA+IC5hcnJvdyxbdWliLXBvcG92ZXItaHRtbC1wb3B1cF0ucG9wb3Zlci5ib3R0b20tcmlnaHQgPiAuYXJyb3csW3VpYi1wb3BvdmVyLWh0bWwtcG9wdXBdLnBvcG92ZXIubGVmdC10b3AgPiAuYXJyb3csW3VpYi1wb3BvdmVyLWh0bWwtcG9wdXBdLnBvcG92ZXIubGVmdC1ib3R0b20gPiAuYXJyb3csW3VpYi1wb3BvdmVyLWh0bWwtcG9wdXBdLnBvcG92ZXIucmlnaHQtdG9wID4gLmFycm93LFt1aWItcG9wb3Zlci1odG1sLXBvcHVwXS5wb3BvdmVyLnJpZ2h0LWJvdHRvbSA+IC5hcnJvdyxbdWliLXBvcG92ZXItdGVtcGxhdGUtcG9wdXBdLnBvcG92ZXIudG9wLWxlZnQgPiAuYXJyb3csW3VpYi1wb3BvdmVyLXRlbXBsYXRlLXBvcHVwXS5wb3BvdmVyLnRvcC1yaWdodCA+IC5hcnJvdyxbdWliLXBvcG92ZXItdGVtcGxhdGUtcG9wdXBdLnBvcG92ZXIuYm90dG9tLWxlZnQgPiAuYXJyb3csW3VpYi1wb3BvdmVyLXRlbXBsYXRlLXBvcHVwXS5wb3BvdmVyLmJvdHRvbS1yaWdodCA+IC5hcnJvdyxbdWliLXBvcG92ZXItdGVtcGxhdGUtcG9wdXBdLnBvcG92ZXIubGVmdC10b3AgPiAuYXJyb3csW3VpYi1wb3BvdmVyLXRlbXBsYXRlLXBvcHVwXS5wb3BvdmVyLmxlZnQtYm90dG9tID4gLmFycm93LFt1aWItcG9wb3Zlci10ZW1wbGF0ZS1wb3B1cF0ucG9wb3Zlci5yaWdodC10b3AgPiAuYXJyb3csW3VpYi1wb3BvdmVyLXRlbXBsYXRlLXBvcHVwXS5wb3BvdmVyLnJpZ2h0LWJvdHRvbSA+IC5hcnJvd3t0b3A6YXV0bztib3R0b206YXV0bztsZWZ0OmF1dG87cmlnaHQ6YXV0bzttYXJnaW46MDt9W3VpYi1wb3BvdmVyLXBvcHVwXS5wb3BvdmVyLFt1aWItcG9wb3Zlci1odG1sLXBvcHVwXS5wb3BvdmVyLFt1aWItcG9wb3Zlci10ZW1wbGF0ZS1wb3B1cF0ucG9wb3ZlcntkaXNwbGF5OmJsb2NrICFpbXBvcnRhbnQ7fTwvc3R5bGU+Jyk7IGFuZ3VsYXIuJCR1aWJUb29sdGlwQ3NzID0gdHJ1ZTsgfSk7XG5hbmd1bGFyLm1vZHVsZSgndWkuYm9vdHN0cmFwLnRpbWVwaWNrZXInKS5ydW4oZnVuY3Rpb24oKSB7IWFuZ3VsYXIuJCRjc3AoKS5ub0lubGluZVN0eWxlICYmICFhbmd1bGFyLiQkdWliVGltZXBpY2tlckNzcyAmJiBhbmd1bGFyLmVsZW1lbnQoZG9jdW1lbnQpLmZpbmQoJ2hlYWQnKS5wcmVwZW5kKCc8c3R5bGUgdHlwZT1cInRleHQvY3NzXCI+LnVpYi10aW1lIGlucHV0e3dpZHRoOjUwcHg7fTwvc3R5bGU+Jyk7IGFuZ3VsYXIuJCR1aWJUaW1lcGlja2VyQ3NzID0gdHJ1ZTsgfSk7XG5hbmd1bGFyLm1vZHVsZSgndWkuYm9vdHN0cmFwLnR5cGVhaGVhZCcpLnJ1bihmdW5jdGlvbigpIHshYW5ndWxhci4kJGNzcCgpLm5vSW5saW5lU3R5bGUgJiYgIWFuZ3VsYXIuJCR1aWJUeXBlYWhlYWRDc3MgJiYgYW5ndWxhci5lbGVtZW50KGRvY3VtZW50KS5maW5kKCdoZWFkJykucHJlcGVuZCgnPHN0eWxlIHR5cGU9XCJ0ZXh0L2Nzc1wiPlt1aWItdHlwZWFoZWFkLXBvcHVwXS5kcm9wZG93bi1tZW51e2Rpc3BsYXk6YmxvY2s7fTwvc3R5bGU+Jyk7IGFuZ3VsYXIuJCR1aWJUeXBlYWhlYWRDc3MgPSB0cnVlOyB9KTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3\n")},function(module,exports,__webpack_require__){eval('const angular = __webpack_require__(0);\r\n\r\nmodule.exports = angular.module("db1.core", [\r\n  __webpack_require__(5),\r\n  __webpack_require__(10),\r\n  __webpack_require__(12)\r\n]).name;\r\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2NvcmUvY29yZS5tb2R1bGUuanM/YmM2ZCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxnQkFBZ0IsbUJBQU8sQ0FBQyxDQUFTOztBQUVqQztBQUNBLEVBQUUsbUJBQU8sQ0FBQyxDQUFhO0FBQ3ZCLEVBQUUsbUJBQU8sQ0FBQyxFQUFXO0FBQ3JCLEVBQUUsbUJBQU8sQ0FBQyxFQUFZO0FBQ3RCIiwiZmlsZSI6IjQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBhbmd1bGFyID0gcmVxdWlyZShcImFuZ3VsYXJcIik7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGFuZ3VsYXIubW9kdWxlKFwiZGIxLmNvcmVcIiwgW1xyXG4gIHJlcXVpcmUoXCIuL2RpcmV0aXZhc1wiKSxcclxuICByZXF1aXJlKFwiLi9maWx0ZXJzXCIpLFxyXG4gIHJlcXVpcmUoXCIuL3NlcnZpY2VzXCIpXHJcbl0pLm5hbWU7XHJcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///4\n')},function(module,exports,__webpack_require__){eval('const angular = __webpack_require__(0);\r\n\r\nmodule.exports = angular.module("db1.core.diretivas", [\r\n  __webpack_require__(6)\r\n]).name;\r\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2NvcmUvZGlyZXRpdmFzL2luZGV4LmpzPzgyZGYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsZ0JBQWdCLG1CQUFPLENBQUMsQ0FBUzs7QUFFakM7QUFDQSxFQUFFLG1CQUFPLENBQUMsQ0FBYTtBQUN2QiIsImZpbGUiOiI1LmpzIiwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgYW5ndWxhciA9IHJlcXVpcmUoXCJhbmd1bGFyXCIpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBhbmd1bGFyLm1vZHVsZShcImRiMS5jb3JlLmRpcmV0aXZhc1wiLCBbXHJcbiAgcmVxdWlyZShcIi4vYXBwLWNhcnRhXCIpXHJcbl0pLm5hbWU7XHJcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///5\n')},function(module,exports,__webpack_require__){eval('const angular = __webpack_require__(0);\r\n__webpack_require__(7);\r\n\r\nmodule.exports = angular\r\n  .module("app-carta", [])\r\n  .directive("appCarta", __webpack_require__(8)).name;\r\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2NvcmUvZGlyZXRpdmFzL2FwcC1jYXJ0YS9pbmRleC5qcz8wOWM4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGdCQUFnQixtQkFBTyxDQUFDLENBQVM7QUFDakMsbUJBQU8sQ0FBQyxDQUFpQjs7QUFFekI7QUFDQTtBQUNBLHlCQUF5QixtQkFBTyxDQUFDLENBQXVCIiwiZmlsZSI6IjYuanMiLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBhbmd1bGFyID0gcmVxdWlyZShcImFuZ3VsYXJcIik7XHJcbnJlcXVpcmUoXCIuL2FwcC1jYXJ0YS5jc3NcIik7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGFuZ3VsYXJcclxuICAubW9kdWxlKFwiYXBwLWNhcnRhXCIsIFtdKVxyXG4gIC5kaXJlY3RpdmUoXCJhcHBDYXJ0YVwiLCByZXF1aXJlKFwiLi9hcHAtY2FydGEuZGlyZWN0aXZlXCIpKS5uYW1lO1xyXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///6\n')},function(module,exports,__webpack_require__){eval("// extracted by mini-css-extract-plugin\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2NvcmUvZGlyZXRpdmFzL2FwcC1jYXJ0YS9hcHAtY2FydGEuY3NzP2MyM2QiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoiNy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///7\n")},function(module,exports,__webpack_require__){eval('module.exports = diretiva;\r\n\r\nfunction diretiva() {\r\n  return {\r\n    restrict: "E",\r\n    template: __webpack_require__(9),\r\n    scope: {\r\n      carta: "=",\r\n      click: "&"\r\n    },\r\n    bindToController: true,\r\n    controller: Controller,\r\n    controllerAs: "vm"\r\n  };\r\n}\r\n\r\nController.$inject = [];\r\n\r\nfunction Controller() {\r\n  const vm = this;\r\n\r\n  vm.getImageCard = () => {\r\n    return {\r\n      background: vm.carta.image\r\n        ? `url(${vm.carta.image}) no-repeat center center`\r\n        : "",\r\n      "background-size": "cover"\r\n    };\r\n  };\r\n}\r\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2NvcmUvZGlyZXRpdmFzL2FwcC1jYXJ0YS9hcHAtY2FydGEuZGlyZWN0aXZlLmpzPzIyZDciXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLENBQWtCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGVBQWU7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiI4LmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBkaXJldGl2YTtcclxuXHJcbmZ1bmN0aW9uIGRpcmV0aXZhKCkge1xyXG4gIHJldHVybiB7XHJcbiAgICByZXN0cmljdDogXCJFXCIsXHJcbiAgICB0ZW1wbGF0ZTogcmVxdWlyZShcIi4vYXBwLWNhcnRhLmh0bWxcIiksXHJcbiAgICBzY29wZToge1xyXG4gICAgICBjYXJ0YTogXCI9XCIsXHJcbiAgICAgIGNsaWNrOiBcIiZcIlxyXG4gICAgfSxcclxuICAgIGJpbmRUb0NvbnRyb2xsZXI6IHRydWUsXHJcbiAgICBjb250cm9sbGVyOiBDb250cm9sbGVyLFxyXG4gICAgY29udHJvbGxlckFzOiBcInZtXCJcclxuICB9O1xyXG59XHJcblxyXG5Db250cm9sbGVyLiRpbmplY3QgPSBbXTtcclxuXHJcbmZ1bmN0aW9uIENvbnRyb2xsZXIoKSB7XHJcbiAgY29uc3Qgdm0gPSB0aGlzO1xyXG5cclxuICB2bS5nZXRJbWFnZUNhcmQgPSAoKSA9PiB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBiYWNrZ3JvdW5kOiB2bS5jYXJ0YS5pbWFnZVxyXG4gICAgICAgID8gYHVybCgke3ZtLmNhcnRhLmltYWdlfSkgbm8tcmVwZWF0IGNlbnRlciBjZW50ZXJgXHJcbiAgICAgICAgOiBcIlwiLFxyXG4gICAgICBcImJhY2tncm91bmQtc2l6ZVwiOiBcImNvdmVyXCJcclxuICAgIH07XHJcbiAgfTtcclxufVxyXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///8\n')},function(module,exports){eval('module.exports = "<div class=scene> <div class=carta ng-class=vm.carta.class ng-click=vm.click()> <div class=\\"carta__face carta__face--front\\"></div> <div class=\\"carta__face carta__face--back\\" ng-style=vm.getImageCard()></div> </div> </div> ";\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2NvcmUvZGlyZXRpdmFzL2FwcC1jYXJ0YS9hcHAtY2FydGEuaHRtbD84YWQ5Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBIiwiZmlsZSI6IjkuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IFwiPGRpdiBjbGFzcz1zY2VuZT4gPGRpdiBjbGFzcz1jYXJ0YSBuZy1jbGFzcz12bS5jYXJ0YS5jbGFzcyBuZy1jbGljaz12bS5jbGljaygpPiA8ZGl2IGNsYXNzPVxcXCJjYXJ0YV9fZmFjZSBjYXJ0YV9fZmFjZS0tZnJvbnRcXFwiPjwvZGl2PiA8ZGl2IGNsYXNzPVxcXCJjYXJ0YV9fZmFjZSBjYXJ0YV9fZmFjZS0tYmFja1xcXCIgbmctc3R5bGU9dm0uZ2V0SW1hZ2VDYXJkKCk+PC9kaXY+IDwvZGl2PiA8L2Rpdj4gXCI7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///9\n')},function(module,exports,__webpack_require__){eval('var angular = __webpack_require__(0);\r\n\r\nmodule.exports = angular\r\n  .module("db1.filters", [])\r\n  .filter("customTime", __webpack_require__(11)).name;\r\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2NvcmUvZmlsdGVycy9pbmRleC5qcz9lYjAwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGNBQWMsbUJBQU8sQ0FBQyxDQUFTOztBQUUvQjtBQUNBO0FBQ0Esd0JBQXdCLG1CQUFPLENBQUMsRUFBUSIsImZpbGUiOiIxMC5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBhbmd1bGFyID0gcmVxdWlyZShcImFuZ3VsYXJcIik7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGFuZ3VsYXJcclxuICAubW9kdWxlKFwiZGIxLmZpbHRlcnNcIiwgW10pXHJcbiAgLmZpbHRlcihcImN1c3RvbVRpbWVcIiwgcmVxdWlyZShcIi4vdGltZVwiKSkubmFtZTtcclxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///10\n')},function(module,exports){eval('module.exports = filter;\r\n\r\nfunction filter() {\r\n  return segundos => {\r\n    if (!Number.isInteger(segundos)) return "00:00:00";\r\n    let tempo = new Date(segundos * 1000)\r\n      .toISOString()\r\n      .substr(11, 8)\r\n      .split(":");\r\n    let h = Number(tempo[0]);\r\n    let m = Number(tempo[1]);\r\n    let s = Number(tempo[2]);\r\n    return `${h ? `${h}h ` : ""}${m ? `${m}m ` : ""}${s ? `${s}s ` : "0"}`;\r\n  };\r\n}\r\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2NvcmUvZmlsdGVycy90aW1lLmpzP2RiZDYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU8sRUFBRSxTQUFTLEVBQUUsT0FBTyxFQUFFLFNBQVMsRUFBRSxPQUFPLEVBQUUsVUFBVTtBQUN6RTtBQUNBIiwiZmlsZSI6IjExLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBmaWx0ZXI7XHJcblxyXG5mdW5jdGlvbiBmaWx0ZXIoKSB7XHJcbiAgcmV0dXJuIHNlZ3VuZG9zID0+IHtcclxuICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihzZWd1bmRvcykpIHJldHVybiBcIjAwOjAwOjAwXCI7XHJcbiAgICBsZXQgdGVtcG8gPSBuZXcgRGF0ZShzZWd1bmRvcyAqIDEwMDApXHJcbiAgICAgIC50b0lTT1N0cmluZygpXHJcbiAgICAgIC5zdWJzdHIoMTEsIDgpXHJcbiAgICAgIC5zcGxpdChcIjpcIik7XHJcbiAgICBsZXQgaCA9IE51bWJlcih0ZW1wb1swXSk7XHJcbiAgICBsZXQgbSA9IE51bWJlcih0ZW1wb1sxXSk7XHJcbiAgICBsZXQgcyA9IE51bWJlcih0ZW1wb1syXSk7XHJcbiAgICByZXR1cm4gYCR7aCA/IGAke2h9aCBgIDogXCJcIn0ke20gPyBgJHttfW0gYCA6IFwiXCJ9JHtzID8gYCR7c31zIGAgOiBcIjBcIn1gO1xyXG4gIH07XHJcbn1cclxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///11\n')},function(module,exports,__webpack_require__){eval('const angular = __webpack_require__(0);\r\n\r\nmodule.exports = angular.module("db1.services", [__webpack_require__(13)]).name;\r\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2NvcmUvc2VydmljZXMvaW5kZXguanM/ODE2ZiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxnQkFBZ0IsbUJBQU8sQ0FBQyxDQUFTOztBQUVqQyxpREFBaUQsbUJBQU8sQ0FBQyxFQUFXIiwiZmlsZSI6IjEyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgYW5ndWxhciA9IHJlcXVpcmUoXCJhbmd1bGFyXCIpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBhbmd1bGFyLm1vZHVsZShcImRiMS5zZXJ2aWNlc1wiLCBbcmVxdWlyZShcIi4vc3RvcmFnZVwiKV0pLm5hbWU7XHJcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///12\n')},function(module,exports,__webpack_require__){eval('const angular = __webpack_require__(0);\r\n\r\nmodule.exports = angular\r\n  .module("db1.services.storage", [])\r\n  .service("StorageService", __webpack_require__(14)).name;\r\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2NvcmUvc2VydmljZXMvc3RvcmFnZS9pbmRleC5qcz9mOTE4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGdCQUFnQixtQkFBTyxDQUFDLENBQVM7O0FBRWpDO0FBQ0E7QUFDQSw2QkFBNkIsbUJBQU8sQ0FBQyxFQUFtQiIsImZpbGUiOiIxMy5qcyIsInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGFuZ3VsYXIgPSByZXF1aXJlKFwiYW5ndWxhclwiKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gYW5ndWxhclxyXG4gIC5tb2R1bGUoXCJkYjEuc2VydmljZXMuc3RvcmFnZVwiLCBbXSlcclxuICAuc2VydmljZShcIlN0b3JhZ2VTZXJ2aWNlXCIsIHJlcXVpcmUoXCIuL3N0b3JhZ2Uuc2VydmljZVwiKSkubmFtZTtcclxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///13\n')},function(module,exports){eval('module.exports = Service;\r\n\r\nconst RANKRODADA = "projetoDB1Rodada";\r\nconst RANKTEMPO = "projetoDB1Tempo";\r\nconst TIPO = "projetoDB1Tipo";\r\n\r\nService.$inject = [];\r\n\r\nfunction Service() {\r\n  const self = this;\r\n\r\n  let rodadas = getStorageRodadas();\r\n  let tempos = getStorageTempos();\r\n\r\n  self.adicionaNovoRanking = (nome, value) => {\r\n    if (isRodada()) {\r\n      rodadas.push({ nome, value });\r\n      return localStorage.setItem(RANKRODADA, JSON.stringify(rodadas));\r\n    }\r\n    tempos.push({ nome, value });\r\n    return localStorage.setItem(RANKTEMPO, JSON.stringify(tempos));\r\n  };\r\n\r\n  self.getRanking = () => {\r\n    if (isRodada()) return rodadas.sort(ordenaValueMenor).slice(0, 10);\r\n    return tempos.sort(ordenaValueMenor).slice(0, 10);\r\n  };\r\n\r\n  function getStorageRodadas() {\r\n    return JSON.parse(localStorage.getItem(RANKRODADA)) || [];\r\n  }\r\n\r\n  function getStorageTempos() {\r\n    return JSON.parse(localStorage.getItem(RANKTEMPO)) || [];\r\n  }\r\n\r\n  function ordenaValueMenor(a, b) {\r\n    return a.value > b.value ? 1 : -1;\r\n  }\r\n\r\n  function isRodada() {\r\n    return self.getTipo() === "rodada";\r\n  }\r\n\r\n  self.setTipo = tipo => localStorage.setItem(TIPO, tipo);\r\n  self.getTipo = tipo => localStorage.getItem(TIPO) || "rodada";\r\n}\r\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2NvcmUvc2VydmljZXMvc3RvcmFnZS9zdG9yYWdlLnNlcnZpY2UuanM/OWVkOCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0EsaUJBQWlCLGNBQWM7QUFDL0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwiZmlsZSI6IjE0LmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBTZXJ2aWNlO1xyXG5cclxuY29uc3QgUkFOS1JPREFEQSA9IFwicHJvamV0b0RCMVJvZGFkYVwiO1xyXG5jb25zdCBSQU5LVEVNUE8gPSBcInByb2pldG9EQjFUZW1wb1wiO1xyXG5jb25zdCBUSVBPID0gXCJwcm9qZXRvREIxVGlwb1wiO1xyXG5cclxuU2VydmljZS4kaW5qZWN0ID0gW107XHJcblxyXG5mdW5jdGlvbiBTZXJ2aWNlKCkge1xyXG4gIGNvbnN0IHNlbGYgPSB0aGlzO1xyXG5cclxuICBsZXQgcm9kYWRhcyA9IGdldFN0b3JhZ2VSb2RhZGFzKCk7XHJcbiAgbGV0IHRlbXBvcyA9IGdldFN0b3JhZ2VUZW1wb3MoKTtcclxuXHJcbiAgc2VsZi5hZGljaW9uYU5vdm9SYW5raW5nID0gKG5vbWUsIHZhbHVlKSA9PiB7XHJcbiAgICBpZiAoaXNSb2RhZGEoKSkge1xyXG4gICAgICByb2RhZGFzLnB1c2goeyBub21lLCB2YWx1ZSB9KTtcclxuICAgICAgcmV0dXJuIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFJBTktST0RBREEsIEpTT04uc3RyaW5naWZ5KHJvZGFkYXMpKTtcclxuICAgIH1cclxuICAgIHRlbXBvcy5wdXNoKHsgbm9tZSwgdmFsdWUgfSk7XHJcbiAgICByZXR1cm4gbG9jYWxTdG9yYWdlLnNldEl0ZW0oUkFOS1RFTVBPLCBKU09OLnN0cmluZ2lmeSh0ZW1wb3MpKTtcclxuICB9O1xyXG5cclxuICBzZWxmLmdldFJhbmtpbmcgPSAoKSA9PiB7XHJcbiAgICBpZiAoaXNSb2RhZGEoKSkgcmV0dXJuIHJvZGFkYXMuc29ydChvcmRlbmFWYWx1ZU1lbm9yKS5zbGljZSgwLCAxMCk7XHJcbiAgICByZXR1cm4gdGVtcG9zLnNvcnQob3JkZW5hVmFsdWVNZW5vcikuc2xpY2UoMCwgMTApO1xyXG4gIH07XHJcblxyXG4gIGZ1bmN0aW9uIGdldFN0b3JhZ2VSb2RhZGFzKCkge1xyXG4gICAgcmV0dXJuIEpTT04ucGFyc2UobG9jYWxTdG9yYWdlLmdldEl0ZW0oUkFOS1JPREFEQSkpIHx8IFtdO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZ2V0U3RvcmFnZVRlbXBvcygpIHtcclxuICAgIHJldHVybiBKU09OLnBhcnNlKGxvY2FsU3RvcmFnZS5nZXRJdGVtKFJBTktURU1QTykpIHx8IFtdO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gb3JkZW5hVmFsdWVNZW5vcihhLCBiKSB7XHJcbiAgICByZXR1cm4gYS52YWx1ZSA+IGIudmFsdWUgPyAxIDogLTE7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBpc1JvZGFkYSgpIHtcclxuICAgIHJldHVybiBzZWxmLmdldFRpcG8oKSA9PT0gXCJyb2RhZGFcIjtcclxuICB9XHJcblxyXG4gIHNlbGYuc2V0VGlwbyA9IHRpcG8gPT4gbG9jYWxTdG9yYWdlLnNldEl0ZW0oVElQTywgdGlwbyk7XHJcbiAgc2VsZi5nZXRUaXBvID0gdGlwbyA9PiBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShUSVBPKSB8fCBcInJvZGFkYVwiO1xyXG59XHJcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///14\n')},function(module,exports,__webpack_require__){eval('const angular = __webpack_require__(0);\r\n\r\nmodule.exports = angular.module("db1.commons", [\r\n  __webpack_require__(16),\r\n  __webpack_require__(19)\r\n]).name;\r\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2NvbW1vbnMvY29tbW9ucy5tb2R1bGUuanM/OGQyMCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxnQkFBZ0IsbUJBQU8sQ0FBQyxDQUFTOztBQUVqQztBQUNBLEVBQUUsbUJBQU8sQ0FBQyxFQUFvQjtBQUM5QixFQUFFLG1CQUFPLENBQUMsRUFBb0I7QUFDOUIiLCJmaWxlIjoiMTUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBhbmd1bGFyID0gcmVxdWlyZShcImFuZ3VsYXJcIik7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGFuZ3VsYXIubW9kdWxlKFwiZGIxLmNvbW1vbnNcIiwgW1xyXG4gIHJlcXVpcmUoXCIuL2hvbWUvaG9tZS5tb2R1bGVcIiksXHJcbiAgcmVxdWlyZShcIi4vam9nby9qb2dvLm1vZHVsZVwiKVxyXG5dKS5uYW1lO1xyXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///15\n')},function(module,exports,__webpack_require__){eval('const angular = __webpack_require__(0);\r\n__webpack_require__(17);\r\n\r\nmodule.exports = angular\r\n  .module("db1.home", [])\r\n  .controller("db1.home.HomeController", __webpack_require__(18)).name;\r\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2NvbW1vbnMvaG9tZS9ob21lLm1vZHVsZS5qcz9jNWM5Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGdCQUFnQixtQkFBTyxDQUFDLENBQVM7QUFDakMsbUJBQU8sQ0FBQyxFQUFZOztBQUVwQjtBQUNBO0FBQ0EseUNBQXlDLG1CQUFPLENBQUMsRUFBbUIiLCJmaWxlIjoiMTYuanMiLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBhbmd1bGFyID0gcmVxdWlyZShcImFuZ3VsYXJcIik7XHJcbnJlcXVpcmUoXCIuL2hvbWUuY3NzXCIpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBhbmd1bGFyXHJcbiAgLm1vZHVsZShcImRiMS5ob21lXCIsIFtdKVxyXG4gIC5jb250cm9sbGVyKFwiZGIxLmhvbWUuSG9tZUNvbnRyb2xsZXJcIiwgcmVxdWlyZShcIi4vaG9tZS5jb250cm9sbGVyXCIpKS5uYW1lO1xyXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///16\n')},function(module,exports,__webpack_require__){eval("// extracted by mini-css-extract-plugin\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2NvbW1vbnMvaG9tZS9ob21lLmNzcz8xNGQ1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBIiwiZmlsZSI6IjE3LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///17\n")},function(module,exports){eval('module.exports = Controller;\r\n\r\nController.$inject = ["StorageService"];\r\n\r\nfunction Controller(StorageService) {\r\n  const vm = this;\r\n\r\n  init();\r\n\r\n  function init() {\r\n    getRank();\r\n    getTipo();\r\n  }\r\n\r\n  function getRank() {\r\n    vm.ranking = StorageService.getRanking();\r\n  }\r\n\r\n  function getTipo() {\r\n    vm.tipo = StorageService.getTipo();\r\n  }\r\n\r\n  vm.changeTipo = () => {\r\n    StorageService.setTipo(vm.tipo);\r\n    getRank();\r\n  };\r\n}\r\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2NvbW1vbnMvaG9tZS9ob21lLmNvbnRyb2xsZXIuanM/M2I3MiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIxOC5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gQ29udHJvbGxlcjtcclxuXHJcbkNvbnRyb2xsZXIuJGluamVjdCA9IFtcIlN0b3JhZ2VTZXJ2aWNlXCJdO1xyXG5cclxuZnVuY3Rpb24gQ29udHJvbGxlcihTdG9yYWdlU2VydmljZSkge1xyXG4gIGNvbnN0IHZtID0gdGhpcztcclxuXHJcbiAgaW5pdCgpO1xyXG5cclxuICBmdW5jdGlvbiBpbml0KCkge1xyXG4gICAgZ2V0UmFuaygpO1xyXG4gICAgZ2V0VGlwbygpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZ2V0UmFuaygpIHtcclxuICAgIHZtLnJhbmtpbmcgPSBTdG9yYWdlU2VydmljZS5nZXRSYW5raW5nKCk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBnZXRUaXBvKCkge1xyXG4gICAgdm0udGlwbyA9IFN0b3JhZ2VTZXJ2aWNlLmdldFRpcG8oKTtcclxuICB9XHJcblxyXG4gIHZtLmNoYW5nZVRpcG8gPSAoKSA9PiB7XHJcbiAgICBTdG9yYWdlU2VydmljZS5zZXRUaXBvKHZtLnRpcG8pO1xyXG4gICAgZ2V0UmFuaygpO1xyXG4gIH07XHJcbn1cclxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///18\n')},function(module,exports,__webpack_require__){eval('const angular = __webpack_require__(0);\r\n__webpack_require__(20);\r\n\r\nmodule.exports = angular\r\n  .module("db1.jogo", [])\r\n  .controller("db1.jogo.JogoController", __webpack_require__(21))\r\n  .config(__webpack_require__(39)).name;\r\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2NvbW1vbnMvam9nby9qb2dvLm1vZHVsZS5qcz9hZDZjIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGdCQUFnQixtQkFBTyxDQUFDLENBQVM7QUFDakMsbUJBQU8sQ0FBQyxFQUFZOztBQUVwQjtBQUNBO0FBQ0EseUNBQXlDLG1CQUFPLENBQUMsRUFBbUI7QUFDcEUsVUFBVSxtQkFBTyxDQUFDLEVBQWUiLCJmaWxlIjoiMTkuanMiLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBhbmd1bGFyID0gcmVxdWlyZShcImFuZ3VsYXJcIik7XHJcbnJlcXVpcmUoXCIuL2pvZ28uY3NzXCIpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBhbmd1bGFyXHJcbiAgLm1vZHVsZShcImRiMS5qb2dvXCIsIFtdKVxyXG4gIC5jb250cm9sbGVyKFwiZGIxLmpvZ28uSm9nb0NvbnRyb2xsZXJcIiwgcmVxdWlyZShcIi4vam9nby5jb250cm9sbGVyXCIpKVxyXG4gIC5jb25maWcocmVxdWlyZShcIi4vam9nby5zdGF0ZXNcIikpLm5hbWU7XHJcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///19\n')},function(module,exports,__webpack_require__){eval("// extracted by mini-css-extract-plugin\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2NvbW1vbnMvam9nby9qb2dvLmNzcz9lNGM5Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBIiwiZmlsZSI6IjIwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///20\n")},function(module,exports,__webpack_require__){eval('const angular = __webpack_require__(0);\r\n\r\nconst NOVOJOGO = "NOVOJOGO";\r\nconst SELECAONOME = "SELECAONOME";\r\nconst JOGOCOMPLETADO = "JOGOCOMPLETADO";\r\nconst TOTALIMAGENS = 15;\r\n\r\nmodule.exports = Controller;\r\n\r\nController.$inject = ["$scope", "StorageService"];\r\n\r\nfunction Controller($scope, StorageService) {\r\n  const vm = this;\r\n\r\n  const images = [];\r\n\r\n  let selecionadas = [];\r\n  let completadas = [];\r\n  let totalCartas = null;\r\n  let cronometro = true;\r\n\r\n  //mtodos externos\r\n  vm.iniciarNovoJogo = iniciarNovoJogo;\r\n  vm.selecionaCarta = selecionaCarta;\r\n  vm.isRodada = isRodada;\r\n\r\n  init();\r\n\r\n  function init() {\r\n    vm.NOVOJOGO = NOVOJOGO;\r\n    vm.SELECAONOME = SELECAONOME;\r\n    vm.JOGOCOMPLETADO = JOGOCOMPLETADO;\r\n    vm.estado = vm.SELECAONOME;\r\n    carregaImagens();\r\n    getTipo();\r\n  }\r\n\r\n  function zeraVariaveis() {\r\n    selecionadas = [];\r\n    completadas = [];\r\n    totalCartas = null;\r\n    cronometro = true;\r\n    vm.rodada = 0;\r\n  }\r\n\r\n  function getTipo() {\r\n    vm.tipo = StorageService.getTipo();\r\n  }\r\n\r\n  function isRodada() {\r\n    return vm.tipo === "rodada";\r\n  }\r\n\r\n  function carregaImagens() {\r\n    for (let index = 1; index <= TOTALIMAGENS; index++) {\r\n      images.push({\r\n        id: index,\r\n        image: __webpack_require__(22)(`./${index}.jpg`)\r\n      });\r\n    }\r\n  }\r\n\r\n  function selecionaCarta(carta, index) {\r\n    if (selecionadas.length > 1 || carta.virada) return;\r\n    carta.virada = true;\r\n    carta.class = { "is-flipped": true };\r\n    verificaCarta(index);\r\n  }\r\n\r\n  function verificaCarta(index) {\r\n    if (!selecionadas.length) return selecionadas.push(index);\r\n    selecionadas.push(index);\r\n\r\n    if (isRodada()) vm.rodada++;\r\n\r\n    if (!verificaCartaIgual()) return desviraCartasSelecionadas();\r\n    return salvaCartasCertas();\r\n  }\r\n\r\n  function verificaCartaIgual() {\r\n    return vm.cartas[selecionadas[0]].id === vm.cartas[selecionadas[1]].id;\r\n  }\r\n\r\n  function desviraCartasSelecionadas() {\r\n    setTimeout(() => {\r\n      selecionadas.forEach(index => {\r\n        vm.cartas[index].class = { "is-flipped": false };\r\n        vm.cartas[index].virada = false;\r\n      });\r\n      limpaSelecionadas();\r\n      $scope.$apply();\r\n    }, 1000);\r\n  }\r\n\r\n  function salvaCartasCertas() {\r\n    completadas = completadas.concat(selecionadas);\r\n    limpaSelecionadas();\r\n    verificaSeAcertouTodos();\r\n  }\r\n\r\n  function limpaSelecionadas() {\r\n    selecionadas = [];\r\n  }\r\n\r\n  function verificaSeAcertouTodos() {\r\n    if (completadas.length !== totalCartas) return;\r\n\r\n    pararCronometro();\r\n    setTimeout(() => {\r\n      mostraResultadoFinal();\r\n      $scope.$apply();\r\n    }, 1000);\r\n  }\r\n\r\n  function mostraResultadoFinal() {\r\n    let value = isRodada() ? vm.rodada : vm.tempo;\r\n    StorageService.adicionaNovoRanking(vm.nome, value);\r\n    vm.estado = vm.JOGOCOMPLETADO;\r\n  }\r\n\r\n  function iniciarNovoJogo() {\r\n    zeraVariaveis();\r\n    vm.estado = NOVOJOGO;\r\n    vm.cartas = angular\r\n      .copy(images)\r\n      .concat(angular.copy(images))\r\n      .sort(misturaImagens);\r\n    totalCartas = vm.cartas.length;\r\n\r\n    if (!isRodada()) iniciaCronometro();\r\n\r\n    function misturaImagens() {\r\n      let a = Math.floor(Math.random() * 60);\r\n      let b = Math.floor(Math.random() * 120);\r\n      return a > b ? -1 : 1;\r\n    }\r\n  }\r\n\r\n  function pararCronometro() {\r\n    cronometro = false;\r\n  }\r\n\r\n  function iniciaCronometro() {\r\n    cronometro = true;\r\n    vm.tempo = 0;\r\n\r\n    loopTempo();\r\n    function loopTempo() {\r\n      setTimeout(() => {\r\n        vm.tempo++;\r\n        $scope.$apply();\r\n        if (cronometro) return loopTempo();\r\n      }, 1000);\r\n    }\r\n  }\r\n}\r\n\r\n/*\r\nMART\r\nfazer um modo dificil on quando acertar os pares ele remover e colocar uma delas em uma lista de completadas e reordenar a grid\r\n*/\r\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2NvbW1vbnMvam9nby9qb2dvLmNvbnRyb2xsZXIuanM/ODIwNSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxnQkFBZ0IsbUJBQU8sQ0FBQyxDQUFTOztBQUVqQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1Qix1QkFBdUI7QUFDOUM7QUFDQTtBQUNBLGVBQWUsd0JBQVEsR0FBcUIsRUFBRSxNQUFNLEtBQUssQ0FBQztBQUMxRCxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjIxLmpzIiwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgYW5ndWxhciA9IHJlcXVpcmUoXCJhbmd1bGFyXCIpO1xyXG5cclxuY29uc3QgTk9WT0pPR08gPSBcIk5PVk9KT0dPXCI7XHJcbmNvbnN0IFNFTEVDQU9OT01FID0gXCJTRUxFQ0FPTk9NRVwiO1xyXG5jb25zdCBKT0dPQ09NUExFVEFETyA9IFwiSk9HT0NPTVBMRVRBRE9cIjtcclxuY29uc3QgVE9UQUxJTUFHRU5TID0gMTU7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENvbnRyb2xsZXI7XHJcblxyXG5Db250cm9sbGVyLiRpbmplY3QgPSBbXCIkc2NvcGVcIiwgXCJTdG9yYWdlU2VydmljZVwiXTtcclxuXHJcbmZ1bmN0aW9uIENvbnRyb2xsZXIoJHNjb3BlLCBTdG9yYWdlU2VydmljZSkge1xyXG4gIGNvbnN0IHZtID0gdGhpcztcclxuXHJcbiAgY29uc3QgaW1hZ2VzID0gW107XHJcblxyXG4gIGxldCBzZWxlY2lvbmFkYXMgPSBbXTtcclxuICBsZXQgY29tcGxldGFkYXMgPSBbXTtcclxuICBsZXQgdG90YWxDYXJ0YXMgPSBudWxsO1xyXG4gIGxldCBjcm9ub21ldHJvID0gdHJ1ZTtcclxuXHJcbiAgLy9tw6l0b2RvcyBleHRlcm5vc1xyXG4gIHZtLmluaWNpYXJOb3ZvSm9nbyA9IGluaWNpYXJOb3ZvSm9nbztcclxuICB2bS5zZWxlY2lvbmFDYXJ0YSA9IHNlbGVjaW9uYUNhcnRhO1xyXG4gIHZtLmlzUm9kYWRhID0gaXNSb2RhZGE7XHJcblxyXG4gIGluaXQoKTtcclxuXHJcbiAgZnVuY3Rpb24gaW5pdCgpIHtcclxuICAgIHZtLk5PVk9KT0dPID0gTk9WT0pPR087XHJcbiAgICB2bS5TRUxFQ0FPTk9NRSA9IFNFTEVDQU9OT01FO1xyXG4gICAgdm0uSk9HT0NPTVBMRVRBRE8gPSBKT0dPQ09NUExFVEFETztcclxuICAgIHZtLmVzdGFkbyA9IHZtLlNFTEVDQU9OT01FO1xyXG4gICAgY2FycmVnYUltYWdlbnMoKTtcclxuICAgIGdldFRpcG8oKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHplcmFWYXJpYXZlaXMoKSB7XHJcbiAgICBzZWxlY2lvbmFkYXMgPSBbXTtcclxuICAgIGNvbXBsZXRhZGFzID0gW107XHJcbiAgICB0b3RhbENhcnRhcyA9IG51bGw7XHJcbiAgICBjcm9ub21ldHJvID0gdHJ1ZTtcclxuICAgIHZtLnJvZGFkYSA9IDA7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBnZXRUaXBvKCkge1xyXG4gICAgdm0udGlwbyA9IFN0b3JhZ2VTZXJ2aWNlLmdldFRpcG8oKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGlzUm9kYWRhKCkge1xyXG4gICAgcmV0dXJuIHZtLnRpcG8gPT09IFwicm9kYWRhXCI7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBjYXJyZWdhSW1hZ2VucygpIHtcclxuICAgIGZvciAobGV0IGluZGV4ID0gMTsgaW5kZXggPD0gVE9UQUxJTUFHRU5TOyBpbmRleCsrKSB7XHJcbiAgICAgIGltYWdlcy5wdXNoKHtcclxuICAgICAgICBpZDogaW5kZXgsXHJcbiAgICAgICAgaW1hZ2U6IHJlcXVpcmUoYC4uLy4uLy4uL2Fzc2V0cy9pbWcvJHtpbmRleH0uanBnYClcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBzZWxlY2lvbmFDYXJ0YShjYXJ0YSwgaW5kZXgpIHtcclxuICAgIGlmIChzZWxlY2lvbmFkYXMubGVuZ3RoID4gMSB8fCBjYXJ0YS52aXJhZGEpIHJldHVybjtcclxuICAgIGNhcnRhLnZpcmFkYSA9IHRydWU7XHJcbiAgICBjYXJ0YS5jbGFzcyA9IHsgXCJpcy1mbGlwcGVkXCI6IHRydWUgfTtcclxuICAgIHZlcmlmaWNhQ2FydGEoaW5kZXgpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gdmVyaWZpY2FDYXJ0YShpbmRleCkge1xyXG4gICAgaWYgKCFzZWxlY2lvbmFkYXMubGVuZ3RoKSByZXR1cm4gc2VsZWNpb25hZGFzLnB1c2goaW5kZXgpO1xyXG4gICAgc2VsZWNpb25hZGFzLnB1c2goaW5kZXgpO1xyXG5cclxuICAgIGlmIChpc1JvZGFkYSgpKSB2bS5yb2RhZGErKztcclxuXHJcbiAgICBpZiAoIXZlcmlmaWNhQ2FydGFJZ3VhbCgpKSByZXR1cm4gZGVzdmlyYUNhcnRhc1NlbGVjaW9uYWRhcygpO1xyXG4gICAgcmV0dXJuIHNhbHZhQ2FydGFzQ2VydGFzKCk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiB2ZXJpZmljYUNhcnRhSWd1YWwoKSB7XHJcbiAgICByZXR1cm4gdm0uY2FydGFzW3NlbGVjaW9uYWRhc1swXV0uaWQgPT09IHZtLmNhcnRhc1tzZWxlY2lvbmFkYXNbMV1dLmlkO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZGVzdmlyYUNhcnRhc1NlbGVjaW9uYWRhcygpIHtcclxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICBzZWxlY2lvbmFkYXMuZm9yRWFjaChpbmRleCA9PiB7XHJcbiAgICAgICAgdm0uY2FydGFzW2luZGV4XS5jbGFzcyA9IHsgXCJpcy1mbGlwcGVkXCI6IGZhbHNlIH07XHJcbiAgICAgICAgdm0uY2FydGFzW2luZGV4XS52aXJhZGEgPSBmYWxzZTtcclxuICAgICAgfSk7XHJcbiAgICAgIGxpbXBhU2VsZWNpb25hZGFzKCk7XHJcbiAgICAgICRzY29wZS4kYXBwbHkoKTtcclxuICAgIH0sIDEwMDApO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gc2FsdmFDYXJ0YXNDZXJ0YXMoKSB7XHJcbiAgICBjb21wbGV0YWRhcyA9IGNvbXBsZXRhZGFzLmNvbmNhdChzZWxlY2lvbmFkYXMpO1xyXG4gICAgbGltcGFTZWxlY2lvbmFkYXMoKTtcclxuICAgIHZlcmlmaWNhU2VBY2VydG91VG9kb3MoKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGxpbXBhU2VsZWNpb25hZGFzKCkge1xyXG4gICAgc2VsZWNpb25hZGFzID0gW107XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiB2ZXJpZmljYVNlQWNlcnRvdVRvZG9zKCkge1xyXG4gICAgaWYgKGNvbXBsZXRhZGFzLmxlbmd0aCAhPT0gdG90YWxDYXJ0YXMpIHJldHVybjtcclxuXHJcbiAgICBwYXJhckNyb25vbWV0cm8oKTtcclxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICBtb3N0cmFSZXN1bHRhZG9GaW5hbCgpO1xyXG4gICAgICAkc2NvcGUuJGFwcGx5KCk7XHJcbiAgICB9LCAxMDAwKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIG1vc3RyYVJlc3VsdGFkb0ZpbmFsKCkge1xyXG4gICAgbGV0IHZhbHVlID0gaXNSb2RhZGEoKSA/IHZtLnJvZGFkYSA6IHZtLnRlbXBvO1xyXG4gICAgU3RvcmFnZVNlcnZpY2UuYWRpY2lvbmFOb3ZvUmFua2luZyh2bS5ub21lLCB2YWx1ZSk7XHJcbiAgICB2bS5lc3RhZG8gPSB2bS5KT0dPQ09NUExFVEFETztcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGluaWNpYXJOb3ZvSm9nbygpIHtcclxuICAgIHplcmFWYXJpYXZlaXMoKTtcclxuICAgIHZtLmVzdGFkbyA9IE5PVk9KT0dPO1xyXG4gICAgdm0uY2FydGFzID0gYW5ndWxhclxyXG4gICAgICAuY29weShpbWFnZXMpXHJcbiAgICAgIC5jb25jYXQoYW5ndWxhci5jb3B5KGltYWdlcykpXHJcbiAgICAgIC5zb3J0KG1pc3R1cmFJbWFnZW5zKTtcclxuICAgIHRvdGFsQ2FydGFzID0gdm0uY2FydGFzLmxlbmd0aDtcclxuXHJcbiAgICBpZiAoIWlzUm9kYWRhKCkpIGluaWNpYUNyb25vbWV0cm8oKTtcclxuXHJcbiAgICBmdW5jdGlvbiBtaXN0dXJhSW1hZ2VucygpIHtcclxuICAgICAgbGV0IGEgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiA2MCk7XHJcbiAgICAgIGxldCBiID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTIwKTtcclxuICAgICAgcmV0dXJuIGEgPiBiID8gLTEgOiAxO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcGFyYXJDcm9ub21ldHJvKCkge1xyXG4gICAgY3Jvbm9tZXRybyA9IGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gaW5pY2lhQ3Jvbm9tZXRybygpIHtcclxuICAgIGNyb25vbWV0cm8gPSB0cnVlO1xyXG4gICAgdm0udGVtcG8gPSAwO1xyXG5cclxuICAgIGxvb3BUZW1wbygpO1xyXG4gICAgZnVuY3Rpb24gbG9vcFRlbXBvKCkge1xyXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICB2bS50ZW1wbysrO1xyXG4gICAgICAgICRzY29wZS4kYXBwbHkoKTtcclxuICAgICAgICBpZiAoY3Jvbm9tZXRybykgcmV0dXJuIGxvb3BUZW1wbygpO1xyXG4gICAgICB9LCAxMDAwKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbi8qXHJcbk1BUlRcclxuZmF6ZXIgdW0gbW9kbyBkaWZpY2lsIG9uIHF1YW5kbyBhY2VydGFyIG9zIHBhcmVzIGVsZSByZW1vdmVyIGUgY29sb2NhciB1bWEgZGVsYXMgZW0gdW1hIGxpc3RhIGRlIGNvbXBsZXRhZGFzIGUgcmVvcmRlbmFyIGEgZ3JpZFxyXG4qL1xyXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///21\n')},,function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__.p + "images/1.jpg";\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL2ltZy8xLmpwZz85ZTg3Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGlCQUFpQixxQkFBdUIiLCJmaWxlIjoiMjMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19wdWJsaWNfcGF0aF9fICsgXCJpbWFnZXMvMS5qcGdcIjsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///23\n')},function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__.p + "images/10.jpg";\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL2ltZy8xMC5qcGc/OWZhYiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxpQkFBaUIscUJBQXVCIiwiZmlsZSI6IjI0LmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcHVibGljX3BhdGhfXyArIFwiaW1hZ2VzLzEwLmpwZ1wiOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///24\n')},function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__.p + "images/11.jpg";\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL2ltZy8xMS5qcGc/ZGQyNyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxpQkFBaUIscUJBQXVCIiwiZmlsZSI6IjI1LmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcHVibGljX3BhdGhfXyArIFwiaW1hZ2VzLzExLmpwZ1wiOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///25\n')},function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__.p + "images/12.jpg";\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL2ltZy8xMi5qcGc/MmRmYyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxpQkFBaUIscUJBQXVCIiwiZmlsZSI6IjI2LmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcHVibGljX3BhdGhfXyArIFwiaW1hZ2VzLzEyLmpwZ1wiOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///26\n')},function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__.p + "images/13.jpg";\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL2ltZy8xMy5qcGc/OGZhNyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxpQkFBaUIscUJBQXVCIiwiZmlsZSI6IjI3LmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcHVibGljX3BhdGhfXyArIFwiaW1hZ2VzLzEzLmpwZ1wiOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///27\n')},function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__.p + "images/14.jpg";\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL2ltZy8xNC5qcGc/ZDIyZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxpQkFBaUIscUJBQXVCIiwiZmlsZSI6IjI4LmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcHVibGljX3BhdGhfXyArIFwiaW1hZ2VzLzE0LmpwZ1wiOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///28\n')},function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__.p + "images/15.jpg";\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL2ltZy8xNS5qcGc/YjIxZCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxpQkFBaUIscUJBQXVCIiwiZmlsZSI6IjI5LmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcHVibGljX3BhdGhfXyArIFwiaW1hZ2VzLzE1LmpwZ1wiOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///29\n')},function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__.p + "images/2.jpg";\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL2ltZy8yLmpwZz9jYzU5Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGlCQUFpQixxQkFBdUIiLCJmaWxlIjoiMzAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19wdWJsaWNfcGF0aF9fICsgXCJpbWFnZXMvMi5qcGdcIjsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///30\n')},function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__.p + "images/3.jpg";\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL2ltZy8zLmpwZz8zMGUxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGlCQUFpQixxQkFBdUIiLCJmaWxlIjoiMzEuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19wdWJsaWNfcGF0aF9fICsgXCJpbWFnZXMvMy5qcGdcIjsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///31\n')},function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__.p + "images/4.jpg";\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL2ltZy80LmpwZz9hYzJlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGlCQUFpQixxQkFBdUIiLCJmaWxlIjoiMzIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19wdWJsaWNfcGF0aF9fICsgXCJpbWFnZXMvNC5qcGdcIjsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///32\n')},function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__.p + "images/5.jpg";\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL2ltZy81LmpwZz8wNjMzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGlCQUFpQixxQkFBdUIiLCJmaWxlIjoiMzMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19wdWJsaWNfcGF0aF9fICsgXCJpbWFnZXMvNS5qcGdcIjsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///33\n')},function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__.p + "images/6.jpg";\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL2ltZy82LmpwZz9mMmFmIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGlCQUFpQixxQkFBdUIiLCJmaWxlIjoiMzQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19wdWJsaWNfcGF0aF9fICsgXCJpbWFnZXMvNi5qcGdcIjsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///34\n')},function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__.p + "images/7.jpg";\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL2ltZy83LmpwZz8xYzNhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGlCQUFpQixxQkFBdUIiLCJmaWxlIjoiMzUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19wdWJsaWNfcGF0aF9fICsgXCJpbWFnZXMvNy5qcGdcIjsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///35\n')},function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__.p + "images/8.jpg";\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL2ltZy84LmpwZz9hNTU2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGlCQUFpQixxQkFBdUIiLCJmaWxlIjoiMzYuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19wdWJsaWNfcGF0aF9fICsgXCJpbWFnZXMvOC5qcGdcIjsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///36\n')},function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__.p + "images/9.jpg";\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL2ltZy85LmpwZz84NWIxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGlCQUFpQixxQkFBdUIiLCJmaWxlIjoiMzcuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19wdWJsaWNfcGF0aF9fICsgXCJpbWFnZXMvOS5qcGdcIjsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///37\n')},function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__.p + "images/textura.jpg";\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL2ltZy90ZXh0dXJhLmpwZz80YTZmIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGlCQUFpQixxQkFBdUIiLCJmaWxlIjoiMzguanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19wdWJsaWNfcGF0aF9fICsgXCJpbWFnZXMvdGV4dHVyYS5qcGdcIjsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///38\n')},function(module,exports,__webpack_require__){eval('module.exports = states;\r\n\r\nstates.$inject = ["$stateProvider"];\r\n\r\nfunction states($stateProvider) {\r\n  $stateProvider.state("main.jogo", {\r\n    url: "/jogo",\r\n    views: {\r\n      "@main": {\r\n        template: __webpack_require__(40),\r\n        controller: "db1.jogo.JogoController as vm"\r\n      }\r\n    }\r\n  });\r\n}\r\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2NvbW1vbnMvam9nby9qb2dvLnN0YXRlcy5qcz9mMjcxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsbUJBQU8sQ0FBQyxFQUFhO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCIsImZpbGUiOiIzOS5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gc3RhdGVzO1xyXG5cclxuc3RhdGVzLiRpbmplY3QgPSBbXCIkc3RhdGVQcm92aWRlclwiXTtcclxuXHJcbmZ1bmN0aW9uIHN0YXRlcygkc3RhdGVQcm92aWRlcikge1xyXG4gICRzdGF0ZVByb3ZpZGVyLnN0YXRlKFwibWFpbi5qb2dvXCIsIHtcclxuICAgIHVybDogXCIvam9nb1wiLFxyXG4gICAgdmlld3M6IHtcclxuICAgICAgXCJAbWFpblwiOiB7XHJcbiAgICAgICAgdGVtcGxhdGU6IHJlcXVpcmUoXCIuL2pvZ28uaHRtbFwiKSxcclxuICAgICAgICBjb250cm9sbGVyOiBcImRiMS5qb2dvLkpvZ29Db250cm9sbGVyIGFzIHZtXCJcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0pO1xyXG59XHJcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///39\n')},function(module,exports){eval('module.exports = "<header class=\\"masthead bg-primary text-white text-center\\" ng-if=\\"vm.estado === vm.NOVOJOGO\\"> <div class=container> <div class=container> <h1 ng-if=!vm.isRodada()>{{ vm.tempo | customTime }}</h1> <h1 ng-if=vm.isRodada()>{{ vm.rodada }}</h1> </div> </div> </header> <section class=\\"bg-primary text-white mb-0\\" ng-if=\\"vm.estado === vm.NOVOJOGO\\"> <div class=\\"container tela\\"> <app-carta ng-repeat=\\"carta in vm.cartas track by $index\\" carta=carta click=\\"vm.selecionaCarta(carta, $index)\\">*{{ carta }}*</app-carta> </div> </section> <div class=\\"d-flex justify-content-center align-items-center s-center\\" style=min-height:200px ng-if=\\"vm.estado === vm.SELECAONOME\\"> <div class=\\"card bg-info\\"> <div class=\\"card-body text-center\\"> <p class=card-text>Insira seu nome</p> <form class=\\"form-inline my-4 my-lg-0\\" name=form> <input class=\\"form-control mr-sm-2\\" required type=text maxlength=20 ng-model=vm.nome placeholder=Nome /> <button class=\\"btn btn-success my-2 my-sm-0\\" type=button ng-disabled=form.$invalid ng-click=vm.iniciarNovoJogo()> Comear </button> </form> </div> </div> </div> <div class=\\"d-flex justify-content-center align-items-center s-center\\" style=min-height:200px ng-if=\\"vm.estado === vm.JOGOCOMPLETADO\\"> <div class=\\"card bg-info\\"> <div class=\\"card-body text-center\\"> <h2>Parabns</h2> <p class=card-text ng-if=!vm.isRodada()> Seu tempo foi: <b>{{ vm.tempo | customTime }}</b> </p> <p class=card-text ng-if=vm.isRodada()> Voc conseguiu em <b>{{ vm.rodada }}</b> rodadas. </p> <button class=\\"btn btn-success my-2 my-sm-0\\" type=button ng-click=vm.iniciarNovoJogo()> Jogar novamente </button> <button class=\\"btn btn-success my-2 my-sm-0\\" type=button ui-sref=main.home> Ir para ranking </button> </div> </div> </div> ";\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2NvbW1vbnMvam9nby9qb2dvLmh0bWw/ZGM0OSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSwyTEFBMkwseUJBQXlCLGdDQUFnQyxhQUFhLHNRQUFzUSxTQUFTLGkzQkFBaTNCLHlCQUF5Qix5RUFBeUUsYUFBYSIsImZpbGUiOiI0MC5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gXCI8aGVhZGVyIGNsYXNzPVxcXCJtYXN0aGVhZCBiZy1wcmltYXJ5IHRleHQtd2hpdGUgdGV4dC1jZW50ZXJcXFwiIG5nLWlmPVxcXCJ2bS5lc3RhZG8gPT09IHZtLk5PVk9KT0dPXFxcIj4gPGRpdiBjbGFzcz1jb250YWluZXI+IDxkaXYgY2xhc3M9Y29udGFpbmVyPiA8aDEgbmctaWY9IXZtLmlzUm9kYWRhKCk+e3sgdm0udGVtcG8gfCBjdXN0b21UaW1lIH19PC9oMT4gPGgxIG5nLWlmPXZtLmlzUm9kYWRhKCk+e3sgdm0ucm9kYWRhIH19PC9oMT4gPC9kaXY+IDwvZGl2PiA8L2hlYWRlcj4gPHNlY3Rpb24gY2xhc3M9XFxcImJnLXByaW1hcnkgdGV4dC13aGl0ZSBtYi0wXFxcIiBuZy1pZj1cXFwidm0uZXN0YWRvID09PSB2bS5OT1ZPSk9HT1xcXCI+IDxkaXYgY2xhc3M9XFxcImNvbnRhaW5lciB0ZWxhXFxcIj4gPGFwcC1jYXJ0YSBuZy1yZXBlYXQ9XFxcImNhcnRhIGluIHZtLmNhcnRhcyB0cmFjayBieSAkaW5kZXhcXFwiIGNhcnRhPWNhcnRhIGNsaWNrPVxcXCJ2bS5zZWxlY2lvbmFDYXJ0YShjYXJ0YSwgJGluZGV4KVxcXCI+Knt7IGNhcnRhIH19KjwvYXBwLWNhcnRhPiA8L2Rpdj4gPC9zZWN0aW9uPiA8ZGl2IGNsYXNzPVxcXCJkLWZsZXgganVzdGlmeS1jb250ZW50LWNlbnRlciBhbGlnbi1pdGVtcy1jZW50ZXIgcy1jZW50ZXJcXFwiIHN0eWxlPW1pbi1oZWlnaHQ6MjAwcHggbmctaWY9XFxcInZtLmVzdGFkbyA9PT0gdm0uU0VMRUNBT05PTUVcXFwiPiA8ZGl2IGNsYXNzPVxcXCJjYXJkIGJnLWluZm9cXFwiPiA8ZGl2IGNsYXNzPVxcXCJjYXJkLWJvZHkgdGV4dC1jZW50ZXJcXFwiPiA8cCBjbGFzcz1jYXJkLXRleHQ+SW5zaXJhIHNldSBub21lPC9wPiA8Zm9ybSBjbGFzcz1cXFwiZm9ybS1pbmxpbmUgbXktNCBteS1sZy0wXFxcIiBuYW1lPWZvcm0+IDxpbnB1dCBjbGFzcz1cXFwiZm9ybS1jb250cm9sIG1yLXNtLTJcXFwiIHJlcXVpcmVkIHR5cGU9dGV4dCBtYXhsZW5ndGg9MjAgbmctbW9kZWw9dm0ubm9tZSBwbGFjZWhvbGRlcj1Ob21lIC8+IDxidXR0b24gY2xhc3M9XFxcImJ0biBidG4tc3VjY2VzcyBteS0yIG15LXNtLTBcXFwiIHR5cGU9YnV0dG9uIG5nLWRpc2FibGVkPWZvcm0uJGludmFsaWQgbmctY2xpY2s9dm0uaW5pY2lhck5vdm9Kb2dvKCk+IENvbWXDp2FyIDwvYnV0dG9uPiA8L2Zvcm0+IDwvZGl2PiA8L2Rpdj4gPC9kaXY+IDxkaXYgY2xhc3M9XFxcImQtZmxleCBqdXN0aWZ5LWNvbnRlbnQtY2VudGVyIGFsaWduLWl0ZW1zLWNlbnRlciBzLWNlbnRlclxcXCIgc3R5bGU9bWluLWhlaWdodDoyMDBweCBuZy1pZj1cXFwidm0uZXN0YWRvID09PSB2bS5KT0dPQ09NUExFVEFET1xcXCI+IDxkaXYgY2xhc3M9XFxcImNhcmQgYmctaW5mb1xcXCI+IDxkaXYgY2xhc3M9XFxcImNhcmQtYm9keSB0ZXh0LWNlbnRlclxcXCI+IDxoMj5QYXJhYsOpbnM8L2gyPiA8cCBjbGFzcz1jYXJkLXRleHQgbmctaWY9IXZtLmlzUm9kYWRhKCk+IFNldSB0ZW1wbyBmb2k6IDxiPnt7IHZtLnRlbXBvIHwgY3VzdG9tVGltZSB9fTwvYj4gPC9wPiA8cCBjbGFzcz1jYXJkLXRleHQgbmctaWY9dm0uaXNSb2RhZGEoKT4gVm9jw6ogY29uc2VndWl1IGVtIDxiPnt7IHZtLnJvZGFkYSB9fTwvYj4gcm9kYWRhcy4gPC9wPiA8YnV0dG9uIGNsYXNzPVxcXCJidG4gYnRuLXN1Y2Nlc3MgbXktMiBteS1zbS0wXFxcIiB0eXBlPWJ1dHRvbiBuZy1jbGljaz12bS5pbmljaWFyTm92b0pvZ28oKT4gSm9nYXIgbm92YW1lbnRlIDwvYnV0dG9uPiA8YnV0dG9uIGNsYXNzPVxcXCJidG4gYnRuLXN1Y2Nlc3MgbXktMiBteS1zbS0wXFxcIiB0eXBlPWJ1dHRvbiB1aS1zcmVmPW1haW4uaG9tZT4gSXIgcGFyYSByYW5raW5nIDwvYnV0dG9uPiA8L2Rpdj4gPC9kaXY+IDwvZGl2PiBcIjsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///40\n')},function(module,exports,__webpack_require__){eval('module.exports = states;\r\n\r\nstates.$inject = ["$stateProvider", "$urlRouterProvider"];\r\n\r\nfunction states($stateProvider, $urlRouterProvider) {\r\n  $urlRouterProvider.otherwise("/home");\r\n\r\n  $stateProvider\r\n    .state("main", {\r\n      abstract: true,\r\n      reloadOnSearch: false\r\n    })\r\n    .state("main.home", {\r\n      url: "/home",\r\n      views: {\r\n        "@main": {\r\n          template: __webpack_require__(42),\r\n          controller: "db1.home.HomeController as vm"\r\n        }\r\n      }\r\n    });\r\n}\r\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2RiMS5zdGF0ZXMuanM/MzU1YSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFPLENBQUMsRUFBMEI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMIiwiZmlsZSI6IjQxLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBzdGF0ZXM7XHJcblxyXG5zdGF0ZXMuJGluamVjdCA9IFtcIiRzdGF0ZVByb3ZpZGVyXCIsIFwiJHVybFJvdXRlclByb3ZpZGVyXCJdO1xyXG5cclxuZnVuY3Rpb24gc3RhdGVzKCRzdGF0ZVByb3ZpZGVyLCAkdXJsUm91dGVyUHJvdmlkZXIpIHtcclxuICAkdXJsUm91dGVyUHJvdmlkZXIub3RoZXJ3aXNlKFwiL2hvbWVcIik7XHJcblxyXG4gICRzdGF0ZVByb3ZpZGVyXHJcbiAgICAuc3RhdGUoXCJtYWluXCIsIHtcclxuICAgICAgYWJzdHJhY3Q6IHRydWUsXHJcbiAgICAgIHJlbG9hZE9uU2VhcmNoOiBmYWxzZVxyXG4gICAgfSlcclxuICAgIC5zdGF0ZShcIm1haW4uaG9tZVwiLCB7XHJcbiAgICAgIHVybDogXCIvaG9tZVwiLFxyXG4gICAgICB2aWV3czoge1xyXG4gICAgICAgIFwiQG1haW5cIjoge1xyXG4gICAgICAgICAgdGVtcGxhdGU6IHJlcXVpcmUoXCIuL2NvbW1vbnMvaG9tZS9ob21lLmh0bWxcIiksXHJcbiAgICAgICAgICBjb250cm9sbGVyOiBcImRiMS5ob21lLkhvbWVDb250cm9sbGVyIGFzIHZtXCJcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG59XHJcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///41\n')},function(module,exports){eval('module.exports = "<header class=\\"masthead bg-primary text-white text-center\\"> <div class=container> <div class=\\"form-check form-check-inline mt-5 mb-2\\"> <label>Tipo jogo: </label> <div class=form-check> <input class=form-check-input type=radio name=rad id=rad1 value=rodada ng-model=vm.tipo ng-change=vm.changeTipo()> <label class=form-check-label for=rad1> Rotada </label> </div> <div class=form-check> <input class=form-check-input type=radio name=rad id=rad2 value=tempo ng-model=vm.tipo ng-change=vm.changeTipo()> <label class=form-check-label for=exampleRadios2> Tempo </label> </div> </div> <h1 class=\\"text-uppercase mb-2\\">Jogo da memria</h1> <button class=\\"btn btn-success my-2 my-sm-0\\" type=button ui-sref=main.jogo> Jogar </button> <hr class=\\"star-light mb-0\\"/> </div> </header> <section class=\\"bg-primary text-white mb-0 pt-3 pb-5\\"> <div class=container> <h2 class=\\"text-center text-uppercase text-white\\">Ranking</h2> <hr class=\\"star-light mb-3\\"/> <h3 class=\\"text-center text-uppercase text-white pb-2\\">TOP 10</h3> <div class=\\"row justify-content-center\\"> <div class=col-md-6> <div class=\\"card bg-info\\" ng-if=vm.ranking.length> <div class=\\"text-center card-rank card-rank-title\\"> <div class=linha-rank> <p class=lead> </p><div class=col>Posio</div> <div class=col>Jogador</div> <div class=col>{{vm.tipo === \'tempo\' ? \'Tempo\' : \'Rodada\'}}</div> <p></p> </div> <hr class=\\"star-light mb-0 mt-2\\"/> </div> <div class=\\"text-center card-rank\\" ng-repeat=\\"rank in vm.ranking track by $index\\"> <div class=linha-rank> <p class=lead> </p><div class=col>{{$index + 1}}</div> <div class=col>{{rank.nome}} </div> <div class=col>{{vm.tipo === \'tempo\' ? (rank.value | customTime) : rank.value}} </div> <p></p> </div> <hr class=\\"star-light mb-0 mt-2\\"/> </div> </div> <div class=\\"card bg-info\\" ng-if=!vm.ranking.length> <div class=\\"text-center card-rank\\"> <p class=lead> Rank zerado </p> </div> </div> </div> </div> </div> </section> ";\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2NvbW1vbnMvaG9tZS9ob21lLmh0bWw/NjY2YSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxvekNBQW96QywwQ0FBMEMsb05BQW9OLFlBQVksd0JBQXdCLFdBQVcseUJBQXlCLDhEQUE4RCIsImZpbGUiOiI0Mi5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gXCI8aGVhZGVyIGNsYXNzPVxcXCJtYXN0aGVhZCBiZy1wcmltYXJ5IHRleHQtd2hpdGUgdGV4dC1jZW50ZXJcXFwiPiA8ZGl2IGNsYXNzPWNvbnRhaW5lcj4gPGRpdiBjbGFzcz1cXFwiZm9ybS1jaGVjayBmb3JtLWNoZWNrLWlubGluZSBtdC01IG1iLTJcXFwiPiA8bGFiZWw+VGlwbyBqb2dvOiA8L2xhYmVsPiA8ZGl2IGNsYXNzPWZvcm0tY2hlY2s+IDxpbnB1dCBjbGFzcz1mb3JtLWNoZWNrLWlucHV0IHR5cGU9cmFkaW8gbmFtZT1yYWQgaWQ9cmFkMSB2YWx1ZT1yb2RhZGEgbmctbW9kZWw9dm0udGlwbyBuZy1jaGFuZ2U9dm0uY2hhbmdlVGlwbygpPiA8bGFiZWwgY2xhc3M9Zm9ybS1jaGVjay1sYWJlbCBmb3I9cmFkMT4gUm90YWRhIDwvbGFiZWw+IDwvZGl2PiA8ZGl2IGNsYXNzPWZvcm0tY2hlY2s+IDxpbnB1dCBjbGFzcz1mb3JtLWNoZWNrLWlucHV0IHR5cGU9cmFkaW8gbmFtZT1yYWQgaWQ9cmFkMiB2YWx1ZT10ZW1wbyBuZy1tb2RlbD12bS50aXBvIG5nLWNoYW5nZT12bS5jaGFuZ2VUaXBvKCk+IDxsYWJlbCBjbGFzcz1mb3JtLWNoZWNrLWxhYmVsIGZvcj1leGFtcGxlUmFkaW9zMj4gVGVtcG8gPC9sYWJlbD4gPC9kaXY+IDwvZGl2PiA8aDEgY2xhc3M9XFxcInRleHQtdXBwZXJjYXNlIG1iLTJcXFwiPkpvZ28gZGEgbWVtw7NyaWE8L2gxPiA8YnV0dG9uIGNsYXNzPVxcXCJidG4gYnRuLXN1Y2Nlc3MgbXktMiBteS1zbS0wXFxcIiB0eXBlPWJ1dHRvbiB1aS1zcmVmPW1haW4uam9nbz4gSm9nYXIgPC9idXR0b24+IDxociBjbGFzcz1cXFwic3Rhci1saWdodCBtYi0wXFxcIi8+IDwvZGl2PiA8L2hlYWRlcj4gPHNlY3Rpb24gY2xhc3M9XFxcImJnLXByaW1hcnkgdGV4dC13aGl0ZSBtYi0wIHB0LTMgcGItNVxcXCI+IDxkaXYgY2xhc3M9Y29udGFpbmVyPiA8aDIgY2xhc3M9XFxcInRleHQtY2VudGVyIHRleHQtdXBwZXJjYXNlIHRleHQtd2hpdGVcXFwiPlJhbmtpbmc8L2gyPiA8aHIgY2xhc3M9XFxcInN0YXItbGlnaHQgbWItM1xcXCIvPiA8aDMgY2xhc3M9XFxcInRleHQtY2VudGVyIHRleHQtdXBwZXJjYXNlIHRleHQtd2hpdGUgcGItMlxcXCI+VE9QIDEwPC9oMz4gPGRpdiBjbGFzcz1cXFwicm93IGp1c3RpZnktY29udGVudC1jZW50ZXJcXFwiPiA8ZGl2IGNsYXNzPWNvbC1tZC02PiA8ZGl2IGNsYXNzPVxcXCJjYXJkIGJnLWluZm9cXFwiIG5nLWlmPXZtLnJhbmtpbmcubGVuZ3RoPiA8ZGl2IGNsYXNzPVxcXCJ0ZXh0LWNlbnRlciBjYXJkLXJhbmsgY2FyZC1yYW5rLXRpdGxlXFxcIj4gPGRpdiBjbGFzcz1saW5oYS1yYW5rPiA8cCBjbGFzcz1sZWFkPiA8L3A+PGRpdiBjbGFzcz1jb2w+UG9zacOnw6NvPC9kaXY+IDxkaXYgY2xhc3M9Y29sPkpvZ2Fkb3I8L2Rpdj4gPGRpdiBjbGFzcz1jb2w+e3t2bS50aXBvID09PSAndGVtcG8nID8gJ1RlbXBvJyA6ICdSb2RhZGEnfX08L2Rpdj4gPHA+PC9wPiA8L2Rpdj4gPGhyIGNsYXNzPVxcXCJzdGFyLWxpZ2h0IG1iLTAgbXQtMlxcXCIvPiA8L2Rpdj4gPGRpdiBjbGFzcz1cXFwidGV4dC1jZW50ZXIgY2FyZC1yYW5rXFxcIiBuZy1yZXBlYXQ9XFxcInJhbmsgaW4gdm0ucmFua2luZyB0cmFjayBieSAkaW5kZXhcXFwiPiA8ZGl2IGNsYXNzPWxpbmhhLXJhbms+IDxwIGNsYXNzPWxlYWQ+IDwvcD48ZGl2IGNsYXNzPWNvbD57eyRpbmRleCArIDF9fTwvZGl2PiA8ZGl2IGNsYXNzPWNvbD57e3Jhbmsubm9tZX19IDwvZGl2PiA8ZGl2IGNsYXNzPWNvbD57e3ZtLnRpcG8gPT09ICd0ZW1wbycgPyAocmFuay52YWx1ZSB8IGN1c3RvbVRpbWUpIDogcmFuay52YWx1ZX19IDwvZGl2PiA8cD48L3A+IDwvZGl2PiA8aHIgY2xhc3M9XFxcInN0YXItbGlnaHQgbWItMCBtdC0yXFxcIi8+IDwvZGl2PiA8L2Rpdj4gPGRpdiBjbGFzcz1cXFwiY2FyZCBiZy1pbmZvXFxcIiBuZy1pZj0hdm0ucmFua2luZy5sZW5ndGg+IDxkaXYgY2xhc3M9XFxcInRleHQtY2VudGVyIGNhcmQtcmFua1xcXCI+IDxwIGNsYXNzPWxlYWQ+IFJhbmsgemVyYWRvIDwvcD4gPC9kaXY+IDwvZGl2PiA8L2Rpdj4gPC9kaXY+IDwvZGl2PiA8L3NlY3Rpb24+IFwiOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///42\n')},function(module,exports,__webpack_require__){eval('const angular = __webpack_require__(0);\r\n__webpack_require__(1);\r\n\r\nmodule.exports = angular\r\n  .module("db1", [\r\n    "ui.router",\r\n    __webpack_require__(2),\r\n    __webpack_require__(4),\r\n    __webpack_require__(15)\r\n  ])\r\n  .config(__webpack_require__(41)).name;\r\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2RiMS5tb2R1bGUuanM/NzczMyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxnQkFBZ0IsbUJBQU8sQ0FBQyxDQUFTO0FBQ2pDLG1CQUFPLENBQUMsQ0FBVzs7QUFFbkI7QUFDQTtBQUNBO0FBQ0EsSUFBSSxtQkFBTyxDQUFDLENBQXNCO0FBQ2xDLElBQUksbUJBQU8sQ0FBQyxDQUFvQjtBQUNoQyxJQUFJLG1CQUFPLENBQUMsRUFBMEI7QUFDdEM7QUFDQSxVQUFVLG1CQUFPLENBQUMsRUFBYyIsImZpbGUiOiI0My5qcyIsInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGFuZ3VsYXIgPSByZXF1aXJlKFwiYW5ndWxhclwiKTtcclxucmVxdWlyZShcIi4vZGIxLmNzc1wiKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gYW5ndWxhclxyXG4gIC5tb2R1bGUoXCJkYjFcIiwgW1xyXG4gICAgXCJ1aS5yb3V0ZXJcIixcclxuICAgIHJlcXVpcmUoXCJhbmd1bGFyLXVpLWJvb3RzdHJhcFwiKSxcclxuICAgIHJlcXVpcmUoXCIuL2NvcmUvY29yZS5tb2R1bGVcIiksXHJcbiAgICByZXF1aXJlKFwiLi9jb21tb25zL2NvbW1vbnMubW9kdWxlXCIpXHJcbiAgXSlcclxuICAuY29uZmlnKHJlcXVpcmUoXCIuL2RiMS5zdGF0ZXNcIikpLm5hbWU7XHJcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///43\n')}]]);